<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><title>RFC 2068. Протокол передачи гипертекста -- HTTP/1.1 (перевод)</title></head>
<body bgcolor="white">
<center>
  <h3>RFC 2068. Спецификация протокола HTTP/1.1 (частичный перевод)</h3>
</center>

<table width="30%" align="right"><tbody><tr><td width="15">&nbsp;</td><td><br><li><a href="#">RFC 2068. Протокол передачи гипертекста -- HTTP/1.1 (перевод)</a>
</li><li><a href="#1">1 Введение.</a>
</li><li><a href="#2">1.1 Цель.</a>
</li><li><a href="#3">1.2 Требования.</a>
</li><li><a href="#4">1.3 Терминология.</a>
</li><li><a href="#5">1.4 Общее описание.</a>
</li><li><a href="#6">2 Письменные соглашения и обобщенная грамматика.</a>
</li><li><a href="#7">2.1 Увеличенная нормальная запись Бекуса-Наура (BNF).</a>
</li><li><a href="#8">2.2 Основные правила.</a>
</li><li><a href="#9">3 Параметры протокола.</a>
</li><li><a href="#10">3.1 Версия HTTP.</a>
</li><li><a href="#11">3.2 Универсальные Идентификаторы Ресурсов (URI).</a>
</li><li><a href="#12">3.2.1 Общий синтаксис.</a>
</li><li><a href="#13">3.2.2 HTTP URL.</a>
</li><li><a href="#14">3.2.3 Сравнение URI.</a>
</li><li><a href="#15">3.3 Форматы даты/времени.</a>
</li><li><a href="#16">3.3.1 Полная дата.</a>
</li><li><a href="#17">3.3.2 Разность секунд (delta seconds).</a>
</li><li><a href="#18">3.4 Кодовые таблицы (character sets).</a>
</li><li><a href="#19">3.5 Кодирование содержимого (content codings).</a>
</li><li><a href="#20">3.6 Кодирование передачи (Transfer Codings).</a>
</li><li><a href="#21">3.7 Медиа типы (Media Types).</a>
</li><li><a href="#22">3.7.1 Канонизация и предопределенные значения типа text.</a>
</li><li><a href="#23">3.7.2 Типы Multipart.</a>
</li><li><a href="#24">3.8 Лексемы программ (Product Tokens).</a>
</li><li><a href="#25">3.9 Качественные значения (Quality Values).</a>
</li><li><a href="#26">3.10 Метки языков (Language Tags).</a>
</li><li><a href="#27">3.11 Метки объектов (Entity Tags).</a>
</li><li><a href="#28">3.12 Еденицы измерения диапазонов (Range Units).</a>
</li><li><a href="#29">4 HTTP сообщение (HTTP Message).</a>
</li><li><a href="#30">4.1 Типы сообщений.</a>
</li><li><a href="#31">4.2 Заголовки сообщений.</a>
</li><li><a href="#32">4.3 Тело cообщения.</a>
</li><li><a href="#33">4.4 Длина сообщения.</a>
</li><li><a href="#34">4.5 Общие поля заголовка.</a>
</li><li><a href="#35">5 Запрос (Request).</a>
</li><li><a href="#36">5.1 Строка запроса (Request-Line).</a>
</li><li><a href="#37">5.1.1 Метод (Method).</a>
</li><li><a href="#38">5.1.2 Запрашиваемый URI (Request-URI).</a>
</li><li><a href="#39">5.2 Ресурс, идентифицируемый запросом.</a>
</li><li><a href="#40">5.3 Поля заголовка запроса.</a>
</li><li><a href="#41">6 Ответ (Response).</a>
</li><li><a href="#42">6.1 Строка состояния (Status-Line).</a>
</li><li><a href="#43">6.1.1 Код состояния и поясняющая фраза.</a>
</li><li><a href="#44">6.2 Поля заголовка ответа.</a>
</li><li><a href="#45">7 Объект (Entity).</a>
</li><li><a href="#46">7.1 Поля заголовка объекта.</a>
</li><li><a href="#47">7.2 Тело объекта.</a>
</li><li><a href="#48">7.2.1 Тип (Type).</a>
</li><li><a href="#49">7.2.2 Длина (Length).</a>
</li><li><a href="#50">8 Соединения (Connections).</a>
</li><li><a href="#51">8.1 Постоянные соединения (Persistent Connections).</a>
</li><li><a href="#52">8.1.1 Цель.</a>
</li><li><a href="#53">8.1.2 Общее описание.</a>
</li><li><a href="#54">8.1.2.1 Обсуждение (Negotiation).</a>
</li><li><a href="#55">8.1.2.2 Конвейерная обработка (Pipelining).</a>
</li><li><a href="#56">8.1.3 Прокси-сервера (Proxy Servers).</a>
</li><li><a href="#57">8.1.4 Практические cоглашения (Practical Considerations).</a>
</li><li><a href="#58">8.2 Требования к передаче сообщений.</a>
</li><li><a href="#59">9 Определения методов (Method Definitions).</a>
</li><li><a href="#60">9.1.1 Безопасные методы.</a>
</li><li><a href="#61">9.2 OPTIONS.</a>
</li><li><a href="#62">9.3 GET.</a>
</li><li><a href="#63">9.4 HEAD.</a>
</li><li><a href="#64">9.5 POST.</a>
</li><li><a href="#65">9.6 PUT.</a>
</li><li><a href="#66">9.7 DELETE.</a>
</li><li><a href="#67">9.8 TRACE.</a>
</li><li><a href="#68">10 Описания кодов состояния (Status Code Definitions).</a>
</li><li><a href="#69">10.1 1xx - Информационные коды.</a>
</li><li><a href="#70">10.1.1 100 Продолжать, Continue.</a>
</li><li><a href="#71">10.1.2 101 Переключение протоколов, Switching Protocols</a>
</li><li><a href="#72">10.2 2xx - Успешные коды.</a>
</li><li><a href="#73">10.2.1 200 OK.</a>
</li><li><a href="#74">10.2.2 201 Создан, Created.</a>
</li><li><a href="#75">10.2.3 202 Принято, Accepted.</a>
</li><li><a href="#76">10.2.4 203 Не авторская информация, Non-Authoritative Information.</a>
</li><li><a href="#77">10.2.5 204 Нет содержимого, No Content.</a>
</li><li><a href="#78">10.2.6 205 Сбросить содержимое, Reset Content.</a>
</li><li><a href="#79">10.2.7 206 Частичное содержимое, Partial Content.</a>
</li><li><a href="#80">10.3 3xx - Перенаправление.</a>
</li><li><a href="#81">10.3.1 300 Множественный выбор, Multiple Choices.</a>
</li><li><a href="#82">10.3.2 301 Постоянно перенесен, Moved Permanently.</a>
</li><li><a href="#83">10.3.3 302 Временно перемещен, Moved Temporarily.</a>
</li><li><a href="#84">10.3.4 303 Смотреть другой, See Other.</a>
</li><li><a href="#85">10.3.5 304 Не модифицирован, Not Modified.</a>
</li><li><a href="#86">10.3.6 305 Используйте прокси-сервер, Use Proxy.</a>
</li><li><a href="#87">10.4 4xx - Коды ошибок клиента.</a>
</li><li><a href="#88">10.4.1 400 Испорченный Запрос, Bad Request.</a>
</li><li><a href="#89">10.4.2 401 Несанкционированно, Unauthorized.</a>
</li><li><a href="#90">10.4.3 402 Требуется оплата, Payment Required.</a>
</li><li><a href="#91">10.4.4 403 Запрещено, Forbidden.</a>
</li><li><a href="#92">10.4.5 404 Не найден, Not Found.</a>
</li><li><a href="#93">10.4.6 405 Метод не дозволен, Method Not Allowed.</a>
</li><li><a href="#94">10.4.7 406 Не приемлем, Not Acceptable.</a>
</li><li><a href="#95">10.4.8 407 Требуется установление подлинности через прокси-сервер,</a>
</li><li><a href="#96">10.4.9 408 Истекло время ожидания запроса, Request Timeout.</a>
</li><li><a href="#97">10.4.10 409 Конфликт, Conflict.</a>
</li><li><a href="#98">10.4.11 410 Удален, Gone.</a>
</li><li><a href="#99">10.4.12 411 Требуется длина, Length Required.</a>
</li><li><a href="#100">10.4.13 412 Предусловие неверно, Precondition Failed.</a>
</li><li><a href="#101">10.4.14 413 Объект запроса слишком большой, Request Entity Too Large.</a>
</li><li><a href="#102">10.4.15 414 URI запроса слишком длинный, Request-URI Too Long.</a>
</li><li><a href="#103">10.4.16 415 Неподдерживаемый медиа тип, Unsupported Media Type.</a>
</li><li><a href="#104">10.5 5xx - Коды ошибок сервера.</a>
</li><li><a href="#105">10.5.1 500 Внутренняя ошибка сервера, Internal Server Error.</a>
</li><li><a href="#106">10.5.2 501 Не реализовано, Not Implemented.</a>
</li><li><a href="#107">10.5.3 502 Ошибка шлюза, Bad Gateway.</a>
</li><li><a href="#108">10.5.4 503 Сервис недоступен, Service Unavailable.</a>
</li><li><a href="#109">10.5.5 504 Истекло время ожидания от шлюза, Gateway Timeout.</a>
</li><li><a href="#110">10.5.6 505 Не поддерживаемая версия HTTP, HTTP Version Not Supported.</a>
</li><li><a href="#111">11 Установление подлинности доступа (Access Authentication).</a>
</li><li><a href="#112">11.1 Базовая схема установления подлинности (Basic Authentication</a>
</li><li><a href="#113">11.2 Обзорная схема установления подлинности (Digest Authentication</a>
</li><li><a href="#114">12 Обсуждение содержимого (Content Negotiation).</a>
</li><li><a href="#115">12.1 Управляемое сервером обсуждение.</a>
</li><li><a href="#116">12.2 Управляемое агентом обсуждение.</a>
</li><li><a href="#117">12.3 Прозрачное обсуждение.</a>
</li></td></tr></tbody></table>

<p><br>
  Network Working Group                                      R. Fielding
  Request for Comments: 2068                                   UC Irvine
  Category: Standards Track                                    J. Gettys
  <br>
  &nbsp; &nbsp; &nbsp; J. Mogul <br>
  &nbsp; &nbsp; &nbsp; DEC <br>
  &nbsp; &nbsp; &nbsp; H. Frystyk <br>
  &nbsp; &nbsp; &nbsp; T. Berners-Lee <br>
  &nbsp; &nbsp; &nbsp; MIT/LCS <br>
  &nbsp; &nbsp; &nbsp; Январь 1997 <br>
  <br>
  <br>
&nbsp; &nbsp; &nbsp;Спецификация протокола HTTP/1.1  </p>
<p>О переводе. <br>
  <br>
&nbsp; &nbsp; &nbsp; Здесь представлен частичный перевод документа RFC 2068 на русский язык. </p>
<p>Перевод произведен: <a href="mailto:Leshik@omsk.com">Leshik@omsk.com</a> . Алексей Симонов. <br>
  <br>
  <br>
В содержании указаны страницы английского оригинала. <br>
  <br>
<br>
Статус данного документа. <br>
  <br>
&nbsp; &nbsp; &nbsp; Этот документ определяет протокол дорожки стандартов Интернета <br>
&nbsp; &nbsp; &nbsp; (Internet standards track protocol) для семейства Интернета, и <br>
&nbsp; &nbsp; &nbsp; предназначен для обсуждения и предложений по усовершенствованию. <br>
&nbsp; &nbsp; &nbsp; Пожалуйста обратитесь к текущему изданию "Официальных стандартов <br>
&nbsp; &nbsp; &nbsp; протоколов Интернет" (STD 1) для выяснения состояния стандартизации <br>
&nbsp; &nbsp; &nbsp; и статуса этого протокола. Распространение данного документа <br>
&nbsp; &nbsp; &nbsp; неограничено. <br>
  <br>
  <br>
&nbsp; &nbsp; &nbsp; Протокол передачи Гипертекста (HTTP) - протокол прикладного уровня <br>
&nbsp; &nbsp; &nbsp; для распределенных, совместных, многосредных информационных систем. <br>
&nbsp; &nbsp; &nbsp; Это общий, платформно-независимый, объектно-ориентированный протокол, <br>
&nbsp; &nbsp; &nbsp; который может использоваться во многих задачах, таких как сервера <br>
&nbsp; &nbsp; &nbsp; имен и распределенные системы управления объектами, посредством <br>
&nbsp; &nbsp; &nbsp; расширения методов запроса. <br>
  <br>
&nbsp; &nbsp; &nbsp; Возможность HTTP - это печать и обсуждение представления данных, <br>
&nbsp; &nbsp; &nbsp; позволяющее строить системы независимо от передаваемых данных. <br>
  <br>
&nbsp; &nbsp; &nbsp; HTTP используется в World Wide Web (WWW) начиная с 1990 года. Эта <br>
&nbsp; &nbsp; &nbsp; спецификация определяет протокол, упоминаемый как "HTTP/1.1". <br>
  <br>
  Содержание. <br>
  <br>
&nbsp; &nbsp; &nbsp; 1 Введение ................................................7 <br>
&nbsp; &nbsp; &nbsp; 1.1 Цель .................................................7 <br>
&nbsp; &nbsp; &nbsp; 1.2 Требования ...........................................7 <br>
&nbsp; &nbsp; &nbsp; 1.3 Терминология .........................................8 <br>
&nbsp; &nbsp; &nbsp; 1.4 Общее описание ......................................11 <br>
&nbsp; &nbsp; &nbsp; 2 Письменные соглашения и обобщенная грамматика ..........13 <br>
&nbsp; &nbsp; &nbsp; 2.1 Увеличенная нормальная запись Бекуса-Наура (BNF) ....13 <br>
&nbsp; &nbsp; &nbsp; 2.2 Основные правила ....................................15 <br>
&nbsp; &nbsp; &nbsp; 3 Параметры протокола ....................................17 <br>
&nbsp; &nbsp; &nbsp; 3.1 Версия HTTP .........................................17 <br>
&nbsp; &nbsp; &nbsp; 3.2 Универсальные Идентификаторы Ресурсов (URI) .........18 <br>
&nbsp; &nbsp; &nbsp; 3.2.1 Общий синтаксис ..................................18 <br>
&nbsp; &nbsp; &nbsp; 3.2.2 HTTP URL .........................................19 <br>
&nbsp; &nbsp; &nbsp; 3.2.3 Сравнение URI ....................................20 <br>
&nbsp; &nbsp; &nbsp; 3.3 Форматы даты/времени ................................21 <br>
&nbsp; &nbsp; &nbsp; 3.3.1 Полная дата ......................................21 <br>
&nbsp; &nbsp; &nbsp; 3.3.2 Разность секунд (delta seconds) ..................22 <br>
&nbsp; &nbsp; &nbsp; 3.4 Кодовые таблицы (character sets) ....................22 <br>
&nbsp; &nbsp; &nbsp; 3.5 Кодирование содержимого (content codings) ...........23 <br>
&nbsp; &nbsp; &nbsp; 3.6 Кодирование передачи (transfer codings) .............24 <br>
&nbsp; &nbsp; &nbsp; 3.7 Медиа типы (Media Types) ............................25 <br>
&nbsp; &nbsp; &nbsp; 3.7.1 Канонизация и предопределенные значения типа <br>
&nbsp; &nbsp; &nbsp; text .............................................26 <br>
&nbsp; &nbsp; &nbsp; 3.7.2 Типы Multipart ...................................27 <br>
&nbsp; &nbsp; &nbsp; 3.8 Лексемы программ (Product Tokens) ...................28 <br>
&nbsp; &nbsp; &nbsp; 3.9 Качественные значения (Quality Values) ..............28 <br>
&nbsp; &nbsp; &nbsp; 3.10 Метки языков (Language Tags) .......................28 <br>
&nbsp; &nbsp; &nbsp; 3.11 Метки объектов (Entity Tags) .......................29 <br>
&nbsp; &nbsp; &nbsp; 3.12 Еденицы измерения диапазонов (Range Units) .........30 <br>
&nbsp; &nbsp; &nbsp; 4 HTTP сообщение (HTTP Message) ..........................30 <br>
&nbsp; &nbsp; &nbsp; 4.1 Типы сообщений ......................................30 <br>
&nbsp; &nbsp; &nbsp; 4.2 Заголовки сообщений .................................31 <br>
&nbsp; &nbsp; &nbsp; 4.3 Тело cообщения ......................................32 <br>
&nbsp; &nbsp; &nbsp; 4.4 Длина сообщения .....................................32 <br>
&nbsp; &nbsp; &nbsp; 4.5 Общие поля заголовка ................................34 <br>
&nbsp; &nbsp; &nbsp; 5 Запрос (Request) .......................................34 <br>
&nbsp; &nbsp; &nbsp; 5.1 Строка запроса (Request-Line) .......................34 <br>
&nbsp; &nbsp; &nbsp; 5.1.1 Метод (Method) ...................................35 <br>
&nbsp; &nbsp; &nbsp; 5.1.2 Запрашиваемый URI (Request-URI) ..................35 <br>
&nbsp; &nbsp; &nbsp; 5.2 Ресурс, идентифицируемый запросом ...................37 <br>
&nbsp; &nbsp; &nbsp; 5.3 Поля заголовка запроса ..............................37 <br>
&nbsp; &nbsp; &nbsp; 6 Ответ (Response) .......................................38 <br>
&nbsp; &nbsp; &nbsp; 6.1 Строка состояния (Status-Line) ......................38 <br>
&nbsp; &nbsp; &nbsp; 6.1.1 Код состояния и поясняющая фраза .................39 <br>
&nbsp; &nbsp; &nbsp; 6.2 Поля заголовка ответа ...............................41 <br>
&nbsp; &nbsp; &nbsp; 7 Объект (Entity) ........................................41 <br>
&nbsp; &nbsp; &nbsp; 7.1 Поля заголовка объекта ..............................41 <br>
&nbsp; &nbsp; &nbsp; 7.2 Тело объекта ........................................42 <br>
&nbsp; &nbsp; &nbsp; 7.2.1 Тип (Type) .......................................42 <br>
&nbsp; &nbsp; &nbsp; 7.2.2 Длина (Length) ...................................43 <br>
&nbsp; &nbsp; &nbsp; 8 Соединения (Connections) ...............................43 <br>
&nbsp; &nbsp; &nbsp; 8.1 Постоянные соединения (Persistent Connections) ......43 <br>
&nbsp; &nbsp; &nbsp; 8.1.1 Цель .............................................43 <br>
&nbsp; &nbsp; &nbsp; 8.1.2 Общее описание ...................................44 <br>
&nbsp; &nbsp; &nbsp; 8.1.3 Прокси-сервера (Proxy Servers) ...................45 <br>
&nbsp; &nbsp; &nbsp; 8.1.4 Практические cоглашения ..........................45 <br>
&nbsp; &nbsp; &nbsp; 8.2 Требования к передаче сообщений .....................46 <br>
&nbsp; &nbsp; &nbsp; 9 Определения методов (Method Definitions) ...............48
  ?    9.1 Безопасные и Idempotent Методы ......................48 <br>
&nbsp; &nbsp; &nbsp; 9.1.1 Безопасные методы ................................48
  ?     9.1.2 Idempotent методы (Idempotent Methods) ...........49 <br>
&nbsp; &nbsp; &nbsp; 9.2 OPTIONS .............................................49 <br>
&nbsp; &nbsp; &nbsp; 9.3 GET .................................................50 <br>
&nbsp; &nbsp; &nbsp; 9.4 HEAD ................................................50 <br>
&nbsp; &nbsp; &nbsp; 9.5 POST ................................................51 <br>
&nbsp; &nbsp; &nbsp; 9.6 PUT .................................................52 <br>
&nbsp; &nbsp; &nbsp; 9.7 DELETE ..............................................53 <br>
&nbsp; &nbsp; &nbsp; 9.8 TRACE ...............................................53 <br>
&nbsp; &nbsp; &nbsp; 10 Описания кодов состояния ..............................53 <br>
&nbsp; &nbsp; &nbsp; 10.1 1xx - Информационные коды ..........................54 <br>
&nbsp; &nbsp; &nbsp; 10.1.1 100 Продолжать, Continue ........................54 <br>
&nbsp; &nbsp; &nbsp; 10.1.2 101 Переключение протоколов, Switching <br>
&nbsp; &nbsp; &nbsp; Protocols ...................................54 <br>
&nbsp; &nbsp; &nbsp; 10.2 2xx - Успешные коды ................................54 <br>
&nbsp; &nbsp; &nbsp; 10.2.1 200 ОК ..........................................54 <br>
&nbsp; &nbsp; &nbsp; 10.2.2 201 Создан, Created .............................55 <br>
&nbsp; &nbsp; &nbsp; 10.2.3 202 Принято, Accepted ...........................55 <br>
&nbsp; &nbsp; &nbsp; 10.2.4 203 Не авторская информация, Non-Authoritative <br>
&nbsp; &nbsp; &nbsp; Information .................................55 <br>
&nbsp; &nbsp; &nbsp; 10.2.5 204 Нет содержимого, No Content .................55 <br>
&nbsp; &nbsp; &nbsp; 10.2.6 205 Сбросить содержимое, Reset Content ..........56 <br>
&nbsp; &nbsp; &nbsp; 10.2.7 206 Частичное содержимое, Partial Content .......56 <br>
&nbsp; &nbsp; &nbsp; 10.3 3xx - Коды перенаправления .........................56 <br>
&nbsp; &nbsp; &nbsp; 10.3.1 300 Множественный выбор, Multiple Choices .......57 <br>
&nbsp; &nbsp; &nbsp; 10.3.2 301 Постоянно перенесен, Moved Permanently ......57 <br>
&nbsp; &nbsp; &nbsp; 10.3.3 302 Временно перемещен, Moved Temporarily .......58 <br>
&nbsp; &nbsp; &nbsp; 10.3.4 303 Смотреть другой, See Other ..................58 <br>
&nbsp; &nbsp; &nbsp; 10.3.5 304 Не модифицирован, Not Modified ..............58 <br>
&nbsp; &nbsp; &nbsp; 10.3.6 305 Используйте прокси-сервер, Use Proxy ........59 <br>
&nbsp; &nbsp; &nbsp; 10.4 4xx - Коды ошибок клиента ..........................59 <br>
&nbsp; &nbsp; &nbsp; 10.4.1 400 Испорченный Запрос, Bad Request .............60 <br>
&nbsp; &nbsp; &nbsp; 10.4.2 401 Несанкционированно, Unauthorized ............60 <br>
&nbsp; &nbsp; &nbsp; 10.4.3 402 Требуется оплата, Payment Required ..........60 <br>
&nbsp; &nbsp; &nbsp; 10.4.4 403 Запрещено, Forbidden ........................60 <br>
&nbsp; &nbsp; &nbsp; 10.4.5 404 Не найден, Not Found ........................60 <br>
&nbsp; &nbsp; &nbsp; 10.4.6 405 Метод не дозволен, Method Not Allowed .......61 <br>
&nbsp; &nbsp; &nbsp; 10.4.7 406 Не приемлем, Not Acceptable .................61 <br>
&nbsp; &nbsp; &nbsp; 10.4.8 407 Требуется установление подлинности через <br>
&nbsp; &nbsp; &nbsp; прокси-сервер, Proxy Authentication <br>
&nbsp; &nbsp; &nbsp; Required ....................................61 <br>
&nbsp; &nbsp; &nbsp; 10.4.9 408 Истекло время ожидания запроса, Request <br>
&nbsp; &nbsp; &nbsp; Timeout .....................................62 <br>
&nbsp; &nbsp; &nbsp; 10.4.10 409 Конфликт, Conflict .........................62 <br>
&nbsp; &nbsp; &nbsp; 10.4.11 410 Удален, Gone ...............................62 <br>
&nbsp; &nbsp; &nbsp; 10.4.12 411 Требуется длина, Length Required ...........63 <br>
&nbsp; &nbsp; &nbsp; 10.4.13 412 Предусловие неверно, Precondition Failed ...63 <br>
&nbsp; &nbsp; &nbsp; 10.4.14 413 Объект запроса слишком большой, Request <br>
&nbsp; &nbsp; &nbsp; Entity Too Large ...........................63 <br>
&nbsp; &nbsp; &nbsp; 10.4.15 414 URI запроса слишком длинный, Request-URI <br>
&nbsp; &nbsp; &nbsp; Too Long ...................................63 <br>
&nbsp; &nbsp; &nbsp; 10.4.16 415 Неподдерживаемый медиа тип, Unsupported <br>
&nbsp; &nbsp; &nbsp; Media Type .................................63 <br>
&nbsp; &nbsp; &nbsp; 10.5 5xx - Коды ошибок сервера ..........................64 <br>
&nbsp; &nbsp; &nbsp; 10.5.1 500 Внутренняя ошибка сервера, Internal Server <br>
&nbsp; &nbsp; &nbsp; Error .......................................64 <br>
&nbsp; &nbsp; &nbsp; 10.5.2 501 Не реализовано, Not Implemented .............64 <br>
&nbsp; &nbsp; &nbsp; 10.5.3 502 Ошибка шлюза, Bad Gateway ...................64 <br>
&nbsp; &nbsp; &nbsp; 10.5.4 503 Сервис недоступен, Service Unavailable ......64 <br>
&nbsp; &nbsp; &nbsp; 10.5.5 504 Истекло время ожидания от шлюза, Gateway <br>
&nbsp; &nbsp; &nbsp; Timeout .....................................64 <br>
&nbsp; &nbsp; &nbsp; 10.5.6 505 Не поддерживаемая версия HTTP, HTTP Version <br>
&nbsp; &nbsp; &nbsp; Not Supported ...............................65 <br>
&nbsp; &nbsp; &nbsp; 11 Установление подлинности доступа (Access <br>
&nbsp; &nbsp; &nbsp; Authentication) .......................................65 <br>
&nbsp; &nbsp; &nbsp; 11.1 Базовая схема установления подлинности (Basic <br>
&nbsp; &nbsp; &nbsp; Authentication Scheme) .............................66 <br>
&nbsp; &nbsp; &nbsp; 11.2 Обзорная схема установления подлинности (Digest <br>
&nbsp; &nbsp; &nbsp; Authentication Scheme) .............................67 <br>
&nbsp; &nbsp; &nbsp; 12 Обсуждение содержимого (Content Negotiation) ..........67 <br>
&nbsp; &nbsp; &nbsp; 12.1 Управляемое сервером обсуждение ....................68 <br>
&nbsp; &nbsp; &nbsp; 12.2 Управляемое агентом обсуждение .....................69 <br>
&nbsp; &nbsp; &nbsp; 12.3 Прозрачное обсуждение ..............................70 <br>
&nbsp; &nbsp; &nbsp; 13 Кэширование в HTTP ....................................70 <br>
&nbsp; &nbsp; &nbsp; 13.1.1 Правильность кэширования ........................72 <br>
&nbsp; &nbsp; &nbsp; 13.1.2 Предупреждения ..................................73 <br>
&nbsp; &nbsp; &nbsp; 13.1.3 Механизмы управления кэшем ......................74 <br>
&nbsp; &nbsp; &nbsp; 13.1.4 Явные предупреждения User Agent .................74 <br>
&nbsp; &nbsp; &nbsp; 13.1.5 Исключения из правил и предупреждений ...........75 <br>
&nbsp; &nbsp; &nbsp; 13.1.6 Контроллируемое клиентом поведение ..............75 <br>
&nbsp; &nbsp; &nbsp; 13.2 Модель устаревания .................................75 <br>
&nbsp; &nbsp; &nbsp; 13.2.1 Устаревание, определеяемое сервером .............75 <br>
&nbsp; &nbsp; &nbsp; 13.2.2 Эвристическое устаревание .......................76 <br>
&nbsp; &nbsp; &nbsp; 13.2.3 Вычисление возраста .............................77 <br>
&nbsp; &nbsp; &nbsp; 13.2.4 Вычисление устаревание ..........................79 <br>
&nbsp; &nbsp; &nbsp; 13.2.5 Значения однозначного устаревания ...............80 <br>
&nbsp; &nbsp; &nbsp; 13.2.6 Disambiguating Multiple Responses ...............80 <br>
&nbsp; &nbsp; &nbsp; 13.3 Модель сравнения (validation model) ................81 <br>
&nbsp; &nbsp; &nbsp; 13.3.1 Даты последнего изменения (Last-modified Dates)..82 <br>
&nbsp; &nbsp; &nbsp; 13.3.2 Объектные отметки сравнения кэша ................82 <br>
&nbsp; &nbsp; &nbsp; 13.3.3 Слабое и сильное сравнение ......................82 <br>
&nbsp; &nbsp; &nbsp; 13.3.4 Правила когда использовать объектные отметки <br>
&nbsp; &nbsp; &nbsp; (Entity Tags) и даты последнего изменения (Last- <br>
&nbsp; &nbsp; &nbsp; modified Dates).........................................85 <br>
&nbsp; &nbsp; &nbsp; 13.3.5 Непроверяемые условия ...........................86 <br>
&nbsp; &nbsp; &nbsp; 13.4 Cachability ответа .................................86 <br>
&nbsp; &nbsp; &nbsp; 13.5 Построение ответов из кэшей ........................87 <br>
&nbsp; &nbsp; &nbsp; 13.5.1 Сквозные (End-to-end) и промежуточные (Hop-by-hop) <br>
&nbsp; &nbsp; &nbsp; заголовки ..............................................88 <br>
&nbsp; &nbsp; &nbsp; 13.5.2 Немодифицируемые заголовки ......................88 <br>
&nbsp; &nbsp; &nbsp; 13.5.3 Объединение заголовков ..........................89 <br>
&nbsp; &nbsp; &nbsp; 13.5.4 Объединнение диапазонов байтов ..................90 <br>
&nbsp; &nbsp; &nbsp; 13.6 Кэширование переговорных ответов (Negotiated <br>
&nbsp; &nbsp; &nbsp; Responses)...............................................90 <br>
&nbsp; &nbsp; &nbsp; 13.7 Общедоступные и необщедоступные кэши ...............91 <br>
&nbsp; &nbsp; &nbsp; 13.8 Поведение кеша при ошибочных или незавершенных <br>
&nbsp; &nbsp; &nbsp; ответах .................................................91 <br>
&nbsp; &nbsp; &nbsp; 13.9 Побочные эффекты GET и HEAD ........................92 <br>
&nbsp; &nbsp; &nbsp; 13.10 Ошибки после модификаций или стирания .............92 <br>
&nbsp; &nbsp; &nbsp; 13.11 Write-Through Mandatory ...........................93 <br>
&nbsp; &nbsp; &nbsp; 13.12 Замена кэша .......................................93 <br>
&nbsp; &nbsp; &nbsp; 13.13 Списки history ....................................93 <br>
&nbsp; &nbsp; &nbsp; 14 Определения полей заголовка ...........................94 <br>
&nbsp; &nbsp; &nbsp; 14.1 Accept .............................................95 <br>
&nbsp; &nbsp; &nbsp; 14.2 Accept-Charset .....................................97 <br>
&nbsp; &nbsp; &nbsp; 14.3 Accept-Encoding ....................................97 <br>
&nbsp; &nbsp; &nbsp; 14.4 Accept-Language ....................................98 <br>
&nbsp; &nbsp; &nbsp; 14.5 Accept-Ranges ......................................99 <br>
&nbsp; &nbsp; &nbsp; 14.6 Age ................................................99 <br>
&nbsp; &nbsp; &nbsp; 14.7 Allow .............................................100 <br>
&nbsp; &nbsp; &nbsp; 14.8 Authorization .....................................100 <br>
&nbsp; &nbsp; &nbsp; 14.9 Cache-Control .....................................101 <br>
&nbsp; &nbsp; &nbsp; 14.9.1 Что кэшируемо (Cachable) .......................103 <br>
&nbsp; &nbsp; &nbsp; 14.9.2 Что может быть сохранено кэшем .................103 <br>
&nbsp; &nbsp; &nbsp; 14.9.3 Модификации основного механизма устаревания ....104 <br>
&nbsp; &nbsp; &nbsp; 14.9.4 Перепроверки правильности кэша и средства <br>
&nbsp; &nbsp; &nbsp; управления перезагрузкой ..............................105 <br>
&nbsp; &nbsp; &nbsp; 14.9.5 Директива No-Transform .........................107 <br>
&nbsp; &nbsp; &nbsp; 14.9.6 Расширения средств управления кэшем ............108 <br>
&nbsp; &nbsp; &nbsp; 14.10 Connection .......................................109 <br>
&nbsp; &nbsp; &nbsp; 14.11 Content-Base .....................................109 <br>
&nbsp; &nbsp; &nbsp; 14.12 Content-Encoding .................................110 <br>
&nbsp; &nbsp; &nbsp; 14.13 Content-Language .................................110 <br>
&nbsp; &nbsp; &nbsp; 14.14 Content-Length ...................................111 <br>
&nbsp; &nbsp; &nbsp; 14.15 Content-Location .................................112 <br>
&nbsp; &nbsp; &nbsp; 14.16 Content-MD5 ......................................113 <br>
&nbsp; &nbsp; &nbsp; 14.17 Content-Range ....................................114 <br>
&nbsp; &nbsp; &nbsp; 14.18 Content-Type .....................................116 <br>
&nbsp; &nbsp; &nbsp; 14.19 Date .............................................116 <br>
&nbsp; &nbsp; &nbsp; 14.20 ETag .............................................117 <br>
&nbsp; &nbsp; &nbsp; 14.21 Expires ..........................................117 <br>
&nbsp; &nbsp; &nbsp; 14.22 From .............................................118 <br>
&nbsp; &nbsp; &nbsp; 14.23 Host .............................................119 <br>
&nbsp; &nbsp; &nbsp; 14.24 If-Modified-Since ................................119 <br>
&nbsp; &nbsp; &nbsp; 14.25 If-Match .........................................121 <br>
&nbsp; &nbsp; &nbsp; 14.26 If-None-Match ....................................122 <br>
&nbsp; &nbsp; &nbsp; 14.27 If-Range .........................................123 <br>
&nbsp; &nbsp; &nbsp; 14.28 If-Unmodified-Since ..............................124 <br>
&nbsp; &nbsp; &nbsp; 14.29 Last-Modified ....................................124 <br>
&nbsp; &nbsp; &nbsp; 14.30 Location .........................................125 <br>
&nbsp; &nbsp; &nbsp; 14.31 Max-Forwards .....................................125 <br>
&nbsp; &nbsp; &nbsp; 14.32 Pragma ...........................................126 <br>
&nbsp; &nbsp; &nbsp; 14.33 Proxy-Authenticate ...............................127 <br>
&nbsp; &nbsp; &nbsp; 14.34 Proxy-Authorization ..............................127 <br>
&nbsp; &nbsp; &nbsp; 14.35 Public ...........................................127 <br>
&nbsp; &nbsp; &nbsp; 14.36 Range ............................................128 <br>
&nbsp; &nbsp; &nbsp; 14.36.1 Диапазоны байт (byte ranges) ..................128 <br>
&nbsp; &nbsp; &nbsp; 14.36.2 Запросы диапазонов (Range Retrieval <br>
&nbsp; &nbsp; &nbsp; Requests) .............................................130 <br>
&nbsp; &nbsp; &nbsp; 14.37 Referer ..........................................131 <br>
&nbsp; &nbsp; &nbsp; 14.38 Retry-After ......................................131 <br>
&nbsp; &nbsp; &nbsp; 14.39 Server ...........................................132 <br>
&nbsp; &nbsp; &nbsp; 14.40 Transfer-Encoding ................................132 <br>
&nbsp; &nbsp; &nbsp; 14.41 Upgrade ..........................................132 <br>
&nbsp; &nbsp; &nbsp; 14.42 User-Agent .......................................134 <br>
&nbsp; &nbsp; &nbsp; 14.43 Vary .............................................134 <br>
&nbsp; &nbsp; &nbsp; 14.44 Via ..............................................135 <br>
&nbsp; &nbsp; &nbsp; 14.45 Warning ..........................................137 <br>
&nbsp; &nbsp; &nbsp; 14.46 WWW-Authenticate .................................139 <br>
&nbsp; &nbsp; &nbsp; 15 Положения о защите ...................................139 <br>
&nbsp; &nbsp; &nbsp; 15.1 Установления подлинности клиентов .................139 <br>
&nbsp; &nbsp; &nbsp; 15.2 Предложение выбрать схему установления <br>
&nbsp; &nbsp; &nbsp; подлинности.............................................140 <br>
&nbsp; &nbsp; &nbsp; 15.3 Неправильное обращение с информацией файла <br>
&nbsp; &nbsp; &nbsp; регистрации сервера (Log)...............................141 <br>
&nbsp; &nbsp; &nbsp; 15.4 Передача чувствительной (sensitive) информации ....141 <br>
&nbsp; &nbsp; &nbsp; 15.5 Атаки, основанные именах файлов и путей............142 <br>
&nbsp; &nbsp; &nbsp; 15.6 Персональная информация ...........................143 <br>
&nbsp; &nbsp; &nbsp; 15.7 Проблемы секретности, связанные с Accept <br>
&nbsp; &nbsp; &nbsp; заголовками ............................................143 <br>
&nbsp; &nbsp; &nbsp; 15.8 Подмена DNS-адресов (DNS Spoofing).................144 <br>
&nbsp; &nbsp; &nbsp; 15.9 Расположение заголовков и Spoofing ................144 <br>
&nbsp; &nbsp; &nbsp; 16 Подтверждения ........................................144 <br>
&nbsp; &nbsp; &nbsp; 17 Ссылки ...............................................146 <br>
&nbsp; &nbsp; &nbsp; 18 Адреса авторов .......................................149 <br>
&nbsp; &nbsp; &nbsp; 19 Приложения ...........................................150 <br>
&nbsp; &nbsp; &nbsp; 19.1 Медиа тип Интернет message/http ...................150 <br>
&nbsp; &nbsp; &nbsp; 19.2 Медиа тип Интернет multipart/byteranges ...........150 <br>
&nbsp; &nbsp; &nbsp; 19.3 Допустимые приложения .............................151 <br>
&nbsp; &nbsp; &nbsp; 19.4 Различия между HTTP объектами и MIME объектами ....152 <br>
&nbsp; &nbsp; &nbsp; 19.4.1 Преобразование к канонической форме ............152 <br>
&nbsp; &nbsp; &nbsp; 19.4.2 Преобразование форматов дат ....................153 <br>
&nbsp; &nbsp; &nbsp; 19.4.3 Введение Content-Encoding ......................153 <br>
&nbsp; &nbsp; &nbsp; 19.4.4 Никакого Content-Transfer-Encoding .............153 <br>
&nbsp; &nbsp; &nbsp; 19.4.5 Поля HTTP заголовка в Multipart Body-Parts .....153 <br>
&nbsp; &nbsp; &nbsp; 19.4.6 Введение Transfer-Encoding .....................154 <br>
&nbsp; &nbsp; &nbsp; 19.4.7 Версия MIME ....................................154 <br>
&nbsp; &nbsp; &nbsp; 19.5 Изменения после HTTP/1.0 ..........................154 <br>
&nbsp; &nbsp; &nbsp; 19.5.1 Изменения упрощаущие много-homed сервера и <br>
&nbsp; &nbsp; &nbsp; сохраняющие IP адреса .................................155 <br>
&nbsp; &nbsp; &nbsp; 19.6 Дополнительные возможности ........................156 <br>
&nbsp; &nbsp; &nbsp; 19.6.1 Дополнительные методы запросов .................156 <br>
&nbsp; &nbsp; &nbsp; 19.6.2 Дополнительные определения полей заголовка .....156 <br>
&nbsp; &nbsp; &nbsp; 19.7 Совместимость с предыдущими версиями ..............160 <br>
&nbsp; &nbsp; &nbsp; 19.7.1 Совместимость с постоянными соединениями, <br>
&nbsp; &nbsp; &nbsp; определяемыми HTTP/1.0  ...............................161 <br>
  <br>
  <br>
  <a name="1"></a></p>
<center><h2>1 Введение.</h2></center>
<br>
<a name="2"></a><center><h2>1.1 Цель.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Протокол передачи Гипертекста (HTTP) - протокол прикладного уровня
<br>&nbsp; &nbsp; &nbsp; для распределенных, совместных, многосредных информационных систем.
<br>&nbsp; &nbsp; &nbsp; HTTP используется в World Wide Web (WWW) начиная с 1990 года. Первой
<br>&nbsp; &nbsp; &nbsp; версией HTTP, известной как HTTP/0.9, был простой протокол для
<br>&nbsp; &nbsp; &nbsp; передачи необработанных данных через Интернет. HTTP/1.0, как
<br>&nbsp; &nbsp; &nbsp; определено в RFC 1945 [6], был улучшением этого протокола, позволяя
<br>&nbsp; &nbsp; &nbsp; сообщениям иметь MIME-подобный формат, содержащий метаинформацию о
<br>&nbsp; &nbsp; &nbsp; передаваемых данных и имел модифицированную семантику
<br>&nbsp; &nbsp; &nbsp; запросов/ответов. Однако, HTTP/1.0 недостаточно хорошо учитывал
<br>&nbsp; &nbsp; &nbsp; особенности работы с иерархическими прокси-серверами (hierarchical
<br>&nbsp; &nbsp; &nbsp; proxies), кэшированием, постоянными соединениями, и виртуальными
<br>&nbsp; &nbsp; &nbsp; хостами (virtual hosts). Кроме того, быстрое увеличение не полностью
<br>&nbsp; &nbsp; &nbsp; совместимых приложений, называющих тот протокол, который они
<br>&nbsp; &nbsp; &nbsp; использовали "HTTP/1.0", потребовало введения версии протокола, в
<br>&nbsp; &nbsp; &nbsp; которой были бы заложены возможности, позволяющие приложениям
<br>&nbsp; &nbsp; &nbsp; определять истинные возможности друг друга.
<br>
<br>&nbsp; &nbsp; &nbsp; Эта спецификация определяет протокол "HTTP/1.1". Этот протокол
<br>&nbsp; &nbsp; &nbsp; содержит более строгие требования, чем HTTP/1.0, гарантирующие
<br>&nbsp; &nbsp; &nbsp; надежную реализацию возможностей.
<br>
<br>&nbsp; &nbsp; &nbsp; Практически информационные системы требуют большей функциональности,
<br>&nbsp; &nbsp; &nbsp; чем просто загрузку информации, включая поиск, модификацию при
<br>&nbsp; &nbsp; &nbsp; помощи внешнего интерфейса, и аннотацию (annotation). HTTP
<br>&nbsp; &nbsp; &nbsp; предоставляет открытый набор методов, которые указывают цель запроса.
<br>&nbsp; &nbsp; &nbsp; Они основаны на дисциплине ссылки, обеспеченной Универсальным
<br>&nbsp; &nbsp; &nbsp; Идентификатором Ресурса (URI) [3][20], как расположение (URL) [4]
<br>&nbsp; &nbsp; &nbsp; или имя (URN), для идентификации ресурса, к которому этот метод
<br>&nbsp; &nbsp; &nbsp; применяется. Сообщения передаются в формате, подобном используемому
<br>&nbsp; &nbsp; &nbsp; электронной почтой, как определено Многоцелевыми Расширениями
<br>&nbsp; &nbsp; &nbsp; Электронной Почты (MIME).
<br>
<br>&nbsp; &nbsp; &nbsp; HTTP также используется как обобщенный протокол связи между агентами
<br>&nbsp; &nbsp; &nbsp; пользователей и прокси-серверами/шлюзами (proxies/gateways) или
<br>&nbsp; &nbsp; &nbsp; другими сервисами Интернета, включая такие, как SMTP [16], NNTP [13],
<br>&nbsp; &nbsp; &nbsp; FTP [18], Gopher [2], и WAIS [10]. Таким образом, HTTP закладывает
<br>&nbsp; &nbsp; &nbsp; основы многосредного (hypermedia) доступа к ресурсам для
<br>&nbsp; &nbsp; &nbsp; разнообразных приложений.
<br>
<br>
<a name="3"></a><center><h2>1.2 Требования.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Эта спецификация использует те же самые слова для определения
<br>&nbsp; &nbsp; &nbsp; требований к реализации протокола, что и RFC 1123 [8]. Эти слова
<br>&nbsp; &nbsp; &nbsp; следующие:
<br>
<br>&nbsp; &nbsp; &nbsp; НЕОБХОДИМО, ДОЛЖЕН (MUST)
<br>&nbsp; &nbsp; &nbsp; Применяется для указания, что данное требование спецификации
<br>&nbsp; &nbsp; &nbsp; необходимо обеспечить в любом случае.
<br>
<br>&nbsp; &nbsp; &nbsp; РЕКОМЕНДУЕТСЯ, СЛЕДУЕТ (SHOULD)
<br>&nbsp; &nbsp; &nbsp; Используется для указания, что данное требование спецификации
<br>&nbsp; &nbsp; &nbsp; должно быть обеспечено, если этому не препятствуют серьезные
<br>&nbsp; &nbsp; &nbsp; причины.
<br>
<br>&nbsp; &nbsp; &nbsp; ВОЗМОЖНО, МОЖЕТ (MAY)
<br>&nbsp; &nbsp; &nbsp; Используется для указания, что данное требование спецификации
<br>&nbsp; &nbsp; &nbsp; является опциональным и может быть либо реализовано, либо нет -
<br>&nbsp; &nbsp; &nbsp; по необходимости.
<br>
<br>&nbsp; &nbsp; &nbsp; Реализация считается несовместимой, если нарушено хотя бы одно
<br>&nbsp; &nbsp; &nbsp; НЕОБХОДИМЫХ требований спецификации протокола. Реализация,
<br>&nbsp; &nbsp; &nbsp; удовлетворяющая всем НЕОБХОДИМЫМ и РЕКОМЕНДУЕМЫМ тредованиям
<br>&nbsp; &nbsp; &nbsp; называется полностью совместимой, а удовлетворяющая всем НЕОБХОДИМЫМ,
<br>&nbsp; &nbsp; &nbsp; но не всем РЕКОМЕНДУЕМЫМ требованиям называется условно совместимой.
<br>
<br>
<a name="4"></a><center><h2>1.3 Терминология.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Эта спецификация использует ряд терминов для описания роли
<br>&nbsp; &nbsp; &nbsp; участников, некоторых объектов, и HTTP связи.
<br>
<br>&nbsp; &nbsp; &nbsp; Соединение (connection)
<br>&nbsp; &nbsp; &nbsp; Виртуальный канал транспортого уровня, установленный между двумя
<br>&nbsp; &nbsp; &nbsp; программами с целью связи.
<br>
<br>&nbsp; &nbsp; &nbsp; Сообщение (message)
<br>&nbsp; &nbsp; &nbsp; Основной модуль HTTP связи, состоящей из структурной
<br>&nbsp; &nbsp; &nbsp; последовательности октетов, соответствующих синтаксису,
<br>&nbsp; &nbsp; &nbsp; определенному в разделе 4 и передаваемых по соединению.
<br>
<br>&nbsp; &nbsp; &nbsp; Запрос (request)
<br>&nbsp; &nbsp; &nbsp; Любое HTTP сообщение, содержащее запрос, определяемый в разделе 5.
<br>
<br>&nbsp; &nbsp; &nbsp; Ответ (response)
<br>&nbsp; &nbsp; &nbsp; Любое HTTP сообщение, содержащее ответ, определяемый в разделе 5.
<br>
<br>&nbsp; &nbsp; &nbsp; Ресурс (resource)
<br>&nbsp; &nbsp; &nbsp; Сетевой объект данных или сервис, который может быть
<br>&nbsp; &nbsp; &nbsp; идентифицирован URI, определеляемым в разделе 3.2. Ресурсы могут
<br>&nbsp; &nbsp; &nbsp; быть доступны в нескольких представлениях (например на нескольких
<br>&nbsp; &nbsp; &nbsp; языках, в разных форматах данных, иметь различный размер, иметь
<br>&nbsp; &nbsp; &nbsp; различную разрешающую способность) или различаться по другим
<br>&nbsp; &nbsp; &nbsp; параметрам.
<br>
<br>&nbsp; &nbsp; &nbsp; Объект (entity)
<br>&nbsp; &nbsp; &nbsp; Информация, передаваемая в качестве полезной нагрузки запроса или
<br>&nbsp; &nbsp; &nbsp; ответа. Объект состоит из метаинформации в форме полей заголовка
<br>&nbsp; &nbsp; &nbsp; объекта и содержания в форме тела объекта, как описано в разделе
<br>&nbsp; &nbsp; &nbsp; 7.
<br>
<br>&nbsp; &nbsp; &nbsp; Представление (representation)
<br>&nbsp; &nbsp; &nbsp; Объект включенный в ответ, и подчиняющийся обсуждению
<br>&nbsp; &nbsp; &nbsp; содержимого (Content Negotiation), что описано в разделе 12.
<br>&nbsp; &nbsp; &nbsp; Может существовать несколько представлений, связанных со
<br>&nbsp; &nbsp; &nbsp; специфическими состояниями ответа.
<br>
<br>&nbsp; &nbsp; &nbsp; Обсуждение содержимого (content negotiation)
<br>&nbsp; &nbsp; &nbsp; Механизм для выбора соответствующего представления во время
<br>&nbsp; &nbsp; &nbsp; обслуживания запроса, как описано в разделе 12. Представление
<br>&nbsp; &nbsp; &nbsp; объектов в любом ответе может быть обсуждено (включая ошибочные
<br>&nbsp; &nbsp; &nbsp; ответы).
<br>
<br>&nbsp; &nbsp; &nbsp; Вариант (variant)
<br>&nbsp; &nbsp; &nbsp; Ресурс может иметь одно, или несколько представлений, связанных
<br>&nbsp; &nbsp; &nbsp; с ним в данный момент. Каждое из этих представлений называется
<br>&nbsp; &nbsp; &nbsp; "вариант". Использование термина "вариант" не обязательно
<br>&nbsp; &nbsp; &nbsp; подразумевает, что ресурс подчинен обсуждению содержимого.
<br>
<br>&nbsp; &nbsp; &nbsp; Клиент (client)
<br>&nbsp; &nbsp; &nbsp; Программа, которая устанавливает соединения с целью посылки
<br>&nbsp; &nbsp; &nbsp; запросов.
<br>
<br>&nbsp; &nbsp; &nbsp; Агент пользователя (user agent)
<br>&nbsp; &nbsp; &nbsp; Клиент, который инициирует запрос. Как правило браузеры,
<br>&nbsp; &nbsp; &nbsp; редакторы, роботы (spiders), или другие инструментальные
<br>&nbsp; &nbsp; &nbsp; средства пользователя.
<br>
<br>&nbsp; &nbsp; &nbsp; Сервер (server)
<br>&nbsp; &nbsp; &nbsp; Приложение, которое слушает соединения, принимает запросы на
<br>&nbsp; &nbsp; &nbsp; обслуживание и посылает ответы. Любая такая программа способна
<br>&nbsp; &nbsp; &nbsp; быть как клиентом, так и сервером; наше использование данного
<br>&nbsp; &nbsp; &nbsp; термина относится скорее к роли, которую программа выполняет,
<br>&nbsp; &nbsp; &nbsp; создавая специфические соединения, нежели к возможностям
<br>&nbsp; &nbsp; &nbsp; программы вообще. Аналогично, любой сервер может действовать как
<br>&nbsp; &nbsp; &nbsp; первоначальный сервер, прокси-сервер, шлюз, или туннель (tunnel),
<br>&nbsp; &nbsp; &nbsp; изменяя поведение, основываясь на характере каждого запроса.
<br>
<br>&nbsp; &nbsp; &nbsp; Первоначальный сервер (origin server)
<br>&nbsp; &nbsp; &nbsp; Сервер, на котором данный ресурс постоянно находится или должен
<br>&nbsp; &nbsp; &nbsp; быть создан.
<br>
<br>&nbsp; &nbsp; &nbsp; Прокси-сервер (proxy)
<br>&nbsp; &nbsp; &nbsp; Программа-посредник, которая действует и как сервер, и как
<br>&nbsp; &nbsp; &nbsp; клиент с целью создания запросов от имени других клиентов.
<br>&nbsp; &nbsp; &nbsp; Запросы обслуживаются прокси-сервером, или передаются им,
<br>&nbsp; &nbsp; &nbsp; возможно с изменениями. Прокси-сервер должен удовлетворять
<br>&nbsp; &nbsp; &nbsp; требованиям клиента и сервера, согласно этой спецификации.
<br>
<br>&nbsp; &nbsp; &nbsp; Шлюз (gateway)
<br>&nbsp; &nbsp; &nbsp; Сервер, который действует как посредник для некоторого
<br>&nbsp; &nbsp; &nbsp; другого сервера. В отличие от прокси-сервера, шлюз получает
<br>&nbsp; &nbsp; &nbsp; запросы в качестве первоначального сервера для запрошенного
<br>&nbsp; &nbsp; &nbsp; ресурса; клиент запроса может не знать, что он соединяется со
<br>&nbsp; &nbsp; &nbsp; шлюзом.
<br>
<br>&nbsp; &nbsp; &nbsp; Туннель (tunnel)
<br>&nbsp; &nbsp; &nbsp; Программа-посредник, которая поддерживает соединение. Один
<br>&nbsp; &nbsp; &nbsp; раз созданный, туннель не рассматривается как часть HTTP связи,
<br>&nbsp; &nbsp; &nbsp; хотя туннель, возможно, был инициализирован запросом HTTP.
<br>&nbsp; &nbsp; &nbsp; Туннель прекращает существовать, когда оба конца соединения
<br>&nbsp; &nbsp; &nbsp; закрываются.
<br>
<br>&nbsp; &nbsp; &nbsp; Кэш (cache)
<br>&nbsp; &nbsp; &nbsp; Локальная память, в которой программа хранит сообщения ответов,
<br>&nbsp; &nbsp; &nbsp; и в которой располагается подсистема, управляющая хранением,
<br>&nbsp; &nbsp; &nbsp; поиском и стиранием сообщений. Кэш сохраняет ответы, которые
<br>&nbsp; &nbsp; &nbsp; могут быть сохранены, чтобы уменьшить время ответа и загрузку
<br>&nbsp; &nbsp; &nbsp; сети (траффик) при будущих эквивалентных запросах. Любой клиент
<br>&nbsp; &nbsp; &nbsp; или сервер может иметь кэш, но кэш не может использоваться
<br>&nbsp; &nbsp; &nbsp; сервером, который действует как туннель.
<br>
<br>&nbsp; &nbsp; &nbsp; Кэшируемый (cachable)
<br>&nbsp; &nbsp; &nbsp; Ответ является кэшируемым, если кэшу разрешено сохранить копию
<br>&nbsp; &nbsp; &nbsp; ответного сообщения для использования при ответе на последующие
<br>&nbsp; &nbsp; &nbsp; запросы. Правила для определения кэшируемости HTTP ответов
<br>&nbsp; &nbsp; &nbsp; определены в разделе 13. Даже если ресурс кэшируем, могут
<br>&nbsp; &nbsp; &nbsp; существовать дополнительные ограничения на использование кэшем
<br>&nbsp; &nbsp; &nbsp; сохраненной копии для сходного запроса.
<br>
<br>&nbsp; &nbsp; &nbsp; Непосредственный (first-hand)
<br>&nbsp; &nbsp; &nbsp; Ответ считается непосредственным, если он приходит
<br>&nbsp; &nbsp; &nbsp; непосредственно от первоначального сервера без ненужной задержки,
<br>&nbsp; &nbsp; &nbsp; возможно через один или несколько прокси-серверов. Ответ также
<br>&nbsp; &nbsp; &nbsp; является непосредственным, если его правильность только что была
<br>&nbsp; &nbsp; &nbsp; проверена непосредственно первоначальным сервером.
<br>
<br>&nbsp; &nbsp; &nbsp; Точное время устаревания (explicit expiration time)
<br>&nbsp; &nbsp; &nbsp; Время, определенное первоначальным сервером и показывающее кэшу,
<br>&nbsp; &nbsp; &nbsp; когда объект больше не может быть возвращен кэшем клиенту без
<br>&nbsp; &nbsp; &nbsp; дополнительной проверки правильности.
<br>
<br>&nbsp; &nbsp; &nbsp; Эвристическое время устаревания (heuristic expiration time)
<br>&nbsp; &nbsp; &nbsp; Время устаревания, назначенное кэшем, если не указано точное
<br>&nbsp; &nbsp; &nbsp; время устаревания.
<br>
<br>&nbsp; &nbsp; &nbsp; Возраст (age)
<br>&nbsp; &nbsp; &nbsp; Возраст ответа - время, прошедшее с момента отсылки, или
<br>&nbsp; &nbsp; &nbsp; успешной проверки ответа первоначальным сервером.
<br>
<br>&nbsp; &nbsp; &nbsp; Время жизни (freshness lifetime)
<br>&nbsp; &nbsp; &nbsp; Отрезок времени между порождением ответа и временем устаревания.
<br>
<br>&nbsp; &nbsp; &nbsp; Свежий (fresh)
<br>&nbsp; &nbsp; &nbsp; Ответ считается свежим, если его возраст еще не превысил время
<br>&nbsp; &nbsp; &nbsp; жизни.
<br>
<br>&nbsp; &nbsp; &nbsp; Просроченнный (stale)
<br>&nbsp; &nbsp; &nbsp; Ответ считается просроченным, если его возраст превысил время
<br>&nbsp; &nbsp; &nbsp; жизни.
<br>
<br>&nbsp; &nbsp; &nbsp; Семантически прозрачный (semantically transparent)
<br>&nbsp; &nbsp; &nbsp; Говорят, что кэш ведет себя "семантически прозрачным" образом в
<br>&nbsp; &nbsp; &nbsp; отношении специфического ответа, когда использование кэша не
<br>&nbsp; &nbsp; &nbsp; влияет ни на клиента запроса, ни на первоначальный сервер, но
<br>&nbsp; &nbsp; &nbsp; повышает эффективность. Когда кэш семантически прозрачен, клиент
<br>&nbsp; &nbsp; &nbsp; получает точно такой же ответ (за исключением промежуточных
<br>&nbsp; &nbsp; &nbsp; (hop-by-hop) заголовков), который получил бы, запрашивая
<br>&nbsp; &nbsp; &nbsp; непосредственно первоначальный сервер, а не кэш.
<br>
?   Указатель правильности (validator)
<br>&nbsp; &nbsp; &nbsp; Элемент протокола (например, метка объекта или время последней
<br>&nbsp; &nbsp; &nbsp; модификации (Last-Modified time)), который используется, чтобы
<br>&nbsp; &nbsp; &nbsp; выяснить, является ли находящаяся в кэше копия эквивалентом
<br>&nbsp; &nbsp; &nbsp; объекта.
<br>
<a name="5"></a><center><h2>1.4 Общее описание.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Протокол HTTP - это протокол запросов/ответов. Клиент посылает
<br>&nbsp; &nbsp; &nbsp; серверу запрос, содержащий метод запроса, URI, версию протокола,
<br>&nbsp; &nbsp; &nbsp; MIME-подобное сообщение, содержащее модификаторы запроса, клиентскую
<br>&nbsp; &nbsp; &nbsp; информацию, и, возможно, тело запроса, по соединению. Сервер
<br>&nbsp; &nbsp; &nbsp; отвечает строкой состояния, включающей версию протокола сообщения,
<br>&nbsp; &nbsp; &nbsp; код успешного выполнения или код ошибки, MIME-подобное сообщение,
<br>&nbsp; &nbsp; &nbsp; содержащее информацию о сервере, метаинформацию объекта, и,
<br>&nbsp; &nbsp; &nbsp; возможно, тело объекта. Связь между HTTP и MIME описана в приложении
<br>&nbsp; &nbsp; &nbsp; 19.4.
<br>
<br>&nbsp; &nbsp; &nbsp; Большинство HTTP соединений инициализируется агентом пользователя и
<br>&nbsp; &nbsp; &nbsp; состоит из запроса, который нужно применить к ресурсу на некотором
<br>&nbsp; &nbsp; &nbsp; первоначальном сервере. В самом простом случае, он может быть
<br>&nbsp; &nbsp; &nbsp; выполнен посредством одиночного соединения (v) между агентом
<br>&nbsp; &nbsp; &nbsp; пользователя (UA) и первоначальным сервером (O).
<br>
<br>&nbsp; &nbsp; &nbsp; цепочка запросов ---------------------&gt;
<br>&nbsp; &nbsp; &nbsp; UA -------------------v------------------- O
<br>&nbsp; &nbsp; &nbsp; &lt;----------------------- цепочка ответов
<br>
<br>&nbsp; &nbsp; &nbsp; Более сложная ситуация возникает, когда в цепочке запросов/ответов
<br>&nbsp; &nbsp; &nbsp; присутствует один или несколько посредников. Существуют три
<br>&nbsp; &nbsp; &nbsp; основных разновидности посредников: прокси-сервера, шлюзы, и
<br>&nbsp; &nbsp; &nbsp; туннели. Прокси-сервер является агентом-посредником, который
<br>&nbsp; &nbsp; &nbsp; получает запросы на некоторый URI в абсолютной форме, изменяет все
<br>&nbsp; &nbsp; &nbsp; сообщение или его часть, и отсылает измененный запрос серверу,
<br>&nbsp; &nbsp; &nbsp; идентифицированному URI. Шлюз - это принимающий агент, действующий
<br>&nbsp; &nbsp; &nbsp; как бы уровень выше некоторого другого сервера(ов) и, в случае
<br>&nbsp; &nbsp; &nbsp; необходимости, транслирующий запросы в протокол основного сервера.
<br>&nbsp; &nbsp; &nbsp; Туннель действует как реле между двумя соединениями не изменяя
<br>&nbsp; &nbsp; &nbsp; сообщения; туннели используются, когда связь нужно производить
<br>&nbsp; &nbsp; &nbsp; через посредника (например Firewall), который не понимает
<br>&nbsp; &nbsp; &nbsp; содержание сообщений.
<br>
<br>&nbsp; &nbsp; &nbsp; цепочка запросов -----------------------------------&gt;
<br>&nbsp; &nbsp; &nbsp; UA -----v----- A -----v----- B -----v----- C -----v----- O
<br>&nbsp; &nbsp; &nbsp; &lt;------------------------------------ цепочка ответов
<br>
<br>&nbsp; &nbsp; &nbsp; На последнем рисунке показаны три посредника (A, B, и C) между
<br>&nbsp; &nbsp; &nbsp; агентом пользователя и первоначальным сервером. Запросы и ответы
<br>&nbsp; &nbsp; &nbsp; передаются через четыре отдельных соединения. Это различие важно,
<br>&nbsp; &nbsp; &nbsp; так как некоторые опции HTTP соединения применимы только к
<br>&nbsp; &nbsp; &nbsp; соединению с ближайшим не туннельным соседом, некоторые только к
<br>&nbsp; &nbsp; &nbsp; конечным точкам цепочки, а некоторые ко всем соединениям в цепочке.
<br>&nbsp; &nbsp; &nbsp; Хотя диаграмма линейна, каждый участник может быть задействован в
<br>&nbsp; &nbsp; &nbsp; нескольких соединениях одновременно. Например, B может получать
<br>&nbsp; &nbsp; &nbsp; запросы от других клиентов, а не только от A, и/или пересылать
<br>&nbsp; &nbsp; &nbsp; запросы к серверам, отличным от C, в то же время, когда он
<br>&nbsp; &nbsp; &nbsp; обрабатывает запрос от А.
<br>
<br>&nbsp; &nbsp; &nbsp; Любая сторона соединения, которая не действует как туннель, может
<br>&nbsp; &nbsp; &nbsp; использовать внутренний кэш для обработки запросов. Эффект кэша
<br>&nbsp; &nbsp; &nbsp; заключается в том, что цепочка запросов/ответов сокращается, если
<br>&nbsp; &nbsp; &nbsp; один из участников в цепочке имеет кэшированный ответ, применимый
<br>&nbsp; &nbsp; &nbsp; к данному запросу. Далее иллюстрируется цепочка, возникающая в
<br>&nbsp; &nbsp; &nbsp; результате того, что B имеет кэшированую копию раннего ответа O
<br>&nbsp; &nbsp; &nbsp; (полеченного через C) для запроса, и который не кэшировался ни UA,
<br>&nbsp; &nbsp; &nbsp; ни A.
<br>
<br>&nbsp; &nbsp; &nbsp; цепочка запросов -------&gt;
<br>&nbsp; &nbsp; &nbsp; UA -----v----- A -----v----- B - - - - - - C - - - - - - O
<br>&nbsp; &nbsp; &nbsp; &lt;-------- цепочка ответов
<br>
<br>&nbsp; &nbsp; &nbsp; Не все ответы полезно кэшировать, а некоторые запросы могут
<br>&nbsp; &nbsp; &nbsp; содержать модификаторы, которые включают специальные требования,
<br>&nbsp; &nbsp; &nbsp; управляющие поведением кэша. Требования HTTP для поведения кэша в
<br>&nbsp; &nbsp; &nbsp; отношении кэшируемых ответов определены в разделе 13.
<br>
<br>&nbsp; &nbsp; &nbsp; Фактически, имеется широкое разнообразие архитектур и конфигураций
<br>&nbsp; &nbsp; &nbsp; кэшей и прокси-серверов, в настоящее время разрабатываемых или
<br>&nbsp; &nbsp; &nbsp; развернутых в World Wide Web; эти системы включают национальные
<br>&nbsp; &nbsp; &nbsp; иерархии прокси-кэшей, которые сохраняют пропускную способность
<br>&nbsp; &nbsp; &nbsp; межокеанских каналов, системы, которые распространяют во много
<br>&nbsp; &nbsp; &nbsp; мест содержимое кэша, организации, которые распространяют
<br>&nbsp; &nbsp; &nbsp; подмножества кэшируемых данных на CD-ROM, и так далее. HTTP системы
<br>&nbsp; &nbsp; &nbsp; используются в корпоративных интранет-сетях с высокоскоростными
<br>&nbsp; &nbsp; &nbsp; линиями связи, и для доступа через PDA с маломощными линиями и
<br>&nbsp; &nbsp; &nbsp; неустойчивой связи. Цель HTTP/1.1 состоит в поддержании широкого
<br>&nbsp; &nbsp; &nbsp; многообразия конфигураций, уже построенных при введении ранних
<br>&nbsp; &nbsp; &nbsp; версий протокола, а также в удовлетворении потребностей
<br>&nbsp; &nbsp; &nbsp; разработчиков web приложений, требующих высокой надежности, по
<br>&nbsp; &nbsp; &nbsp; крайней мере надежных относительно индикации отказа.
<br>
<br>&nbsp; &nbsp; &nbsp; HTTP соединение обычно происходит посредством TCP/IP соединений.
<br>&nbsp; &nbsp; &nbsp; Заданный по умолчанию порт TCP - 80, но могут использоваться и
<br>&nbsp; &nbsp; &nbsp; другие порты. HTTP также может быть реализован посредством любого
<br>&nbsp; &nbsp; &nbsp; другого протокола Интернета, или других сетей. HTTP необходима
<br>&nbsp; &nbsp; &nbsp; только надежная передача данных, следовательно может использоваться
<br>&nbsp; &nbsp; &nbsp; любой протокол, который гарантирует надежную передачу данных;
<br>&nbsp; &nbsp; &nbsp; отображение структуры запроса и ответа HTTP/1.1 на транспортные
<br>&nbsp; &nbsp; &nbsp; модули данных рассматриваемого протокола - вопрос, не решаемый
<br>&nbsp; &nbsp; &nbsp; этой спецификацией.
<br>
<br>&nbsp; &nbsp; &nbsp; Большинство реализаций HTTP/1.0 использовало новое соединение для
<br>&nbsp; &nbsp; &nbsp; каждого обмена запросом/ответом. В HTTP/1.1, установленное
<br>&nbsp; &nbsp; &nbsp; соединение может использоваться для одного или нескольких обменов
<br>&nbsp; &nbsp; &nbsp; запросом/ответом, хотя соединение может быть закрыто по ряду
<br>&nbsp; &nbsp; &nbsp; причин (смотрите раздел 8.1).
<br>
<br>
<a name="6"></a><center><h2>2 Письменные соглашения и обобщенная грамматика.</h2></center>
<br>
<br>
<a name="7"></a><center><h2>2.1 Увеличенная нормальная запись Бекуса-Наура (BNF).</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Все механизмы, определенные этим документом, описаны как в обычной,
<br>&nbsp; &nbsp; &nbsp; так и в увеличенной нормальной записи Бекуса-Наура (BNF), подобной
<br>&nbsp; &nbsp; &nbsp; используемой в RFC 822 [9]. Разработчик должен быть знаком с такой
<br>&nbsp; &nbsp; &nbsp; формой записи, чтобы понять данную спецификацию. Увеличенная
<br>&nbsp; &nbsp; &nbsp; нормальная запись Бекуса-Наура включает следующие конструкции:
<br>
<br>&nbsp; &nbsp; &nbsp; имя = определение
<br>&nbsp; &nbsp; &nbsp; name = definition
<br>&nbsp; &nbsp; &nbsp; Имя правила - это просто его название (не включающее символов
<br>&nbsp; &nbsp; &nbsp; "&lt;" и "&gt;"), и отделяемое от определения символом равенства "=".
<br>&nbsp; &nbsp; &nbsp; Пробел важен только при выравнивании продолжающихся строк,
<br>&nbsp; &nbsp; &nbsp; используемых для указания определений правил, которые
<br>&nbsp; &nbsp; &nbsp; занимают более одной строки. Некоторые основные правила, такие
<br>&nbsp; &nbsp; &nbsp; как SP, LWS, HT, CRLF, DIGIT, ALPHA и т.д, представлены в
<br>&nbsp; &nbsp; &nbsp; верхнем регистре. Угловые скобки используются в определении
<br>&nbsp; &nbsp; &nbsp; всякий раз, когда их присутствие облегчает использование имен
<br>&nbsp; &nbsp; &nbsp; правил.
<br>
<br>&nbsp; &nbsp; &nbsp; "литерал"
<br>&nbsp; &nbsp; &nbsp; "literal"
<br>&nbsp; &nbsp; &nbsp; Кавычки окружают литеральный текст. Если не установлено иного,
<br>&nbsp; &nbsp; &nbsp; этот текст регистро-независим.
<br>
<br>&nbsp; &nbsp; &nbsp; правило1 | правило2
<br>&nbsp; &nbsp; &nbsp; rule1 | rule2
<br>&nbsp; &nbsp; &nbsp; Элементы, отделяемые полосой ("|") являются вариантами. Например,
<br>&nbsp; &nbsp; &nbsp; "да | нет" принимает значение либо да, либо нет.
<br>
<br>&nbsp; &nbsp; &nbsp; (правило1 правило2)
<br>&nbsp; &nbsp; &nbsp; (rule1 rule2)
<br>&nbsp; &nbsp; &nbsp; Элементы, включенные в круглые скобки обрабатываются как
<br>&nbsp; &nbsp; &nbsp; один элемент. Таким образом, "(elem (foo | bar) elem)"
<br>&nbsp; &nbsp; &nbsp; допускает последовательности лексем "elem foo elem" и
<br>&nbsp; &nbsp; &nbsp; "elem bar elem".
<br>
<br>&nbsp; &nbsp; &nbsp; *правило
<br>&nbsp; &nbsp; &nbsp; *rule
<br>&nbsp; &nbsp; &nbsp; Символ "*", предшествующий элементу, указывает повторение.
<br>&nbsp; &nbsp; &nbsp; Полная форма - "&lt;n&gt;*&lt;m&gt;element" означает минимум &lt;n&gt;, максимум
<br>&nbsp; &nbsp; &nbsp; &lt;m&gt; вхождений элемента. Значения по умолчанию - 0 и
<br>&nbsp; &nbsp; &nbsp; бесконечность. Таким образом запись "*(element)" допускает
<br>&nbsp; &nbsp; &nbsp; любое число повторений (в том числе ноль); запись "1*element"
<br>&nbsp; &nbsp; &nbsp; требует по крайней мере одно повторение; а "1*2element"
<br>&nbsp; &nbsp; &nbsp; допускает либо один, либо два повторения.
<br>
<br>&nbsp; &nbsp; &nbsp; [правило]
<br>&nbsp; &nbsp; &nbsp; [rule]
<br>&nbsp; &nbsp; &nbsp; В квадратные скобки заключают опциональные элементы; "[foo bar]"
<br>&nbsp; &nbsp; &nbsp; эквивалентно "*1(foo bar)".
<br>
<br>&nbsp; &nbsp; &nbsp; N правило
<br>&nbsp; &nbsp; &nbsp; N rule
<br>&nbsp; &nbsp; &nbsp; Точное количество повторений: "&lt;n&gt;(element)" эквивалентно
<br>&nbsp; &nbsp; &nbsp; "&lt;n&gt;*&lt;n&gt;(element)"; то есть присутствует точно &lt;n&gt; повторов
<br>&nbsp; &nbsp; &nbsp; элемента. Таким образом 2DIGIT - номер из 2 цифр, а 3ALPHA
<br>&nbsp; &nbsp; &nbsp; - строка из трех алфавитных символов.
<br>
<br>&nbsp; &nbsp; &nbsp; #правило
<br>&nbsp; &nbsp; &nbsp; #rule
<br>&nbsp; &nbsp; &nbsp; Конструкция "#" предназначена, подобно "*", для определения
<br>&nbsp; &nbsp; &nbsp; списка элементов. Полная форма - "&lt;n&gt;#&lt;m&gt;element" означает
<br>&nbsp; &nbsp; &nbsp; минимум &lt;n&gt;, максимум &lt;m&gt; вхождений элемента, отделенных одной
<br>&nbsp; &nbsp; &nbsp; или несколькими запятыми (","), и, возможно, линейным пробелом
<br>&nbsp; &nbsp; &nbsp; (LWS). Это обычно делает форму списков очень простой; правило
<br>&nbsp; &nbsp; &nbsp; типа "( *LWS element *( *LWS "," *LWS element)) " можно
<br>&nbsp; &nbsp; &nbsp; представить как "1#элемент". Везде, где используется эта
<br>&nbsp; &nbsp; &nbsp; конструкция, пустые элементы допускаются, но не учитываются при
<br>&nbsp; &nbsp; &nbsp; подсчете представленных элементов. То есть конструкция
<br>&nbsp; &nbsp; &nbsp; "(element), , (element)" допускается, но считаются в ней только
<br>&nbsp; &nbsp; &nbsp; два элемента. Следовательно там, где требуется по крайней мере
<br>&nbsp; &nbsp; &nbsp; один элемент, должен присутствовать по крайней мере  один не
<br>&nbsp; &nbsp; &nbsp; пустой элемент. Значения по умолчанию - 0 и бесконечность.
<br>&nbsp; &nbsp; &nbsp; Таким образом запись "#(element)" допускает любое число
<br>&nbsp; &nbsp; &nbsp; повторений (в том числе ноль); запись "1#element" требует по
<br>&nbsp; &nbsp; &nbsp; крайней мере одного повтора ненулевого элемента; а "1*2element"
<br>&nbsp; &nbsp; &nbsp; допускает один или два повтора.
<br>
<br>&nbsp; &nbsp; &nbsp; ; комментарий
<br>&nbsp; &nbsp; &nbsp; ; comment
<br>&nbsp; &nbsp; &nbsp; Точка с запятой, поставленная справа от текста правила, начинает
<br>&nbsp; &nbsp; &nbsp; комментарий, который продолжается до конца строки. Это - простой
<br>&nbsp; &nbsp; &nbsp; способ включения полезных пометок параллельно спецификациям.
<br>
<br>&nbsp; &nbsp; &nbsp; подразумевая *LWS
<br>&nbsp; &nbsp; &nbsp; implied *LWS
<br>&nbsp; &nbsp; &nbsp; Грамматика, описанная этой спецификацией основана на словах.
<br>&nbsp; &nbsp; &nbsp; За исключением случаев, в которых отмечено иное, линейный
<br>&nbsp; &nbsp; &nbsp; пробел (LWS) может быть включен между любыми двумя смежными
<br>&nbsp; &nbsp; &nbsp; словами (лексемой или строкой цитирования), и между смежными
<br>&nbsp; &nbsp; &nbsp; лексемами и разделителями (tspecials), не изменяя интерпретацию
<br>&nbsp; &nbsp; &nbsp; поля. Между любыми двумя лексемами должен существовать по
<br>&nbsp; &nbsp; &nbsp; крайней мере один разделитель (tspecials), так как иначе они
<br>&nbsp; &nbsp; &nbsp; интерпретируются как одна лексема.
<br>
<br>
<a name="8"></a><center><h2>2.2 Основные правила.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Следующие правила используются в продолжение всей этой спецификации
<br>&nbsp; &nbsp; &nbsp; для описания основных конструкций синтаксического анализа.
<br>&nbsp; &nbsp; &nbsp; Кодированный набор символов US-ASCII определен в ANSI X3.4-1986
<br>&nbsp; &nbsp; &nbsp; [21].
<br>
<br>&nbsp; &nbsp; &nbsp; OCTET          = &lt;любая 8-битная последовательность данных&gt;
<br>
<br>&nbsp; &nbsp; &nbsp; CHAR           = &lt;любой US-ASCII символ (октеты 0 - 127)&gt;
<br>
<br>&nbsp; &nbsp; &nbsp; UPALPHA        = &lt;любой US-ASCII символ верхнего регистра
<br>&nbsp; &nbsp; &nbsp; "A".."Z"&gt;
<br>
<br>&nbsp; &nbsp; &nbsp; LOALPHA        = &lt;любой US-ASCII символ нижнего регистра
<br>&nbsp; &nbsp; &nbsp; "a".."z"&gt;
<br>
<br>&nbsp; &nbsp; &nbsp; ALPHA          = UPALPHA | LOALPHA
<br>
<br>&nbsp; &nbsp; &nbsp; DIGIT          = &lt;любая US-ASCII цифра "0".."9"&gt;
<br>
<br>&nbsp; &nbsp; &nbsp; CTL            = &lt;любой US-ASCII управляющий символ (октеты
<br>&nbsp; &nbsp; &nbsp; 0 - 31) и DEL (127)&gt;
<br>
<br>&nbsp; &nbsp; &nbsp; CR             = &lt;US-ASCII CR, возврат каретки (13)&gt;
<br>
<br>&nbsp; &nbsp; &nbsp; LF             = &lt;US-ASCII LF, перевод строки (10)&gt;
<br>
<br>&nbsp; &nbsp; &nbsp; SP             = &lt;US-ASCII SP, пробел (32)&gt;
<br>
<br>&nbsp; &nbsp; &nbsp; HT             = &lt;US-ASCII HT, метка горизонтальной
<br>&nbsp; &nbsp; &nbsp; табуляции (9)&gt;
<br>
<br>&nbsp; &nbsp; &nbsp; &lt;"&gt;            = &lt;US-ASCII двойные кавычки (34)&gt;
<br>
<br>&nbsp; &nbsp; &nbsp; HTTP/1.1 определяет последовательность CR LF как метку конца строки
<br>&nbsp; &nbsp; &nbsp; во всех элементах протокола, за исключением тела объекта (смотрите
<br>&nbsp; &nbsp; &nbsp; приложение 19.3 о допустимых применениях (tolerant applications)).
<br>&nbsp; &nbsp; &nbsp; Метка конца строки внутри тела объекта определяется соответствыющим
<br>&nbsp; &nbsp; &nbsp; медиа типом, как описано в разделе 3.7.
<br>
<br>&nbsp; &nbsp; &nbsp; CRLF           = CR LF
<br>
<br>&nbsp; &nbsp; &nbsp; HTTP/1.1 заголовки занимают несколько строк, если следующая строка
<br>&nbsp; &nbsp; &nbsp; начинается с пробела или метки горизонтальной табуляции. Все
<br>&nbsp; &nbsp; &nbsp; незаполненное пространство строки, включая переход на следующую
<br>&nbsp; &nbsp; &nbsp; строку, имеет ту же семантику, что и SP.
<br>
<br>&nbsp; &nbsp; &nbsp; LWS            = [CRLF] 1*( SP | HT )
<br>
<br>&nbsp; &nbsp; &nbsp; Правило TEXT используется только для описательного содержимого поля
<br>&nbsp; &nbsp; &nbsp; и значений, которые не предназначены, для интерпретации
<br>&nbsp; &nbsp; &nbsp; синтаксическим анализатором сообщений. Слова *TEXT могут содержать
<br>&nbsp; &nbsp; &nbsp; символы из наборов символов (character sets), отличных от
<br>&nbsp; &nbsp; &nbsp; ISO 8859-1 [22], только когда они закодированы согласно правилам
<br>&nbsp; &nbsp; &nbsp; RFC 1522 [14].
<br>
<br>&nbsp; &nbsp; &nbsp; TEXT           = &lt;любой OCTET, за исключением CTLs,
<br>&nbsp; &nbsp; &nbsp; но содержащий LWS&gt;
<br>
<br>&nbsp; &nbsp; &nbsp; Шестнадцатеричные цифры используются некоторыми элементами
<br>&nbsp; &nbsp; &nbsp; протокола.
<br>
<br>&nbsp; &nbsp; &nbsp; HEX            = "A" | "B" | "C" | "D" | "E" | "F"
<br>&nbsp; &nbsp; &nbsp; | "a" | "b" | "c" | "d" | "e" | "f" | DIGIT
<br>
<br>&nbsp; &nbsp; &nbsp; Многие значения полей заголовка HTTP/1.1 состоят из слов,
<br>&nbsp; &nbsp; &nbsp; разделенных LWS или специальными символами. Эти специальные символы
<br>&nbsp; &nbsp; &nbsp; ДОЛЖНЫ находиться в цитируемой строке (quoted string), чтобы быть
<br>&nbsp; &nbsp; &nbsp; использованными в качестве значения параметра.
<br>
<br>&nbsp; &nbsp; &nbsp; token          = 1*&lt;любой CHAR за исключением CTLs или
<br>&nbsp; &nbsp; &nbsp; tspecials&gt;
<br>
<br>&nbsp; &nbsp; &nbsp; tspecials      = "(" | ")" | "&lt;" | "&gt;" | "@"
<br>&nbsp; &nbsp; &nbsp; | "," | ";" | ":" | "\" | &lt;"&gt;
<br>&nbsp; &nbsp; &nbsp; | "/" | "[" | "]" | "?" | "="
<br>&nbsp; &nbsp; &nbsp; | "{" | "}" | SP | HT
<br>
<br>
<br>&nbsp; &nbsp; &nbsp; В некоторые поля HTTP заголовка могут быть включены комментарии.
<br>&nbsp; &nbsp; &nbsp; Текст комментария окружается круглыми скобками. Комментарии
<br>&nbsp; &nbsp; &nbsp; допускаются только в полях, содержащих "comment" как часть
<br>&nbsp; &nbsp; &nbsp; определения значения поля. Во всех других полях круглые скобки
<br>&nbsp; &nbsp; &nbsp; рассматриваются частью значения поля.
<br>
<br>&nbsp; &nbsp; &nbsp; comment        = "(" *( ctext | comment ) ")"
<br>
<br>&nbsp; &nbsp; &nbsp; ctext          = &lt;любой TEXT не включающий "(" and ")"&gt;
<br>
<br>&nbsp; &nbsp; &nbsp; Строка текста анализируется как одно слово, если это цитирование,
<br>&nbsp; &nbsp; &nbsp; помеченное двойными кавычками.
<br>
<br>&nbsp; &nbsp; &nbsp; quoted-string  = ( &lt;"&gt; *(qdtext) &lt;"&gt; )
<br>
<br>&nbsp; &nbsp; &nbsp; qdtext         = &lt;любой TEXT не включающий &lt;"&gt;&gt;
<br>
<br>&nbsp; &nbsp; &nbsp; Символ наклонной черты влево ("\") может использоваться как
<br>&nbsp; &nbsp; &nbsp; односимвольный механизм цитирования только внутри конструкций
<br>&nbsp; &nbsp; &nbsp; комментария и строки цитирования (quoted-string).
<br>
<br>&nbsp; &nbsp; &nbsp; quoted-pair    = "\" CHAR
<br>
<br>
<a name="9"></a><center><h2>3 Параметры протокола.</h2></center>
<br>
<br>
<a name="10"></a><center><h2>3.1 Версия HTTP.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; HTTP использует схему нумерации типа "&lt;major&gt;.&lt;minor&gt;", для указания
<br>&nbsp; &nbsp; &nbsp; версии протокола. Стратегия версификации протокола предназначена
<br>&nbsp; &nbsp; &nbsp; для того, чтобы позволить отправителю указать формат сообщения и
<br>&nbsp; &nbsp; &nbsp; свои способности понимания для дальнейшей HTTP связи, прежде чем
<br>&nbsp; &nbsp; &nbsp; он получит что-либо посредством этой связи. При добавлении
<br>&nbsp; &nbsp; &nbsp; компонентов сообщения, которые не воздействуют на поведение
<br>&nbsp; &nbsp; &nbsp; связи, или компонентов, которые добавляются только к расширяемым
<br>&nbsp; &nbsp; &nbsp; значениям поля, номер версии не меняется. Когда внесенные в протокол
<br>&nbsp; &nbsp; &nbsp; изменения добавляют возможности, которые не изменяют общий алгоритм
<br>&nbsp; &nbsp; &nbsp; анализа сообщений, но которые расширяют семантику сообщения и
<br>&nbsp; &nbsp; &nbsp; подразумевают дополнительные возможности отправителя, увеличивается
<br>&nbsp; &nbsp; &nbsp; &lt;Minor&gt; номер. Когда формат сообщения протокола изменяется
<br>&nbsp; &nbsp; &nbsp; увеличивается &lt;Major&gt; номер.
<br>
<br>&nbsp; &nbsp; &nbsp; Версия HTTP сообщения обозначается полем HTTP-version в первой
<br>&nbsp; &nbsp; &nbsp; строке сообщения.
<br>
<br>&nbsp; &nbsp; &nbsp; HTTP-Version   = "HTTP" "/" 1*DIGIT "." 1*DIGIT
<br>
<br>&nbsp; &nbsp; &nbsp; Обратите внимание, что major и minor числа ДОЛЖНЫ обрабатываться
<br>&nbsp; &nbsp; &nbsp; как отдельные целые числа и что каждое может состоять более чем из
<br>&nbsp; &nbsp; &nbsp; одной цифры. Таким образом, HTTP/2.4 - более низкая версия, чем
<br>&nbsp; &nbsp; &nbsp; HTTP/2.13, которая в свою очередь ниже чем HTTP/12.3. Нули ДОЛЖНЫ
<br>&nbsp; &nbsp; &nbsp; игнорироваться получателями и НЕ ДОЛЖНЫ посылаться.
<br>
<br>&nbsp; &nbsp; &nbsp; Приложения, посылающие сообщения запросов или ответов, которые
<br>&nbsp; &nbsp; &nbsp; описывает эта спецификация, ДОЛЖНЫ включить HTTP версию
<br>&nbsp; &nbsp; &nbsp; (HTTP-version) "HTTP/1.1". Использование этого номера версии
<br>&nbsp; &nbsp; &nbsp; указывает, что посылающее приложение по крайней мере условно
<br>&nbsp; &nbsp; &nbsp; совместимо с этой спецификацией.
<br>
<br>&nbsp; &nbsp; &nbsp; HTTP версия приложения - это самая высокая HTTP версия, для которой
<br>&nbsp; &nbsp; &nbsp; приложение является по крайней мере условно совместимым.
<br>
<br>&nbsp; &nbsp; &nbsp; Приложения, реализующие прокси-сервера и шлюзы, должны быть
<br>&nbsp; &nbsp; &nbsp; внимательны, когда пересылают сообщения протокола различных версий.
<br>&nbsp; &nbsp; &nbsp; Начиная с момента, когда версия протокола указывает возможности
<br>&nbsp; &nbsp; &nbsp; отправителя, прокси-сервер/шлюз никогда НЕ ДОЛЖЕН посылать
<br>&nbsp; &nbsp; &nbsp; сообщения, версия которых больше, чем HTTP версия отправителя; если
<br>&nbsp; &nbsp; &nbsp; получена более высокая версия запроса, то прокси-сервер/шлюз ДОЛЖЕН
<br>&nbsp; &nbsp; &nbsp; или понизить версию запроса, отдав сообщение об ошибке, или
<br>&nbsp; &nbsp; &nbsp; переключиться на туннельное поведение. У запросов, версия которых
<br>&nbsp; &nbsp; &nbsp; ниже, чем HTTP версия прокси-сервера/шлюза МОЖНО перед пересылкой
<br>&nbsp; &nbsp; &nbsp; увеличить версию; ответ прокси-сервера/шлюза на этот запрос ДОЛЖЕН
<br>&nbsp; &nbsp; &nbsp; иметь ту же самую major версию, что и запрос.
<br>
<br>&nbsp; &nbsp; &nbsp; Обратите внимание: Преобразование версий HTTP может включать
<br>&nbsp; &nbsp; &nbsp; модификацию полей заголовка, требуемых или запрещенных в этих
<br>&nbsp; &nbsp; &nbsp; версиях.
<br>
<br>
<a name="11"></a><center><h2>3.2 Универсальные Идентификаторы Ресурсов (URI).</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; URI известны под многими именами: WWW адреса, Универсальные
<br>&nbsp; &nbsp; &nbsp; Идентификаторы Документов, Универсальные Идентификаторы Ресурсов
<br>&nbsp; &nbsp; &nbsp; (URI), и, в заключение, как комбинация Единообразных Идентификаторов
<br>&nbsp; &nbsp; &nbsp; Ресурса (Uniform Resource Locators, URL) и Единообразных Имен
<br>&nbsp; &nbsp; &nbsp; Ресурса (Uniform Resource Names, URN). HTTP определяет URL просто
<br>&nbsp; &nbsp; &nbsp; как строку определенного формата, которая идентифицирует - через
<br>&nbsp; &nbsp; &nbsp; имя, расположение, или любую другую характеристику - ресурс.
<br>
<br>
<a name="12"></a><center><h2>3.2.1 Общий синтаксис.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; URI в HTTP могут представляться в абсолютной (absolute) форме или
<br>&nbsp; &nbsp; &nbsp; относительно некоторой известной основы URI (relative), в
<br>&nbsp; &nbsp; &nbsp; зависимости от контекста их использования. Эти две формы
<br>&nbsp; &nbsp; &nbsp; различаются тем, что абсолютные URI всегда начинаются с имени
<br>&nbsp; &nbsp; &nbsp; схемы с двоеточием.
<br>
<br>&nbsp; &nbsp; &nbsp; URI         = ( absoluteURI | relativeURI ) [ "#" fragment ]
<br>
<br>&nbsp; &nbsp; &nbsp; absoluteURI = scheme ":" *( uchar | reserved )
<br>
<br>&nbsp; &nbsp; &nbsp; relativeURI = net_path | abs_path | rel_path
<br>
<br>&nbsp; &nbsp; &nbsp; net_path    = "//" net_loc [ abs_path ]
<br>&nbsp; &nbsp; &nbsp; abs_path    = "/" rel_path
<br>&nbsp; &nbsp; &nbsp; rel_path    = [ path ] [ ";" params ] [ "?" query ]
<br>
<br>&nbsp; &nbsp; &nbsp; path        = fsegment *( "/" segment )
<br>&nbsp; &nbsp; &nbsp; fsegment    = 1*pchar
<br>&nbsp; &nbsp; &nbsp; segment     = *pchar
<br>
<br>&nbsp; &nbsp; &nbsp; params      = param *( ";" param )
<br>&nbsp; &nbsp; &nbsp; param       = *( pchar | "/" )
<br>
<br>&nbsp; &nbsp; &nbsp; scheme      = 1*( ALPHA | DIGIT | "+" | "-" | "." )
<br>&nbsp; &nbsp; &nbsp; net_loc     = *( pchar | ";" | "?" )
<br>
<br>&nbsp; &nbsp; &nbsp; query       = *( uchar | reserved )
<br>&nbsp; &nbsp; &nbsp; fragment    = *( uchar | reserved )
<br>
<br>&nbsp; &nbsp; &nbsp; pchar       = uchar | ":" | "@" | "&amp;" | "=" | "+"
<br>&nbsp; &nbsp; &nbsp; uchar       = unreserved | escape
<br>&nbsp; &nbsp; &nbsp; unreserved  = ALPHA | DIGIT | safe | extra | national
<br>
<br>&nbsp; &nbsp; &nbsp; escape      = "%" HEX HEX
<br>&nbsp; &nbsp; &nbsp; reserved    = ";" | "/" | "?" | ":" | "@" | "&amp;" | "=" | "+"
<br>&nbsp; &nbsp; &nbsp; extra       = "!" | "*" | "'" | "(" | ")" | ","
<br>&nbsp; &nbsp; &nbsp; safe        = "$" | "-" | "_" | "."
<br>&nbsp; &nbsp; &nbsp; unsafe      = CTL | SP | &lt;"&gt; | "#" | "%" | "&lt;" | "&gt;"
<br>&nbsp; &nbsp; &nbsp; national    = &lt;любой OCTET за исключением ALPHA, DIGIT,
<br>&nbsp; &nbsp; &nbsp; reserved, extra, safe, и unsafe&gt;
<br>
<br>&nbsp; &nbsp; &nbsp; Полную информацию относительно синтаксиса и семантики URL смотрите
<br>&nbsp; &nbsp; &nbsp; RFC 1738 [4] И RFC 1808 [11]. Вышеуказанная нормальная запись
<br>&nbsp; &nbsp; &nbsp; Бекуса-Наура включает национальные символы, недозволенные в
<br>&nbsp; &nbsp; &nbsp; допустимых URL (это определено в RFC 1738), так как HTTP серверы
<br>&nbsp; &nbsp; &nbsp; позволяют использовать для представления части rel_path адресов
<br>&nbsp; &nbsp; &nbsp; набор незарезервированных символов, и, следовательно, HTTP
<br>&nbsp; &nbsp; &nbsp; прокси-сервера могут получать запросы URI, не соответствующие
<br>&nbsp; &nbsp; &nbsp; RFC 1738.
<br>
<br>&nbsp; &nbsp; &nbsp; Протокол HTTP не накладывает a priori никаких ограничений на длины
<br>&nbsp; &nbsp; &nbsp; URI. Серверы ДОЛЖНЫ быть способны обработать URI любого ресурса,
<br>&nbsp; &nbsp; &nbsp; который они обслуживают, и им СЛЕДУЕТ быть в состоянии обрабатывать
<br>&nbsp; &nbsp; &nbsp; URI неограниченной длины, если они обслуживают формы, основанные
<br>&nbsp; &nbsp; &nbsp; на методе GET, которые могут генерировать такой URI. Серверу
<br>&nbsp; &nbsp; &nbsp; СЛЕДУЕТ возвращать код состояния 414 (URI запроса слишком длинный,
<br>&nbsp; &nbsp; &nbsp; Request-URI Too Long), если URI больше, чем сервер может обработать
<br>&nbsp; &nbsp; &nbsp; (смотрите раздел 10.4.15).
<br>
<br>&nbsp; &nbsp; &nbsp; Обратите внимание: Серверы должны быть осторожны с URI, которые
<br>&nbsp; &nbsp; &nbsp; имеют длину более 255 байтов, потому что некоторые старые
<br>&nbsp; &nbsp; &nbsp; клиенты или прокси-сервера не могут правильно поддерживать
<br>&nbsp; &nbsp; &nbsp; эти длины.
<br>
<br>
<a name="13"></a><center><h2>3.2.2 HTTP URL.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; "Http" схема используется для доступа к сетевым ресурсам при помощи
<br>&nbsp; &nbsp; &nbsp; протокола HTTP. Этот раздел определяет схемо-определенный синтаксис
<br>&nbsp; &nbsp; &nbsp; и семантику для HTTP URL.
<br>
<br>&nbsp; &nbsp; &nbsp; http_URL       = "http:" "//" host [ ":" port ] [ abs_path ]
<br>
<br>&nbsp; &nbsp; &nbsp; host           = &lt;допустимое доменное имя машины
<br>&nbsp; &nbsp; &nbsp; или IP адрес (в точечно-десятичной форме),
<br>&nbsp; &nbsp; &nbsp; как определено в разделе 2.1 RFC 1123&gt;
<br>
<br>&nbsp; &nbsp; &nbsp; port           = *DIGIT
<br>
<br>
<br>&nbsp; &nbsp; &nbsp; Если порт пуст или не задан - используется порт 80. Это означает,
<br>&nbsp; &nbsp; &nbsp; что идентифицированный ресурс размещен в сервере, ожидающем TCP
<br>&nbsp; &nbsp; &nbsp; соединений на специфицированном порте port, компьютера host, и
<br>&nbsp; &nbsp; &nbsp; запрашиваемый URI ресурса - abs_path. Использования IP адресов в
<br>&nbsp; &nbsp; &nbsp; URL СЛЕДУЕТ избегать, когда это возможно (смотрите RFC 1900 [24]).
<br>&nbsp; &nbsp; &nbsp; Если abs_path не представлен в URL, он ДОЛЖЕН рассматриваться как
<br>&nbsp; &nbsp; &nbsp; "/" при вычислении запрашиваемого URI (Request-URI) ресурса
<br>&nbsp; &nbsp; &nbsp; (раздел 5.1.2).
<br>
<br>
<a name="14"></a><center><h2>3.2.3 Сравнение URI.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; При сравнении двух URI, чтобы решить соответствуют ли они друг
<br>&nbsp; &nbsp; &nbsp; другу или нет, клиенту СЛЕДУЕТ использовать чувствительное к
<br>&nbsp; &nbsp; &nbsp; регистру пооктетное (octet-by-octet) сравнение этих URI, со
<br>&nbsp; &nbsp; &nbsp; следующими исключениями:
<br>
<br>&nbsp; &nbsp; &nbsp; o  Порт, который пуст или не указан, эквивалентен заданному по
<br>&nbsp; &nbsp; &nbsp; умолчанию порту для этого URI;
<br>
<br>&nbsp; &nbsp; &nbsp; o  Сравнение имен хостов ДОЛЖНО производиться без учета регистра;
<br>
<br>&nbsp; &nbsp; &nbsp; o  Сравнение имен схем ДОЛЖНО производиться без учета регистра;
<br>
<br>&nbsp; &nbsp; &nbsp; o  Пустой abs_path эквивалентен "/".
<br>
<br>&nbsp; &nbsp; &nbsp; Символы, отличные от тех, что находятся в "зарезервированных"
<br>&nbsp; &nbsp; &nbsp; ("reserved") и "опасных" ("unsafe") наборах (см. раздел 3.2)
<br>&nbsp; &nbsp; &nbsp; эквивалентны их кодированию как ""%" HEX HEX ".
<br>
<br>&nbsp; &nbsp; &nbsp; Например следующие три URI эквивалентны:
<br>
<br>&nbsp; &nbsp; &nbsp; http://abc.com:80/~smith/home.html
<br>&nbsp; &nbsp; &nbsp; http://ABC.com/%7Esmith/home.html
<br>&nbsp; &nbsp; &nbsp; http://ABC.com:/%7esmith/home.html
<br>
<br>
<a name="15"></a><center><h2>3.3 Форматы даты/времени.</h2></center>
<br>
<br>
<a name="16"></a><center><h2>3.3.1 Полная дата.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; HTTP приложения исторически допускали три различных формата для
<br>&nbsp; &nbsp; &nbsp; представления даты/времени:
<br>
<br>&nbsp; &nbsp; &nbsp; Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, дополненный в RFC 1123
<br>&nbsp; &nbsp; &nbsp; Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, переписанный как RFC 1036
<br>&nbsp; &nbsp; &nbsp; Sun Nov  6 08:49:37 1994       ; формат asctime() ANSI C
<br>
<br>&nbsp; &nbsp; &nbsp; Первый формат выбран в качестве стандарта Интернета и представляет
<br>&nbsp; &nbsp; &nbsp; подмножество фиксированной длины, как определено в RFC 1123
<br>&nbsp; &nbsp; &nbsp; (модифицированном RFC 822). Второй формат находится в общем
<br>&nbsp; &nbsp; &nbsp; пользовании, но основан на устаревшем и потерявшем статус стандарта
<br>&nbsp; &nbsp; &nbsp; RFC 850 [12], описывающем форматы дат, он обладает тем недостатком,
<br>&nbsp; &nbsp; &nbsp; что год указывается не в четырехразрядной нотации. Клиенты и
<br>&nbsp; &nbsp; &nbsp; серверы HTTP/1.1, которые анализируют значение даты, ДОЛЖНЫ
<br>&nbsp; &nbsp; &nbsp; понимать все три формата (для совместимости с HTTP/1.0), но
<br>&nbsp; &nbsp; &nbsp; генерировать для представления значений дат в полях заголовка HTTP
<br>&nbsp; &nbsp; &nbsp; ДОЛЖНЫ только формат RFC 1123 .
<br>
<br>&nbsp; &nbsp; &nbsp; Обратите внимание: Поощряется практика, при которой получатели
<br>&nbsp; &nbsp; &nbsp; значений дат здраво воспринимают значения дат, которые, возможно,
<br>&nbsp; &nbsp; &nbsp; посланы не HTTP приложениями, что имеет место при загрузке или
<br>&nbsp; &nbsp; &nbsp; регистрации сообщений через прокси-сервера/шлюзы к SMTP или NNTP.
<br>
<br>&nbsp; &nbsp; &nbsp; Все без исключений форматы HTTP даты/времени ДОЛЖНЫ быть
<br>&nbsp; &nbsp; &nbsp; представлены в Greenwich Mean Time (GMT). В первых двух форматах
<br>&nbsp; &nbsp; &nbsp; данный факт указывается включением трехсимвольного сокращения "GMT"
<br>&nbsp; &nbsp; &nbsp; в качестве часового пояса. В asctime() формате это ДОЛЖНО
<br>&nbsp; &nbsp; &nbsp; подразумеваться при чтении.
<br>
<br>&nbsp; &nbsp; &nbsp; HTTP-date    = rfc1123-date | rfc850-date | asctime-date
<br>
<br>&nbsp; &nbsp; &nbsp; rfc1123-date = wkday "," SP date1 SP time SP "GMT"
<br>&nbsp; &nbsp; &nbsp; rfc850-date  = weekday "," SP date2 SP time SP "GMT"
<br>&nbsp; &nbsp; &nbsp; asctime-date = wkday SP date3 SP time SP 4DIGIT
<br>
<br>&nbsp; &nbsp; &nbsp; date1        = 2DIGIT SP month SP 4DIGIT
<br>&nbsp; &nbsp; &nbsp; ; день месяц год (например 02 Jun 1982)
<br>
<br>&nbsp; &nbsp; &nbsp; date2        = 2DIGIT "-" month "-" 2DIGIT
<br>&nbsp; &nbsp; &nbsp; ; день-месяц-год (напрмер 02-Jun-82)
<br>
<br>&nbsp; &nbsp; &nbsp; date3        = month SP ( 2DIGIT | ( SP 1DIGIT ))
<br>&nbsp; &nbsp; &nbsp; ; месяц день (например, Jun  2)
<br>
<br>&nbsp; &nbsp; &nbsp; time         = 2DIGIT ":" 2DIGIT ":" 2DIGIT
<br>&nbsp; &nbsp; &nbsp; ; 00:00:00 - 23:59:59
<br>
<br>&nbsp; &nbsp; &nbsp; wkday        = "Mon" | "Tue" | "Wed"
<br>&nbsp; &nbsp; &nbsp; | "Thu" | "Fri" | "Sat" | "Sun"
<br>
<br>&nbsp; &nbsp; &nbsp; weekday      = "Monday" | "Tuesday" | "Wednesday"
<br>&nbsp; &nbsp; &nbsp; | "Thursday" | "Friday" | "Saturday" | "Sunday"
<br>
<br>&nbsp; &nbsp; &nbsp; month        = "Jan" | "Feb" | "Mar" | "Apr"
<br>&nbsp; &nbsp; &nbsp; | "May" | "Jun" | "Jul" | "Aug"
<br>&nbsp; &nbsp; &nbsp; | "Sep" | "Oct" | "Nov" | "Dec"
<br>
<br>&nbsp; &nbsp; &nbsp; Обратите внимание: Эти требования - это требования к для
<br>&nbsp; &nbsp; &nbsp; форматам даты/времени, которые применяются внутри потока
<br>&nbsp; &nbsp; &nbsp; протокола HTTP. Клиентам и серверам не требуется использовать
<br>&nbsp; &nbsp; &nbsp; эти форматы для представления пользователю, регистрации
<br>&nbsp; &nbsp; &nbsp; запросов и т.д.
<br>
<br>
<a name="17"></a><center><h2>3.3.2 Разность секунд (delta seconds).</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Некоторые поля HTTP заголовка позволяют указывать значения времени
<br>&nbsp; &nbsp; &nbsp; в виде целого числа секунд, представленного в десятичной форме,
<br>&nbsp; &nbsp; &nbsp; которые должны пройти с того момента, как сообщение было получено.
<br>
<br>&nbsp; &nbsp; &nbsp; delta-seconds  = 1*DIGIT
<br>
<br>
<a name="18"></a><center><h2>3.4 Кодовые таблицы (character sets).</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; HTTP использует то же самое определение термина "кодовая таблица",
<br>&nbsp; &nbsp; &nbsp; которое описано для MIME:
<br>
<br>&nbsp; &nbsp; &nbsp; Термин "кодовая таблица" используется в данном документе, чтобы
<br>&nbsp; &nbsp; &nbsp; сослаться на метод, использующий одну или несколько таблиц для
<br>&nbsp; &nbsp; &nbsp; преобразования последовательности октетов в последовательность
<br>&nbsp; &nbsp; &nbsp; символов. Стоит отметить, что однозначное преобразование в
<br>&nbsp; &nbsp; &nbsp; обратном направлении не требуется, и что не все символы могут
<br>&nbsp; &nbsp; &nbsp; быть доступны в данной кодовой таблице, и что кодовая таблица
<br>&nbsp; &nbsp; &nbsp; может обеспечивать более чем одну последовательность октетов для
<br>&nbsp; &nbsp; &nbsp; представления специфических символов. Это определение допускает
<br>&nbsp; &nbsp; &nbsp; различные виды кодирования символов, от простых однотабличных
<br>&nbsp; &nbsp; &nbsp; отображений типа US-ASCII до сложных методов, переключающих
<br>&nbsp; &nbsp; &nbsp; таблицы, наподобие тех, которые используют методики ISO 2022.
<br>&nbsp; &nbsp; &nbsp; Однако определение, связанное с именем кодовой таблицы MIME
<br>&nbsp; &nbsp; &nbsp; ДОЛЖНО полностью определять отображение, которое преобразует
<br>&nbsp; &nbsp; &nbsp; октеты в символы. В частности использование внешней информации
<br>&nbsp; &nbsp; &nbsp; профилирования для определения точного отображения не
<br>&nbsp; &nbsp; &nbsp; разрешается.
<br>
<br>&nbsp; &nbsp; &nbsp; Обратите внимание: Это использование термина "кодовая таблица"
<br>&nbsp; &nbsp; &nbsp; обычно упоминается как "кодирование символов". Однако, с тех пор
<br>&nbsp; &nbsp; &nbsp; как HTTP и MIME совместно используют одиннаковую запись, важно,
<br>&nbsp; &nbsp; &nbsp; чтобы совпадала также и терминология.
<br>
<br>&nbsp; &nbsp; &nbsp; Кодовые таблицы HTTP идентифицируются лексемами, не чувствительными
<br>&nbsp; &nbsp; &nbsp; к регистру. Полный набор лексем определен реестром кодовых таблиц
<br>&nbsp; &nbsp; &nbsp; IANA [19].
<br>
<br>&nbsp; &nbsp; &nbsp; charset = token
<br>
<br>&nbsp; &nbsp; &nbsp; Хотя HTTP позволяет использовать в качестве значения charset
<br>&nbsp; &nbsp; &nbsp; произвольную лексему, любая лексема, которая имеет предопределенное
<br>&nbsp; &nbsp; &nbsp; значение в реестре кодовых таблиц IANA, ДОЛЖНА представлять набор
<br>&nbsp; &nbsp; &nbsp; символов, определенный в данном реестре. Приложениям СЛЕДУЕТ
<br>&nbsp; &nbsp; &nbsp; ограничить использование символьных наборов теми, которые
<br>&nbsp; &nbsp; &nbsp; определены в реестре IANA.
<br>
<br>
<a name="19"></a><center><h2>3.5 Кодирование содержимого (content codings).</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Значение кодирования содержимого указывает какое преобразование
<br>&nbsp; &nbsp; &nbsp; кодирования было или будет применено к объекту. Кодирование
<br>&nbsp; &nbsp; &nbsp; содержимого используется прежде всего для сжатия или другого
<br>&nbsp; &nbsp; &nbsp; полезного преобразования к документу без потери идентификации
<br>&nbsp; &nbsp; &nbsp; основного медиа типа и информации. Часто, объект сохраняется в
<br>&nbsp; &nbsp; &nbsp; кодированной форме, затем передается, а потом декодируется
<br>&nbsp; &nbsp; &nbsp; получателем.
<br>
<br>&nbsp; &nbsp; &nbsp; content-coding   = token
<br>
<br>&nbsp; &nbsp; &nbsp; Все значения кодирования содержимого (content-coding) не
<br>&nbsp; &nbsp; &nbsp; чувствительны к регистру. HTTP/1.1 использует значения кодирования
<br>&nbsp; &nbsp; &nbsp; содержимого (content-coding) в полях заголовка Accept-Encoding
<br>&nbsp; &nbsp; &nbsp; (раздел 14.3) и Content-Encoding (раздел 14.12). Хотя значение
<br>&nbsp; &nbsp; &nbsp; описывает кодирование содержимого, но, что более важно - оно
<br>&nbsp; &nbsp; &nbsp; указывает, какой механизм декодирования потребуется для обратного
<br>&nbsp; &nbsp; &nbsp; процесса.
<br>
<br>&nbsp; &nbsp; &nbsp; Internet Assigned Numbers Authority (IANA) действует как реестр
<br>&nbsp; &nbsp; &nbsp; для значений лексем кодирования содержимого (content-coding).
<br>&nbsp; &nbsp; &nbsp; Первоначально реестр содержал следующие лексемы:
<br>
<br>&nbsp; &nbsp; &nbsp; gzip
<br>&nbsp; &nbsp; &nbsp; Формат кодирования, производящий сжатие файла программой "gzip"
<br>&nbsp; &nbsp; &nbsp; (GNU zip), как описано в RFC 1952 [25]. Это формат Lempel-Ziv
<br>&nbsp; &nbsp; &nbsp; кодирования (LZ77) с 32 разрядным CRC.
<br>
<br>&nbsp; &nbsp; &nbsp; compress
<br>&nbsp; &nbsp; &nbsp; Формат кодирования, производимый общей программой "compress" для
<br>&nbsp; &nbsp; &nbsp; сжатия UNIX файлов. Это формат адаптивного Lempel-Ziv-Welch
<br>&nbsp; &nbsp; &nbsp; кодирования (LZW).
<br>
<br>&nbsp; &nbsp; &nbsp; Обратите внимание: Использовать названия программ для
<br>&nbsp; &nbsp; &nbsp; идентификации форматов кодирования не желательно и должно быть
<br>&nbsp; &nbsp; &nbsp; не понятно будущим кодированиям. Их использование здесь
<br>&nbsp; &nbsp; &nbsp; объясняется исторической практикой, но так делать не нужно. Для
<br>&nbsp; &nbsp; &nbsp; совместимости с предыдущими реализациями HTTP, приложения должны
<br>&nbsp; &nbsp; &nbsp; рассматривать "x-gzip" и "x-compress" как эквиваленты "gzip" и
<br>&nbsp; &nbsp; &nbsp; "compress" соответственно.
<br>
<br>&nbsp; &nbsp; &nbsp; deflate
<br>&nbsp; &nbsp; &nbsp; Формат zlib, определенный в RFC 1950 [31], в комбинации с
<br>&nbsp; &nbsp; &nbsp; механизмом сжатия "deflate", описанным в RFC 1951 [29].
<br>
<br>&nbsp; &nbsp; &nbsp; Новая лексема значения кодирования содержимого (content-coding)
<br>&nbsp; &nbsp; &nbsp; должна быть зарегистрирована; чтобы обеспечить взаимодействие между
<br>&nbsp; &nbsp; &nbsp; клиентами и серверами, спецификация алгоритма кодирования
<br>&nbsp; &nbsp; &nbsp; содержимого, необходимого для определения нового значения, должна
<br>&nbsp; &nbsp; &nbsp; быть открыто опубликована и адекватна для независимой реализации,
<br>&nbsp; &nbsp; &nbsp; а также соответствовать цели кодирования содержимого определенного
<br>&nbsp; &nbsp; &nbsp; в этом разделе.
<br>
<br>
<a name="20"></a><center><h2>3.6 Кодирование передачи (Transfer Codings).</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Значения кодирования передачи используются для указания
<br>&nbsp; &nbsp; &nbsp; преобразования кодирования, которое было или должно быть применено
<br>&nbsp; &nbsp; &nbsp; к телу объекта (entity-body) в целях гарантирования "безопасной
<br>&nbsp; &nbsp; &nbsp; передачи" по сети. Оно отличается от кодирования содержимого тем,
<br>&nbsp; &nbsp; &nbsp; что кодирование передачи - это свойство сообщения, а не
<br>&nbsp; &nbsp; &nbsp; первоначального объекта.
<br>
<br>&nbsp; &nbsp; &nbsp; transfer-coding         = "chunked" | transfer-extension
<br>
<br>&nbsp; &nbsp; &nbsp; transfer-extension      = token
<br>
<br>&nbsp; &nbsp; &nbsp; Все значения кодирования передачи (transfer-coding) не
<br>&nbsp; &nbsp; &nbsp; чувствительны к регистру. HTTP/1.1 использует значения кодирования
<br>&nbsp; &nbsp; &nbsp; передачи (transfer-coding) в поле заголовка Transfer-Encoding
<br>&nbsp; &nbsp; &nbsp; (раздел 14.40).
<br>
<br>&nbsp; &nbsp; &nbsp; Кодирования передачи - это аналоги значений
<br>&nbsp; &nbsp; &nbsp; Content-Transfer-Encoding MIME, которые были разработаны для
<br>&nbsp; &nbsp; &nbsp; обеспечения безопасной передачи двоичных данных при использовании
<br>&nbsp; &nbsp; &nbsp; 7-битного обслуживания передачи. Однако безопасный транспорт
<br>&nbsp; &nbsp; &nbsp; имеет другое предназначение для чисто 8-битного протокола передачи.
<br>&nbsp; &nbsp; &nbsp; В HTTP единственая опасная характеристика тела сообщения вызвана
<br>&nbsp; &nbsp; &nbsp; сложностью определения точной длины тела сообщения (раздел 7.2.2),
<br>&nbsp; &nbsp; &nbsp; или желанием шифровать данные при пользовании общедоступным
<br>&nbsp; &nbsp; &nbsp; транспортом.
<br>
<br>&nbsp; &nbsp; &nbsp; Кодирование по кускам (chunked encoding) изменяет тело сообщения
<br>&nbsp; &nbsp; &nbsp; для передачи его последовательностью кусков, каждый из которых
<br>&nbsp; &nbsp; &nbsp; имеет собственный индикатор размера, сопровождаемым опциональным
<br>&nbsp; &nbsp; &nbsp; завершителем, содержащим поля заголовка объекта. Это позволяет
<br>&nbsp; &nbsp; &nbsp; динамически создаваемому содержимому передаваться вместе с
<br>&nbsp; &nbsp; &nbsp; информацией, необходимой получателю для проверки полноты получения
<br>&nbsp; &nbsp; &nbsp; сообщения.
<br>
<br>&nbsp; &nbsp; &nbsp; Chunked-Body   = *chunk
<br>&nbsp; &nbsp; &nbsp; "0" CRLF
<br>&nbsp; &nbsp; &nbsp; footer
<br>&nbsp; &nbsp; &nbsp; CRLF
<br>
<br>&nbsp; &nbsp; &nbsp; chunk          = chunk-size [ chunk-ext ] CRLF
<br>&nbsp; &nbsp; &nbsp; chunk-data CRLF
<br>
<br>&nbsp; &nbsp; &nbsp; hex-no-zero    = &lt;HEX за исключением "0"&gt;
<br>
<br>&nbsp; &nbsp; &nbsp; chunk-size     = hex-no-zero *HEX
<br>&nbsp; &nbsp; &nbsp; chunk-ext      = *( ";" chunk-ext-name [ "=" chunk-ext-value ] )
<br>&nbsp; &nbsp; &nbsp; chunk-ext-name = token
<br>&nbsp; &nbsp; &nbsp; chunk-ext-val  = token | quoted-string
<br>&nbsp; &nbsp; &nbsp; chunk-data     = chunk-size(OCTET)
<br>
<br>&nbsp; &nbsp; &nbsp; footer         = *entity-header
<br>
<br>&nbsp; &nbsp; &nbsp; Кодирование по кускам (chunked encoding) оканчивается куском
<br>&nbsp; &nbsp; &nbsp; нулевого размера, следующим за завершителем, оканчивающимся пустой
<br>&nbsp; &nbsp; &nbsp; строкой. Цель завершителя состоит в эффективном методе обеспечения
<br>&nbsp; &nbsp; &nbsp; информации об объекте, который сгенерирован динамически; приложения
<br>&nbsp; &nbsp; &nbsp; НЕ ДОЛЖНЫ посылать в завершителе поля заголовка, которые явно не
<br>&nbsp; &nbsp; &nbsp; предназначены для использования в завершителе, такие как
<br>&nbsp; &nbsp; &nbsp; Content-MD5 или будущие расширения HTTP для цифровых подписей и
<br>&nbsp; &nbsp; &nbsp; других возможностей.
<br>
<br>&nbsp; &nbsp; &nbsp; Примерный процесс декодирования Chunked-Body представлен в
<br>&nbsp; &nbsp; &nbsp; приложении 19.4.6.
<br>
<br>&nbsp; &nbsp; &nbsp; Все HTTP/1.1 приложения ДОЛЖНЫ быть в состоянии получать и
<br>&nbsp; &nbsp; &nbsp; декодировать кодирование передачи "по кускам" ("chunked" transfer
<br>&nbsp; &nbsp; &nbsp; coding), и ДОЛЖНЫ игнорировать расширения кодирования передачи,
<br>&nbsp; &nbsp; &nbsp; которые они не понимают. Серверу, который получил тело объекта со
<br>&nbsp; &nbsp; &nbsp; значением кодирования передачи, которое он не понимает, СЛЕДУЕТ
<br>&nbsp; &nbsp; &nbsp; возвратить ответ с кодом 501 (Не реализовано, Not Implemented) и
<br>&nbsp; &nbsp; &nbsp; разорвать соединение. Сервер НЕ ДОЛЖЕН посылать поля кодирования
<br>&nbsp; &nbsp; &nbsp; передачи (transfer-coding) HTTP/1.0 клиентам.
<br>
<br>
<a name="21"></a><center><h2>3.7 Медиа типы (Media Types).</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; HTTP использует Медиа Типы Интернета (Internet Media Types) в полях
<br>&nbsp; &nbsp; &nbsp; заголовка Content-Type (раздел 14.18) и Accept (раздел 14.1) для
<br>&nbsp; &nbsp; &nbsp; обеспечения открытой и расширяемой типизации данных и обсуждения
<br>&nbsp; &nbsp; &nbsp; типов.
<br>
<br>&nbsp; &nbsp; &nbsp; media-type     = type "/" subtype *( ";" parameter )
<br>&nbsp; &nbsp; &nbsp; type           = token
<br>&nbsp; &nbsp; &nbsp; subtype        = token
<br>
<br>&nbsp; &nbsp; &nbsp; Параметры могут следовать за type/subtype в форме пар
<br>&nbsp; &nbsp; &nbsp; атрибут/значение (attribute/value).
<br>
<br>&nbsp; &nbsp; &nbsp; parameter      = attribute "=" value
<br>&nbsp; &nbsp; &nbsp; attribute      = token
<br>&nbsp; &nbsp; &nbsp; value          = token | quoted-string
<br>
<br>&nbsp; &nbsp; &nbsp; Тип, подтип, и имена атрибутов и параметров  не чувствительны к
<br>&nbsp; &nbsp; &nbsp; регистру. Значения параметров могут быть чувствительными к регистру,
<br>&nbsp; &nbsp; &nbsp; но могут быть и не чувствительны, в зависимости от семантики имени
<br>&nbsp; &nbsp; &nbsp; параметра. Линейный пробел (LWS) НЕ ДОЛЖЕН использоваться между
<br>&nbsp; &nbsp; &nbsp; типом и подтипом, между атрибутом и значением. Агенты пользователей,
<br>&nbsp; &nbsp; &nbsp; распознающие медиа типы, ДОЛЖНЫ обрабатывать (или подготавливать
<br>&nbsp; &nbsp; &nbsp; для обработки любыми внешними приложениями) параметры для тех типов
<br>&nbsp; &nbsp; &nbsp; MIME, которые описаны, и сообщать пользователю о обнаруженных
<br>&nbsp; &nbsp; &nbsp; проблемах.
<br>
<br>&nbsp; &nbsp; &nbsp; Обратите внимание: Некоторые старые HTTP приложения не распознают
<br>&nbsp; &nbsp; &nbsp; параметры медиа типов. При посылке данных к таким HTTP приложениям
<br>&nbsp; &nbsp; &nbsp; реализации должны использовать параметры медиа типов только когда
<br>&nbsp; &nbsp; &nbsp; это требуется по определению типа/подтипа.
<br>
<br>&nbsp; &nbsp; &nbsp; Значения медиа-типов регистрируются Internet Assigned Number
<br>&nbsp; &nbsp; &nbsp; Authority (IANA). Процесс регистрации медиа типа определен в RFC
<br>&nbsp; &nbsp; &nbsp; 2048 [17]. Использование не зарегистрированных медиа типов вводит
<br>&nbsp; &nbsp; &nbsp; в заблуждение.
<br>
<br>
<a name="22"></a><center><h2>3.7.1 Канонизация и предопределенные значения типа text.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Медиа типы Интернета зарегистрированы в канонической форме. Вообще,
<br>&nbsp; &nbsp; &nbsp; тело объекта, передаваемое HTTP сообщением, ДОЛЖНО быть
<br>&nbsp; &nbsp; &nbsp; представлено в соответствующей каноническиой форме до передачи;
<br>&nbsp; &nbsp; &nbsp; исключение составляют типы "text", определяемые в следующем абзаце.
<br>
<br>&nbsp; &nbsp; &nbsp; В канонической форме медиа подтипы типа "text" используют CRLF в
<br>&nbsp; &nbsp; &nbsp; качестве метки конца строки. HTTP ослабляет это требование и
<br>&nbsp; &nbsp; &nbsp; позволяет передавать текст размеченный таким образом, что еденичные
<br>&nbsp; &nbsp; &nbsp; CR или LF могут быть метками конца строки, правда это правило
<br>&nbsp; &nbsp; &nbsp; должно быть выполнено для всего тела объекта (entity-body). HTTP
<br>&nbsp; &nbsp; &nbsp; приложения ДОЛЖНЫ воспринимать CRLF, просто CR, и просто LF как
<br>&nbsp; &nbsp; &nbsp; представление конца строки в текстовых типах, переданных по HTTP.
<br>&nbsp; &nbsp; &nbsp; Кроме того, если текст представляется в кодовой таблице, которая
<br>&nbsp; &nbsp; &nbsp; не использует октеты 13 и 10 для CR и LF соответственно, что имеет
<br>&nbsp; &nbsp; &nbsp; место в некоторых многобайтовых кодовых таблицах, то HTTP позволяет
<br>&nbsp; &nbsp; &nbsp; использовать любые последовательности октетов, определенные этим
<br>&nbsp; &nbsp; &nbsp; набором символов для представления эквивалентов CR и LF в качестве
<br>&nbsp; &nbsp; &nbsp; кода конца строки. Эта гибкость в отношении концов строк применима
<br>&nbsp; &nbsp; &nbsp; только к текстовым типам в теле объекта; просто CR или просто LF НЕ
<br>&nbsp; &nbsp; &nbsp; ДОЛЖНЫ заменять CRLF внутри любой управляющей структуры HTTP (типа
<br>&nbsp; &nbsp; &nbsp; поля заголовка и разделителей типа multipart).
<br>
<br>&nbsp; &nbsp; &nbsp; Если тело объекта кодируется при помощи Content-Encoding, то
<br>&nbsp; &nbsp; &nbsp; основные данные ДОЛЖНЫ быть в определенной выше форме до
<br>&nbsp; &nbsp; &nbsp; кодирования.
<br>
<br>&nbsp; &nbsp; &nbsp; Параметр "charset" используется с некоторыми медиа типами для
<br>&nbsp; &nbsp; &nbsp; указания кодовой таблицы (раздел 3.4), используемой для
<br>&nbsp; &nbsp; &nbsp; представления данных. Если параметр "charset" не указан
<br>&nbsp; &nbsp; &nbsp; отправителем, то при получении по HTTP медиа подтипы типа "text"
<br>&nbsp; &nbsp; &nbsp; имеют значение "charset", по умолчанию равное "ISO-8859-1". Данные
<br>&nbsp; &nbsp; &nbsp; в кодовых таблицах или их подмножествах, отличных от "ISO-8859-1"
<br>&nbsp; &nbsp; &nbsp; ДОЛЖНЫ быть помечены соответствующим значением "charset".
<br>
<br>&nbsp; &nbsp; &nbsp; Некоторое программное обеспечение HTTP/1.0 интерпретировало
<br>&nbsp; &nbsp; &nbsp; заголовок Content-Type без параметра "charset" неправильно, как
<br>&nbsp; &nbsp; &nbsp; означающее "должен предположить получатель". Отправители, желающие
<br>&nbsp; &nbsp; &nbsp; предусмотреть такое поведение МОГУТ включать параметр "charset"
<br>&nbsp; &nbsp; &nbsp; даже когда charset равен ISO-8859-1 и ДОЛЖНЫ сделать это, если
<br>&nbsp; &nbsp; &nbsp; известно, что это не запутает получателя.
<br>
<br>&nbsp; &nbsp; &nbsp; К сожалению, некоторые старые HTTP/1.0 клиенты не работали правильно
<br>&nbsp; &nbsp; &nbsp; с определением параметра "charset". HTTP/1.1 получатели ДОЛЖНЫ
<br>&nbsp; &nbsp; &nbsp; отдавать приоритет метке "charset", поставленной отправителем; и те
<br>&nbsp; &nbsp; &nbsp; агенты пользователей, которые имеют возможность "предположить"
<br>&nbsp; &nbsp; &nbsp; charset ДОЛЖНЫ при первоначальном отображении документа использовать
<br>&nbsp; &nbsp; &nbsp; charset из поля content-type, если они поддерживают такой charset,
<br>&nbsp; &nbsp; &nbsp; а затем использовать собственные установки.
<br>
<br>
<a name="23"></a><center><h2>3.7.2 Типы Multipart.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; MIME предусматривает ряд типов "multipart" - формирующих пакет из
<br>&nbsp; &nbsp; &nbsp; одного или нескольких объектов внутри тела одного сообщения. Все
<br>&nbsp; &nbsp; &nbsp; типы mulptipart используют общий синтаксис, определеный в MIME [7],
<br>&nbsp; &nbsp; &nbsp; и ДОЛЖНЫ содержать разделительный параметр частью значения медиа
<br>&nbsp; &nbsp; &nbsp; типа. Тело сообщения - самостоятельный элемент протокола и,
<br>&nbsp; &nbsp; &nbsp; следовательно, ДОЛЖНО использовать только СRLF для представления
<br>&nbsp; &nbsp; &nbsp; концов строк между частями тела (body-parts). В отличие от MIME,
<br>&nbsp; &nbsp; &nbsp; окончание любого multipart сообщения ДОЛЖНО быть пустым; HTTP
<br>&nbsp; &nbsp; &nbsp; приложения НЕ ДОЛЖНЫ передавать окончание (даже если первоначальный
<br>&nbsp; &nbsp; &nbsp; multipart содержит заключение).
<br>
<br>&nbsp; &nbsp; &nbsp; В HTTP части тела (body-parts) типа multipart МОГУТ содержать поля
<br>&nbsp; &nbsp; &nbsp; заголовка, которые являются значащими в примнении к этой части.
<br>&nbsp; &nbsp; &nbsp; Поле заголовка Content-Location (раздел 14.15) СЛЕДУЕТ включать в
<br>&nbsp; &nbsp; &nbsp; часть тела (body-part) каждого включенного объекта, который может
<br>&nbsp; &nbsp; &nbsp; быть идентифицирован URL.
<br>
<br>&nbsp; &nbsp; &nbsp; Вообще говоря, HTTP агенту пользователя СЛЕДУЕТ следовать такому же
<br>&nbsp; &nbsp; &nbsp; или подобному поведению, которому следовал бы MIME агент
<br>&nbsp; &nbsp; &nbsp; пользователя после получения типа multipart. Если приложение
<br>&nbsp; &nbsp; &nbsp; получает незарегистрированный подтип multipart, оно ДОЛЖНО
<br>&nbsp; &nbsp; &nbsp; обрабатывать его как подтип "multipart/mixed".
<br>
<br>&nbsp; &nbsp; &nbsp; Обратите внимание: тип "multipart/form-data" был специально
<br>&nbsp; &nbsp; &nbsp; определен для передачи данных формы, подходящих для обработки
<br>&nbsp; &nbsp; &nbsp; методом запроса POST, что описано в RFC 1867 [15].
<br>
<br>
<a name="24"></a><center><h2>3.8 Лексемы программ (Product Tokens).</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Лексемы программ используются, чтобы обеспечить коммуникационным
<br>&nbsp; &nbsp; &nbsp; приложениям возможность идентифицировать себя названием и версией
<br>&nbsp; &nbsp; &nbsp; программного обеспечения. Большинство полей, использующих лексемы
<br>&nbsp; &nbsp; &nbsp; программ также допускает перечисление подпрограмм, которые формируют
<br>&nbsp; &nbsp; &nbsp; значительную часть приложения, и которые перечисляются через пробел.
<br>&nbsp; &nbsp; &nbsp; В соответствии с соглашением, подпрограммы перечисляются в порядке
<br>&nbsp; &nbsp; &nbsp; их значения для идентификации приложения.
<br>
<br>&nbsp; &nbsp; &nbsp; product         = token ["/" product-version]
<br>&nbsp; &nbsp; &nbsp; product-version = token
<br>
<br>&nbsp; &nbsp; &nbsp; Примеры:
<br>
<br>&nbsp; &nbsp; &nbsp; User-Agent: CERN-LineMode/2.15 libwww/2.17b3
<br>&nbsp; &nbsp; &nbsp; Server: Apache/0.8.4
<br>
<br>&nbsp; &nbsp; &nbsp; Лексемы программ должны быть короткими и по сути - использование их
<br>&nbsp; &nbsp; &nbsp; для рекламы или другой несущественной информации однозначно
<br>&nbsp; &nbsp; &nbsp; запрещено. Хотя в лексеме product-version может встречаться любой
<br>&nbsp; &nbsp; &nbsp; символ, все же ее следует использовать только для идентификатора
<br>&nbsp; &nbsp; &nbsp; версии (то есть, последовательным версиям одной и той же программы
<br>&nbsp; &nbsp; &nbsp; СЛЕДУЕТ иметь отличия только в части product-version лексемы
<br>&nbsp; &nbsp; &nbsp; product.
<br>
<br>
<a name="25"></a><center><h2>3.9 Качественные значения (Quality Values).</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Обсуждение содержимого HTTP (раздел 12) использует короткие числа "с
<br>&nbsp; &nbsp; &nbsp; плавающей точкой" для указания относительной важности ("веса")
<br>&nbsp; &nbsp; &nbsp; различных оговоренных параметров. Вес - это нормализованое
<br>&nbsp; &nbsp; &nbsp; вещественное число в диапазоне от 0 до 1, где 0 - минимальное, а
<br>&nbsp; &nbsp; &nbsp; 1 - максимальное значение. HTTP/1.1 приложения НЕ ДОЛЖНЫ
<br>&nbsp; &nbsp; &nbsp; генерировать более трех цифр после десятичной точки.
<br>&nbsp; &nbsp; &nbsp; Пользовательским конфигурациям этих значений СЛЕДУЕТ также
<br>&nbsp; &nbsp; &nbsp; ограничиваться этим режимом.
<br>
<br>&nbsp; &nbsp; &nbsp; qvalue         = ( "0" [ "." 0*3DIGIT ] )
<br>&nbsp; &nbsp; &nbsp; | ( "1" [ "." 0*3("0") ] )
<br>
<br>&nbsp; &nbsp; &nbsp; "Качественные значения" - не корректное название, так как эти
<br>&nbsp; &nbsp; &nbsp; значения просто представляют отношение снижения производительности
<br>&nbsp; &nbsp; &nbsp; к желательному качеству.
<br>
<br>
<a name="26"></a><center><h2>3.10 Метки языков (Language Tags).</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Метка языка идентифицирует естественный язык: разговорный,
<br>&nbsp; &nbsp; &nbsp; письменный, или другой используемый людьми для обмена информацмей
<br>&nbsp; &nbsp; &nbsp; с другими людьми. Машинные языки являются исключением. HTTP
<br>&nbsp; &nbsp; &nbsp; использует метки языка внутри полей Accept-Language и
<br>&nbsp; &nbsp; &nbsp; Content-Language.
<br>
<br>&nbsp; &nbsp; &nbsp; Синтаксис и запись HTTP меток языка такие же, как определяемые
<br>&nbsp; &nbsp; &nbsp; RFC 1766 [1]. В резюме, метка языка состоит из одной или нескольких
<br>&nbsp; &nbsp; &nbsp; частей: метка первичного языка и, возможно пустой, ряд подчиненных
<br>&nbsp; &nbsp; &nbsp; меток:
<br>
<br>&nbsp; &nbsp; &nbsp; language-tag  = primary-tag *( "-" subtag )
<br>
<br>&nbsp; &nbsp; &nbsp; primary-tag   = 1*8ALPHA
<br>&nbsp; &nbsp; &nbsp; subtag        = 1*8ALPHA
<br>
<br>&nbsp; &nbsp; &nbsp; Внутри метки не допустим пробел и все метки не чувствительны к
<br>&nbsp; &nbsp; &nbsp; регистру. Пространство имен меток языка управляется IANA. Например
<br>&nbsp; &nbsp; &nbsp; метки содержат:
<br>
<br>&nbsp; &nbsp; &nbsp; en, en-US, en-cockney, i-cherokee, x-pig-latin
<br>
<br>&nbsp; &nbsp; &nbsp; Любая двухсимвольная первичная метка является меткой аббревеатуры
<br>&nbsp; &nbsp; &nbsp; языка ISO 639, а любая двухсимвольная подчиненная метка является
<br>&nbsp; &nbsp; &nbsp; меткой кода страны ISO 3166. (Последние три метки из
<br>&nbsp; &nbsp; &nbsp; вышеперечисленных - не зарегистрированные метки; все, кроме
<br>&nbsp; &nbsp; &nbsp; последней - примеры меток, которые могли бы быть зарегистрированы
<br>&nbsp; &nbsp; &nbsp; в будущем.)
<br>
<br>
<a name="27"></a><center><h2>3.11 Метки объектов (Entity Tags).</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Метки объектов используются для сравнения двух или более объектов
<br>&nbsp; &nbsp; &nbsp; от одного и того же запрошенного ресурса. HTTP/1.1 использует метки
<br>&nbsp; &nbsp; &nbsp; объекта в полях заголовка ETag (раздел 14.20), If-Match (раздел
<br>&nbsp; &nbsp; &nbsp; 14.25), If-None-Match (раздел 14.26), и If-Range (раздел 14.27).
<br>&nbsp; &nbsp; &nbsp; Определение того, как они используются и сравниваются в качестве
<br>&nbsp; &nbsp; &nbsp; меток проверки кэша находится в разделе 13.3.3. Метка объекта
<br>&nbsp; &nbsp; &nbsp; состоит из непрозрачной цитируемой строки (opaque quoted string),
<br>&nbsp; &nbsp; &nbsp; возможно предваренной индикатором слабости (weakness indicator).
<br>
<br>&nbsp; &nbsp; &nbsp; entity-tag = [ weak ] opaque-tag
<br>
<br>&nbsp; &nbsp; &nbsp; weak       = "W/"
<br>&nbsp; &nbsp; &nbsp; opaque-tag = quoted-string
<br>
<br>&nbsp; &nbsp; &nbsp; "Сильная метка объекта" ("strong entity tag") может быть разделена
<br>&nbsp; &nbsp; &nbsp; двумя объектами ресурса, только если они пооктетно эквивалентны.
<br>
<br>&nbsp; &nbsp; &nbsp; "Слабая метка объекта" ("weak entity tag"), обозначяемая префиксом
<br>&nbsp; &nbsp; &nbsp; "W/", может быть разделена двумя объектами ресурса только если
<br>&nbsp; &nbsp; &nbsp; объекты эквивалентны и могли бы заменять друг друга без
<br>&nbsp; &nbsp; &nbsp; значительного изменения в семантике. Слабая метка объекта может
<br>&nbsp; &nbsp; &nbsp; использоваться только для слабого сравнения.
<br>
<br>&nbsp; &nbsp; &nbsp; Метка объекта ДОЛЖНА быть уникальна среди всех версий всех
<br>&nbsp; &nbsp; &nbsp; объектов, связанных с конкретным ресурсом. Данное значение метки
<br>&nbsp; &nbsp; &nbsp; объекта может использоваться для объектов, полученных запросами
<br>&nbsp; &nbsp; &nbsp; различных URI без предположения эквивалентности этих объектов.
<br>
<br>
<a name="28"></a><center><h2>3.12 Еденицы измерения диапазонов (Range Units).</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; HTTP/1.1 позволяет клиенту запрашивать только часть объекта.
<br>&nbsp; &nbsp; &nbsp; HTTP/1.1 использует еденицы измерения диапазонов в полях заголовка
<br>&nbsp; &nbsp; &nbsp; Range (раздел 14.36) и Content-Range (раздел 14.17). Объект может
<br>&nbsp; &nbsp; &nbsp; быть разбит на части соответственно различным структурным модулям.
<br>
<br>&nbsp; &nbsp; &nbsp; range-unit       = bytes-unit | other-range-unit
<br>
<br>&nbsp; &nbsp; &nbsp; bytes-unit       = "bytes"
<br>&nbsp; &nbsp; &nbsp; other-range-unit = token
<br>
<br>&nbsp; &nbsp; &nbsp; Единственая еденица измерения диапазонов, определенная в HTTP/1.1
<br>&nbsp; &nbsp; &nbsp; - это "bytes". Реализации HTTP/1.1 могут игнорировать диапазоны,
<br>&nbsp; &nbsp; &nbsp; определенные с использованием других едениц измерения. HTTP/1.1
<br>&nbsp; &nbsp; &nbsp; был разработан, чтобы допускать реализации приложений, которые не
<br>&nbsp; &nbsp; &nbsp; зависят от знания диапазонов.
<br>
<br>
<a name="29"></a><center><h2>4 HTTP сообщение (HTTP Message).</h2></center>
<br>
<br>
<a name="30"></a><center><h2>4.1 Типы сообщений.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; HTTP сообщения делятся на запросы клиента серверу и ответы сервера
<br>&nbsp; &nbsp; &nbsp; клиенту.
<br>
<br>&nbsp; &nbsp; &nbsp; HTTP-message   = Request | Response    ; сообщения HTTP/1.1
<br>
<br>&nbsp; &nbsp; &nbsp; Сообщения запроса (раздел 5) и ответа (раздел 6) используют
<br>&nbsp; &nbsp; &nbsp; обобщенный формат сообщения RFC 822 [9] для пересылки объектов
<br>&nbsp; &nbsp; &nbsp; (полезной нагрузки сообщения). Оба типа сообщений выглядят
<br>&nbsp; &nbsp; &nbsp; следующим образом: сначала идет начальная строка (start-line),
<br>&nbsp; &nbsp; &nbsp; затем один или несколько полей заголовка (называемых также просто
<br>&nbsp; &nbsp; &nbsp; "заголовки"), затем пустая строка (то есть строка, равная CRLF),
<br>&nbsp; &nbsp; &nbsp; указывающая конец полей заголовка, а затем, возможно, тело
<br>&nbsp; &nbsp; &nbsp; сообщения.
<br>
<br>&nbsp; &nbsp; &nbsp; generic-message = start-line
<br>&nbsp; &nbsp; &nbsp; *message-header
<br>&nbsp; &nbsp; &nbsp; CRLF
<br>&nbsp; &nbsp; &nbsp; [ message-body ]
<br>
<br>&nbsp; &nbsp; &nbsp; start-line      = Request-Line | Status-Line
<br>
<br>&nbsp; &nbsp; &nbsp; В интересах ошибкоустойчивости, серверам СЛЕДУЕТ игнорировать
<br>&nbsp; &nbsp; &nbsp; все пустые строки, полученные перед строкой запроса
<br>&nbsp; &nbsp; &nbsp; (Request-Line). Другими словами, если сервер читает поток
<br>&nbsp; &nbsp; &nbsp; протокола и в самом начале сообщения получает CRLF, то ему следует
<br>&nbsp; &nbsp; &nbsp; этот CRLF игнорировать.
<br>
<br>&nbsp; &nbsp; &nbsp; Обратите внимание: некоторые ошибочные реализации HTTP/1.0
<br>&nbsp; &nbsp; &nbsp; клиентов генерируют дополнительные CRLF после запроса POST.
<br>&nbsp; &nbsp; &nbsp; Стоит вновь повторить, что это явно запрещено нормальной записью
<br>&nbsp; &nbsp; &nbsp; Бекуса-Наура. HTTP/1.1 клиент не должен добавлять дополнительные
<br>&nbsp; &nbsp; &nbsp; CRLF перед запросом и после него.
<br>
<br>
<a name="31"></a><center><h2>4.2 Заголовки сообщений.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Поля заголовков HTTP, которые включают поля общих заголовков
<br>&nbsp; &nbsp; &nbsp; (general-header) (раздел 4.5), заголовков запроса (request-header)
<br>&nbsp; &nbsp; &nbsp; (раздел 5.3), заголовков ответа (response-header) (раздел 6.2), и
<br>&nbsp; &nbsp; &nbsp; заголовков объекта (entity-header) (раздел 7.1), имеют такой же
<br>&nbsp; &nbsp; &nbsp; обобщенный формат, что описан в разделе 3.1 RFC 822 [9]. Каждое
<br>&nbsp; &nbsp; &nbsp; поле заголовка состоит из имени, двоеточия (":") и значения поля.
<br>&nbsp; &nbsp; &nbsp; Имена полей не чувствительны к регистру. Значению поля может
<br>&nbsp; &nbsp; &nbsp; предшествовать любое число LWS, хотя предпочтителен одиночный SP.
<br>&nbsp; &nbsp; &nbsp; Поля заголовка могут занимать несколько строк. При этом каждая
<br>&nbsp; &nbsp; &nbsp; следующая строка начинается по крайней мере одним SP или HT.
<br>&nbsp; &nbsp; &nbsp; Приложениям СЛЕДУЕТ придерживаться "общей формы" ("common form")
<br>&nbsp; &nbsp; &nbsp; при генерации HTTP конструкций, так как могут существовать
<br>&nbsp; &nbsp; &nbsp; реализации, которые не в состоянии принимать что-либо кроме общих
<br>&nbsp; &nbsp; &nbsp; форм.
<br>
<br>&nbsp; &nbsp; &nbsp; message-header = field-name ":" [ field-value ] CRLF
<br>
<br>&nbsp; &nbsp; &nbsp; field-name     = token
<br>&nbsp; &nbsp; &nbsp; field-value    = *( field-content | LWS )
<br>
<br>&nbsp; &nbsp; &nbsp; field-content  = &lt;октеты, составляющие значение поля и
<br>&nbsp; &nbsp; &nbsp; состоящие или из *TEXT или из комбинаций
<br>&nbsp; &nbsp; &nbsp; лексем, tspecials, и quoted-string&gt;
<br>
<br>&nbsp; &nbsp; &nbsp; Порядок, в котором получены поля заголовка с различными именами
<br>&nbsp; &nbsp; &nbsp; не имеет значения. Однако "хорошая практика" заключается в том,
<br>&nbsp; &nbsp; &nbsp; что сначала посылаются поля общих заголовков, затем поля
<br>&nbsp; &nbsp; &nbsp; заголовков запроса или заголовков ответа, и, наконец, поля
<br>&nbsp; &nbsp; &nbsp; заголовков объекта.
<br>
<br>&nbsp; &nbsp; &nbsp; Несколько полей заголовка с одиннаковыми именами могут
<br>&nbsp; &nbsp; &nbsp; присутствовать в сообщении тогда, и только тогда, когда все
<br>&nbsp; &nbsp; &nbsp; значения полей, входящих в заголовок, определяют разделенный
<br>&nbsp; &nbsp; &nbsp; запятыми список [то есть #(value)]. ДОЛЖНО быть возможно
<br>&nbsp; &nbsp; &nbsp; объединить несколько таких полей заголовка в одну пару "имя поля:
<br>&nbsp; &nbsp; &nbsp; значение поля" (не измененяя этим семантику сообщения) присоединяя
<br>&nbsp; &nbsp; &nbsp; каждое последующее значение поля к первому через запятые. Порядок,
<br>&nbsp; &nbsp; &nbsp; в котором получены поля с одинаковыми именами, имеет значение
<br>&nbsp; &nbsp; &nbsp; для интерпретации объединенного значения поля, и, следовательно,
<br>&nbsp; &nbsp; &nbsp; прокси-сервер НЕ ДОЛЖЕН изменять порядок значений этого поля при
<br>&nbsp; &nbsp; &nbsp; пересылке.
<br>
<br>
<a name="32"></a><center><h2>4.3 Тело cообщения.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Тело HTTP сообщения (message-body), если оно присутствует,
<br>&nbsp; &nbsp; &nbsp; используется для передачи тела объекта, связанного с запросом или
<br>&nbsp; &nbsp; &nbsp; ответом. Тело сообщения (message-body) отличается от тела объекта
<br>&nbsp; &nbsp; &nbsp; (entity-body) только в том случае, когда применяется кодирование
<br>&nbsp; &nbsp; &nbsp; передачи, что указывается полем заголовка Transfer-Encoding
<br>&nbsp; &nbsp; &nbsp; (раздел 14.40).
<br>
<br>&nbsp; &nbsp; &nbsp; message-body = entity-body
<br>&nbsp; &nbsp; &nbsp; | &lt;entity-body закодированно согласно
<br>&nbsp; &nbsp; &nbsp; Transfer-Encoding&gt;
<br>
<br>&nbsp; &nbsp; &nbsp; Поле Transfer-Encoding ДОЛЖНО использоваться для указания любого
<br>&nbsp; &nbsp; &nbsp; кодирования передачи, примененного приложением в целях
<br>&nbsp; &nbsp; &nbsp; гарантирования безопасной и правильной передачи сообщения. Поле
<br>&nbsp; &nbsp; &nbsp; Transfer-Encoding - это свойство сообщения, а не объекта, и, таким
<br>&nbsp; &nbsp; &nbsp; образом, может быть добавлено или удалено любым приложением в
<br>&nbsp; &nbsp; &nbsp; цепочке запросов/ответов.
<br>
<br>&nbsp; &nbsp; &nbsp; Правила, устанавливающие допустимость тела сообщения в сообщении,
<br>&nbsp; &nbsp; &nbsp; отличны для запросов и ответов.
<br>
<br>&nbsp; &nbsp; &nbsp; Присутствие тела сообщения в запросе отмечается добавлением к
<br>&nbsp; &nbsp; &nbsp; заголовкам запроса поля заголовка Content-Length или
<br>&nbsp; &nbsp; &nbsp; Transfer-Encoding. Тело сообщения (message-body) МОЖЕТ быть
<br>&nbsp; &nbsp; &nbsp; добавлено в запрос только когда метод запроса допускает тело
<br>&nbsp; &nbsp; &nbsp; объекта (entity-body) (раздел 5.1.1).
<br>
<br>&nbsp; &nbsp; &nbsp; Включается или не включается тело сообщения (message-body) в
<br>&nbsp; &nbsp; &nbsp; сообщение ответа зависит как от метода запроса, так и от кода
<br>&nbsp; &nbsp; &nbsp; состояния ответа (раздел 6.1.1). Все ответы на запрос с методом
<br>&nbsp; &nbsp; &nbsp; HEAD НЕ ДОЛЖНЫ включать тело сообщения (message-body), даже если
<br>&nbsp; &nbsp; &nbsp; присутствуют поля заголовка объекта (entity-header), заставляющие
<br>&nbsp; &nbsp; &nbsp; поверить в присутствие объекта. Никакие ответы с кодами состояния 1xx
<br>&nbsp; &nbsp; &nbsp; (Информационные), 204 (Нет содержимого, No Content), и 304 (Не
<br>&nbsp; &nbsp; &nbsp; модифицирован, Not Modified) НЕ ДОЛЖНЫ содержать тела сообщения
<br>&nbsp; &nbsp; &nbsp; (message-body). Все другие ответы содержат тело сообщения, даже
<br>&nbsp; &nbsp; &nbsp; если оно имеет нулевую длину.
<br>
<br>
<a name="33"></a><center><h2>4.4 Длина сообщения.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Когда тело сообщения (message-body) присутствует в сообщении,
<br>&nbsp; &nbsp; &nbsp; длина этого тела определяется одним из следующих методов (в
<br>&nbsp; &nbsp; &nbsp; порядке старшинства):
<br>
<br>&nbsp; &nbsp; &nbsp; 1. Любое сообщение ответа, которое НЕ ДОЛЖНО включать тело
<br>&nbsp; &nbsp; &nbsp; сообщения (message-body) (например ответы с кодами состояния
<br>&nbsp; &nbsp; &nbsp; 1xx, 204, 304 и все ответы на запрос HEAD) всегда завершается
<br>&nbsp; &nbsp; &nbsp; пустой строкой после полей заголовка, независимо от полей
<br>&nbsp; &nbsp; &nbsp; заголовка объекта (entity-header fields), представленных в
<br>&nbsp; &nbsp; &nbsp; сообщении.
<br>
<br>&nbsp; &nbsp; &nbsp; 2. Если поле заголовка Transfer-Encoding (раздел 14.40)
<br>&nbsp; &nbsp; &nbsp; присутствует и указывает на применение кодирования передачи
<br>&nbsp; &nbsp; &nbsp; "chunked", то длина определяется кодированием по кускам
<br>&nbsp; &nbsp; &nbsp; (chunked encoding) (раздел 3.6).
<br>
<br>&nbsp; &nbsp; &nbsp; 3. Если поле заголовка Content-Length (раздел 14.14) присутствует,
<br>&nbsp; &nbsp; &nbsp; то его значение представляет длину тела сообщения
<br>&nbsp; &nbsp; &nbsp; (message-body) в байтах.
<br>
<br>&nbsp; &nbsp; &nbsp; 4. Если сообщение использует медиа тип "multipart/byteranges",
<br>&nbsp; &nbsp; &nbsp; который саморазграничен, то он и определяет длину. Этот медиа
<br>&nbsp; &nbsp; &nbsp; тип НЕ ДОЛЖЕН использоваться, если отправитель не знает, что
<br>&nbsp; &nbsp; &nbsp; получатель может его обработать; присутствие в запросе
<br>&nbsp; &nbsp; &nbsp; заголовка Range с несколькими спецификаторами диапазонов байтов
<br>&nbsp; &nbsp; &nbsp; (byte-range) подразумевает, что клиент может анализировать
<br>&nbsp; &nbsp; &nbsp; multipart/byteranges ответы.
<br>
<br>&nbsp; &nbsp; &nbsp; 5. Длина определяется закрытием соединения сервером. (Закрытие
<br>&nbsp; &nbsp; &nbsp; соединения не может использоваться для указания конца тела
<br>&nbsp; &nbsp; &nbsp; запроса, так как в этом случае у сервера не остается никакой
<br>&nbsp; &nbsp; &nbsp; возможности послать обратно ответ).
<br>
<br>&nbsp; &nbsp; &nbsp; Для совместимости с HTTP/1.0 приложениями HTTP/1.1 запросы,
<br>&nbsp; &nbsp; &nbsp; содержащие тело сообщения (message-body) ДОЛЖНЫ включать
<br>&nbsp; &nbsp; &nbsp; допустимое поле заголовка Content-Length, если не известно, что
<br>&nbsp; &nbsp; &nbsp; сервер является HTTP/1.1 совместимым. Если запрос содержит тело
<br>&nbsp; &nbsp; &nbsp; сообщения (message-body), и Content-Length не указано, серверу
<br>&nbsp; &nbsp; &nbsp; СЛЕДУЕТ послать ответ с кодом состояния 400 (Испорченный Запрос,
<br>&nbsp; &nbsp; &nbsp; Bad Request), если он не может определить длину сообщения, или
<br>&nbsp; &nbsp; &nbsp; с кодом состояния 411 (Требуется длина, Length Required), если он
<br>&nbsp; &nbsp; &nbsp; настаивает на получении Content-Length.
<br>
<br>&nbsp; &nbsp; &nbsp; Все HTTP/1.1 приложения, которые получают объекты, ДОЛЖНЫ понимать
<br>&nbsp; &nbsp; &nbsp; кодирование передачи типа "chunked" (раздел 3.6), таким образом
<br>&nbsp; &nbsp; &nbsp; разрешается использование данного механизма для таких сообщений,
<br>&nbsp; &nbsp; &nbsp; длина которых не может быть определена заранее.
<br>
<br>&nbsp; &nbsp; &nbsp; Сообщения НЕ ДОЛЖНЫ одновременно включать и поле заголовка
<br>&nbsp; &nbsp; &nbsp; Content-Length и применять кодирование передачи типа "chunked".
<br>&nbsp; &nbsp; &nbsp; Если поступило сообщение с полем Content-Length и закодированное
<br>&nbsp; &nbsp; &nbsp; с применением кодирования передачи "chunked", то поле
<br>&nbsp; &nbsp; &nbsp; Content-Length ДОЛЖНО игнорироваться.
<br>
<br>&nbsp; &nbsp; &nbsp; Если поле Content-Length присутствует в сообщении, которое
<br>&nbsp; &nbsp; &nbsp; допускает наличие тела сообщения (message-body), то значение поля
<br>&nbsp; &nbsp; &nbsp; ДОЛЖНО точно соответствовать числу октетов в теле сообщения.
<br>&nbsp; &nbsp; &nbsp; HTTP/1.1 агенты пользователя ДОЛЖНЫ информировать пользователя в
<br>&nbsp; &nbsp; &nbsp; случае получения и обнаружения недопустимой длины.
<br>
<br>
<a name="34"></a><center><h2>4.5 Общие поля заголовка.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Имеется несколько полей заголовка, которые применяются как для
<br>&nbsp; &nbsp; &nbsp; сообщений запросов, так и для сообщений ответов, но которые не
<br>&nbsp; &nbsp; &nbsp; применяются к передаваемому объекту. Эти поля заголовка
<br>&nbsp; &nbsp; &nbsp; применяются только к передаваемому сообщению.
<br>
<br>&nbsp; &nbsp; &nbsp; general-header = Cache-Control            ; Раздел 14.9
<br>&nbsp; &nbsp; &nbsp; | Connection               ; Раздел 14.10
<br>&nbsp; &nbsp; &nbsp; | Date                     ; Раздел 14.19
<br>&nbsp; &nbsp; &nbsp; | Pragma                   ; Раздел 14.32
<br>&nbsp; &nbsp; &nbsp; | Transfer-Encoding        ; Раздел 14.40
<br>&nbsp; &nbsp; &nbsp; | Upgrade                  ; Раздел 14.41
<br>&nbsp; &nbsp; &nbsp; | Via                      ; Раздел 14.44
<br>
<br>&nbsp; &nbsp; &nbsp; Имена общих полей заголовка (general-header fields) могут быть
<br>&nbsp; &nbsp; &nbsp; надежно расширены только в сочетании с изменением версии протокола.
<br>&nbsp; &nbsp; &nbsp; Однако, новые или экспериментальные поля заголовка могут получить
<br>&nbsp; &nbsp; &nbsp; семантику общих полей заголовка (general-header fields), если все
<br>&nbsp; &nbsp; &nbsp; стороны соединения распознают их как общие поля заголовка.
<br>&nbsp; &nbsp; &nbsp; Нераспознанные поля заголовка обрабатываются как поля заголовка
<br>&nbsp; &nbsp; &nbsp; объекта (entity-header).
<br>
<br>
<a name="35"></a><center><h2>5 Запрос (Request).</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Сообщение запроса от клиента к серверу  содержит в первой строке:
<br>&nbsp; &nbsp; &nbsp; метод, который нужно применить к ресурсу, идентификатор ресурса
<br>&nbsp; &nbsp; &nbsp; и используемую версию протокола.
<br>
<br>&nbsp; &nbsp; &nbsp; Request       = Request-Line              ; Раздел 5.1
<br>&nbsp; &nbsp; &nbsp; *( general-header         ; Раздел 4.5
<br>&nbsp; &nbsp; &nbsp; | request-header         ; Раздел 5.3
<br>&nbsp; &nbsp; &nbsp; | entity-header )        ; Раздел 7.1
<br>&nbsp; &nbsp; &nbsp; CRLF
<br>&nbsp; &nbsp; &nbsp; [ message-body ]          ; Раздел 7.2
<br>
<br>
<a name="36"></a><center><h2>5.1 Строка запроса (Request-Line).</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Строка запроса (Request-Line) начинается с лексемы метода, затем
<br>&nbsp; &nbsp; &nbsp; следует запрашиваемый URI (Request-URI), версия протокола и CRLF.
<br>&nbsp; &nbsp; &nbsp; Эти элементы разделяются SP. В строке запроса (Request-Line) не
<br>&nbsp; &nbsp; &nbsp; допустимы CR и LF, исключение составляет конечная
<br>&nbsp; &nbsp; &nbsp; последовательность CRLF.
<br>
<br>&nbsp; &nbsp; &nbsp; Request-Line   = Method SP Request-URI SP HTTP-Version CRLF
<br>
<br>
<a name="37"></a><center><h2>5.1.1 Метод (Method).</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Лексема метода указывает метод, который нужно применить к ресурсу,
<br>&nbsp; &nbsp; &nbsp; идентифицированному запрашиваемым URI (Request-URI). Метод
<br>&nbsp; &nbsp; &nbsp; чувствителен к регистру.
<br>
<br>&nbsp; &nbsp; &nbsp; Method         = "OPTIONS"                ; Раздел 9.2
<br>&nbsp; &nbsp; &nbsp; | "GET"                    ; Раздел 9.3
<br>&nbsp; &nbsp; &nbsp; | "HEAD"                   ; Раздел 9.4
<br>&nbsp; &nbsp; &nbsp; | "POST"                   ; Раздел 9.5
<br>&nbsp; &nbsp; &nbsp; | "PUT"                    ; Раздел 9.6
<br>&nbsp; &nbsp; &nbsp; | "DELETE"                 ; Раздел 9.7
<br>&nbsp; &nbsp; &nbsp; | "TRACE"                  ; Раздел 9.8
<br>&nbsp; &nbsp; &nbsp; | extension-method
<br>
<br>&nbsp; &nbsp; &nbsp; extension-method = token
<br>
<br>&nbsp; &nbsp; &nbsp; Список методов, применимых к ресурсу, может быть указан в поле
<br>&nbsp; &nbsp; &nbsp; заголовка Allow (раздел 14.7). Возврашаемый код состояния ответа
<br>&nbsp; &nbsp; &nbsp; всегда сообщает клиенту, допустим ли метод для ресурса в настоящее
<br>&nbsp; &nbsp; &nbsp; время, так как набор допустимых методов может изменяться
<br>&nbsp; &nbsp; &nbsp; динамически. Серверам СЛЕДУЕТ возвратить код состояния 405 (Метод
<br>&nbsp; &nbsp; &nbsp; не дозволен, Method Not Allowed), если метод известен серверу, но
<br>&nbsp; &nbsp; &nbsp; не применим для запрошенного ресурса, и 501 (Не реализовано, Not
<br>&nbsp; &nbsp; &nbsp; Implemented), если метод не распознан или не реализован сервером.
<br>&nbsp; &nbsp; &nbsp; Список методов, известных серверу, может быть указан в поле
<br>&nbsp; &nbsp; &nbsp; заголовка ответа Public (раздел 14.35).
<br>
<br>&nbsp; &nbsp; &nbsp; Методы GET и HEAD ДОЛЖНЫ поддерживаться всеми универсальными
<br>&nbsp; &nbsp; &nbsp; (general-purpose) серверами. Остальные методы опциональны; однако,
<br>&nbsp; &nbsp; &nbsp; если вышеупомянутые методы реализованы, то они ДОЛЖНЫ иметь
<br>&nbsp; &nbsp; &nbsp; семантику, описанную в разделе 9.
<br>
<br>
<a name="38"></a><center><h2>5.1.2 Запрашиваемый URI (Request-URI).</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Запрашиваемый URI (Request-URI) - это Единообразный Идентификатор
<br>&nbsp; &nbsp; &nbsp; Ресурса (URL, раздел 3.2), который идентифицирует ресурс запроса.
<br>
<br>&nbsp; &nbsp; &nbsp; Request-URI    = "*" | absoluteURI | abs_path
<br>
<br>&nbsp; &nbsp; &nbsp; Три опции для запрашиваемого URI (Request-URI) зависят от
<br>&nbsp; &nbsp; &nbsp; характера запроса. Звездочка "*" означает, что запрос обращается
<br>&nbsp; &nbsp; &nbsp; не к специфическому ресурсу, а к серверу непосредственно, и
<br>&nbsp; &nbsp; &nbsp; допускается только в том случае, когда используемый метод не
<br>&nbsp; &nbsp; &nbsp; обязательно обращается к ресурсу.
<br>&nbsp; &nbsp; &nbsp; В качестве примера:
<br>
<br>&nbsp; &nbsp; &nbsp; OPTIONS * HTTP/1.1
<br>
<br>&nbsp; &nbsp; &nbsp; absoluteURI необходим, когда запрос производится через
<br>&nbsp; &nbsp; &nbsp; прокси-сервер. Прокси-сервер перенаправляет запрос на сервер или
<br>&nbsp; &nbsp; &nbsp; обслуживает его, пользуясь кэшем, и возвращает ответ. Обратите
<br>&nbsp; &nbsp; &nbsp; внимание, что прокси-сервер МОЖЕТ переслать запрос другому
<br>&nbsp; &nbsp; &nbsp; прокси-серверу или непосредственно серверу, определенному
<br>&nbsp; &nbsp; &nbsp; absoluteURI. Чтобы избежать зацикливания запроса прокси-сервер
<br>&nbsp; &nbsp; &nbsp; ДОЛЖЕН быть способен распознавать все имена сервера, включая любые
<br>&nbsp; &nbsp; &nbsp; псевдонимы, локальные разновидности, и числовые IP адреса.
<br>&nbsp; &nbsp; &nbsp; Request-Line может быть, например, таким:
<br>
<br>&nbsp; &nbsp; &nbsp; GET http://www.w3.org/pub/WWW/TheProject.html HTTP/1.1
<br>
<br>&nbsp; &nbsp; &nbsp; Чтобы обеспечить переход к absoluteURI во всех запросах в будущих
<br>&nbsp; &nbsp; &nbsp; версиях HTTP, все HTTP/1.1 серверы ДОЛЖНЫ принимать absoluteURI
<br>&nbsp; &nbsp; &nbsp; в запросах, хотя HTTP/1.1 клиенты будут генерировать их только в
<br>&nbsp; &nbsp; &nbsp; запросах к прокси-серверам.
<br>
<br>&nbsp; &nbsp; &nbsp; Наиболее общая форма Request-URI - та, которая используется для
<br>&nbsp; &nbsp; &nbsp; идентификации ресурса на первоначальном сервере или шлюзе. В этом
<br>&nbsp; &nbsp; &nbsp; случае абсолютный путь URI (смотрите раздел 3.2.1, abs_path)
<br>&nbsp; &nbsp; &nbsp; ДОЛЖЕН быть передан как Request-URI, а сетевое расположение URI
<br>&nbsp; &nbsp; &nbsp; (net_loc) ДОЛЖНО быть передано в поле заголовка Host. Для
<br>&nbsp; &nbsp; &nbsp; последнего примера клиент, желающий получить ресурс
<br>&nbsp; &nbsp; &nbsp; непосредственно с первоначального сервера должен создать TCP
<br>&nbsp; &nbsp; &nbsp; соединение на 80 порт хоста "www.w3.org" и послать строки:
<br>
<br>&nbsp; &nbsp; &nbsp; GET /pub/WWW/TheProject.html HTTP/1.1
<br>&nbsp; &nbsp; &nbsp; Host: www.w3.org
<br>
<br>&nbsp; &nbsp; &nbsp; и далее остаток запроса. Обратите внимание, что абсолютный путь не
<br>&nbsp; &nbsp; &nbsp; может быть пустым; если оригинальный URI пуст, то он ДОЛЖЕН
<br>&nbsp; &nbsp; &nbsp; запрашиваться как "/" (корневой каталог сервера).
<br>
<br>&nbsp; &nbsp; &nbsp; Если прокси-сервер получает запрос без пути в Request-URI, и метод
<br>&nbsp; &nbsp; &nbsp; запроса допускает форму запроса "*", то последний прокси-сервер в
<br>&nbsp; &nbsp; &nbsp; цепочке запросов ДОЛЖЕН передать запрос, в котором Request-URI
<br>&nbsp; &nbsp; &nbsp; равен "*". Например запрос
<br>
<br>&nbsp; &nbsp; &nbsp; OPTIONS http://www.ics.uci.edu:8001 HTTP/1.1
<br>
<br>&nbsp; &nbsp; &nbsp; был бы передан прокси-сервером в виде
<br>
<br>&nbsp; &nbsp; &nbsp; OPTIONS * HTTP/1.1
<br>&nbsp; &nbsp; &nbsp; Host: www.ics.uci.edu:8001
<br>
<br>&nbsp; &nbsp; &nbsp; после соединения с портом 8001 хоста "www.ics.uci.edu".
<br>
<br>&nbsp; &nbsp; &nbsp; Request-URI передается в формате, определенном в разделе 3.2.1.
<br>&nbsp; &nbsp; &nbsp; Первоначальный сервер ДОЛЖЕН декодировать Request-URI, чтобы
<br>&nbsp; &nbsp; &nbsp; правильно интерпретировать запрос. Серверам СЛЕДУЕТ отвечать на
<br>&nbsp; &nbsp; &nbsp; недопустимые Request-URI соответствующим кодом состояния.
<br>
<br>&nbsp; &nbsp; &nbsp; В запросах, которые передаются далее, прокси-сервера никогда НЕ
<br>&nbsp; &nbsp; &nbsp; ДОЛЖНЫ перезаписывать часть "abs_path" запрашиваемого URI
<br>&nbsp; &nbsp; &nbsp; (Request-URI), за исключением случая, отмеченного выше, когда
<br>&nbsp; &nbsp; &nbsp; пустой abs_path заменяется на "*", независимо от внутренней
<br>&nbsp; &nbsp; &nbsp; реализации прокси-сервера.
<br>
<br>&nbsp; &nbsp; &nbsp; Обратите внимание: правило "ничто не перезаписывать"
<br>&nbsp; &nbsp; &nbsp; предохраняет прокси-сервера от изменения значения запроса,
<br>&nbsp; &nbsp; &nbsp; в котором первоначальный сервер неправильно использует не
<br>&nbsp; &nbsp; &nbsp; зарезервированные символы URL для своих целей. Реализаторам
<br>&nbsp; &nbsp; &nbsp; следует знать, что некоторые до-HTTP/1.1 прокси-сервера, как
<br>&nbsp; &nbsp; &nbsp; известно, перезаписывали Request-URI.
<br>
<br>
<a name="39"></a><center><h2>5.2 Ресурс, идентифицируемый запросом.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Первоначальные HTTP/1.1 сервера ДОЛЖНЫ учитывать, что точный
<br>&nbsp; &nbsp; &nbsp; ресурс, идентифицированный интернет-запросом определяется
<br>&nbsp; &nbsp; &nbsp; исследованием как Request-URI, так и поля заголовка Host.
<br>
<br>&nbsp; &nbsp; &nbsp; Первоначальный сервер, который не позволяет ресурсам отличаться по
<br>&nbsp; &nbsp; &nbsp; запрошенному хосту (host), МОЖЕТ игнорировать значение поля
<br>&nbsp; &nbsp; &nbsp; заголовка Host. (Но смотрите раздел 19.5.1 для других требований
<br>&nbsp; &nbsp; &nbsp; по поддержке Host в HTTP/1.1).
<br>
<br>&nbsp; &nbsp; &nbsp; Первоначальный сервер, который различает ресурсы, основанные на
<br>&nbsp; &nbsp; &nbsp; запрошенном хосте (иногда называемые виртуальными хостами или
<br>&nbsp; &nbsp; &nbsp; vanity hostnames) ДОЛЖЕН использовать следующие правила для
<br>&nbsp; &nbsp; &nbsp; определения запрошенного в HTTP/1.1 запросе ресурса:
<br>
<br>&nbsp; &nbsp; &nbsp; 1. Если Request-URI - это absoluteURI, то хост - это часть
<br>&nbsp; &nbsp; &nbsp; Request-URI. Любое значение поля заголовка Host в запросе
<br>&nbsp; &nbsp; &nbsp; ДОЛЖНО игнорироваться.
<br>
<br>&nbsp; &nbsp; &nbsp; 2. Если Request-URI - не absoluteURI, а запрос содержит поле
<br>&nbsp; &nbsp; &nbsp; заголовка Host, то хост определяется значением поля
<br>&nbsp; &nbsp; &nbsp; заголовка Host.
<br>
<br>&nbsp; &nbsp; &nbsp; 3. Если хоста, определенного правилами 1 или 2 не существует на
<br>&nbsp; &nbsp; &nbsp; сервере, код состояния ответа ДОЛЖЕН быть 400 (Испорченный
<br>&nbsp; &nbsp; &nbsp; Запрос, Bad Request).
<br>
<br>&nbsp; &nbsp; &nbsp; Получатели HTTP/1.0 запроса, в котором недостает поля заголовка
<br>&nbsp; &nbsp; &nbsp; Host, МОГУТ пытаться использовать эвристику (например, исследовать
<br>&nbsp; &nbsp; &nbsp; путь в URI на предмет уникальности на каком-либо из хостов) чтобы
<br>&nbsp; &nbsp; &nbsp; определить какой точно ресурс запрашивается.
<br>
<br>
<a name="40"></a><center><h2>5.3 Поля заголовка запроса.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Поля заголовка запроса позволяют клиенту передавать серверу
<br>&nbsp; &nbsp; &nbsp; дополнительную информацию о запросе и о самом клиенте. Эти поля
<br>&nbsp; &nbsp; &nbsp; действуют как модификаторы запроса с семантикой, эквивалентной
<br>&nbsp; &nbsp; &nbsp; параметрам вызова методов в языках программирования.
<br>
<br>&nbsp; &nbsp; &nbsp; request-header = Accept                   ; Раздел 14.1
<br>&nbsp; &nbsp; &nbsp; | Accept-Charset           ; Раздел 14.2
<br>&nbsp; &nbsp; &nbsp; | Accept-Encoding          ; Раздел 14.3
<br>&nbsp; &nbsp; &nbsp; | Accept-Language          ; Раздел 14.4
<br>&nbsp; &nbsp; &nbsp; | Authorization            ; Раздел 14.8
<br>&nbsp; &nbsp; &nbsp; | From                     ; Раздел 14.22
<br>&nbsp; &nbsp; &nbsp; | Host                     ; Раздел 14.23
<br>&nbsp; &nbsp; &nbsp; | If-Modified-Since        ; Раздел 14.24
<br>&nbsp; &nbsp; &nbsp; | If-Match                 ; Раздел 14.25
<br>&nbsp; &nbsp; &nbsp; | If-None-Match            ; Раздел 14.26
<br>&nbsp; &nbsp; &nbsp; | If-Range                 ; Раздел 14.27
<br>&nbsp; &nbsp; &nbsp; | If-Unmodified-Since      ; Раздел 14.28
<br>&nbsp; &nbsp; &nbsp; | Max-Forwards             ; Раздел 14.31
<br>&nbsp; &nbsp; &nbsp; | Proxy-Authorization      ; Раздел 14.34
<br>&nbsp; &nbsp; &nbsp; | Range                    ; Раздел 14.36
<br>&nbsp; &nbsp; &nbsp; | Referer                  ; Раздел 14.37
<br>&nbsp; &nbsp; &nbsp; | User-Agent               ; Раздел 14.42
<br>
<br>&nbsp; &nbsp; &nbsp; Имена полей заголовка запроса (Request-header) могут быть надежно
<br>&nbsp; &nbsp; &nbsp; расширены только в сочетании с изменением версии протокола.
<br>&nbsp; &nbsp; &nbsp; Однако, новые или экспериментальные поля заголовка могут получить
<br>&nbsp; &nbsp; &nbsp; семантику полей заголовка запроса (Request-header), если все
<br>&nbsp; &nbsp; &nbsp; стороны соединения распознают их как поля заголовка запроса
<br>&nbsp; &nbsp; &nbsp; (Request-header). Нераспознанные поля заголовка обрабатываются
<br>&nbsp; &nbsp; &nbsp; как поля заголовка объекта (entity-header).
<br>
<br>
<a name="41"></a><center><h2>6 Ответ (Response).</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; После получения и интерпретации сообщения запроса, сервер отвечает
<br>&nbsp; &nbsp; &nbsp; сообщением  HTTP ответа.
<br>
<br>&nbsp; &nbsp; &nbsp; Response      = Status-Line               ; Раздел 6.1
<br>&nbsp; &nbsp; &nbsp; *( general-header         ; Раздел 4.5
<br>&nbsp; &nbsp; &nbsp; | response-header        ; Раздел 6.2
<br>&nbsp; &nbsp; &nbsp; | entity-header )        ; Раздел 7.1
<br>&nbsp; &nbsp; &nbsp; CRLF
<br>&nbsp; &nbsp; &nbsp; [ message-body ]          ; Раздел 7.2
<br>
<br>
<a name="42"></a><center><h2>6.1 Строка состояния (Status-Line).</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Первая строка ответа - это строка состояния (Status-Line). Она
<br>&nbsp; &nbsp; &nbsp; состоит из версии протокола (HTTP-Version), числового кода
<br>&nbsp; &nbsp; &nbsp; состояния (Status-Code) и поясняющей фразы (Reason-Phrase),
<br>&nbsp; &nbsp; &nbsp; разделенных символами SP. CR и LF не допустимы в
<br>&nbsp; &nbsp; &nbsp; Status-Line, за исключением конечной последовательности CRLF.
<br>
<br>&nbsp; &nbsp; &nbsp; Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF
<br>
<br>
<a name="43"></a><center><h2>6.1.1 Код состояния и поясняющая фраза.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Элемент код состояния (Status-Code) - это целочисленный
<br>&nbsp; &nbsp; &nbsp; трехразрядный код результата понимания и удовлетворения запроса.
<br>&nbsp; &nbsp; &nbsp; Эти коды полностью определены в разделе 10. Поясняющая фраза
<br>&nbsp; &nbsp; &nbsp; (Reason-Phrase) предназначена для короткого текстового описания
<br>&nbsp; &nbsp; &nbsp; кода состояния. Код состояния (Status-Code) предназначен для
<br>&nbsp; &nbsp; &nbsp; использования автоматами, а поясняющая фраза предназначена для
<br>&nbsp; &nbsp; &nbsp; живых пользователей. От клиента не требуется исследовать или
<br>&nbsp; &nbsp; &nbsp; отображать поясняющую фразу (Reason-Phrase).
<br>
<br>&nbsp; &nbsp; &nbsp; Первая цифра кода состояния определяет класс ответа. Последние две
<br>&nbsp; &nbsp; &nbsp; цифры не имеют определенной роли в классификации. Имеется 5
<br>&nbsp; &nbsp; &nbsp; значений первой цифры:
<br>
<br>&nbsp; &nbsp; &nbsp; o  1xx: Информационные коды - запрос получен, продолжается
<br>&nbsp; &nbsp; &nbsp; обработка.
<br>
<br>&nbsp; &nbsp; &nbsp; o  2xx: Успешные коды - действие было успешно получено, понято
<br>&nbsp; &nbsp; &nbsp; и обработано.
<br>
<br>&nbsp; &nbsp; &nbsp; o  3xx: Коды перенаправления - для выполнения запроса должны
<br>&nbsp; &nbsp; &nbsp; быть предприняты дальнейшие действия.
<br>
<br>&nbsp; &nbsp; &nbsp; o  4xx: Коды ошибок клиента - запрос имеет плохой синтаксис
<br>&nbsp; &nbsp; &nbsp; или не может быть выполнен.
<br>
<br>&nbsp; &nbsp; &nbsp; o  5xx: Коды ошибок сервера - сервер не в состоянии выполнить
<br>&nbsp; &nbsp; &nbsp; допустимый запрос.
<br>
<br>&nbsp; &nbsp; &nbsp; Конкретные значения числовых кодов состояния, определенных в
<br>&nbsp; &nbsp; &nbsp; HTTP/1.1, и примерный набор соответствующих поясняющих фраз
<br>&nbsp; &nbsp; &nbsp; (Reason-Phrase) приводятся ниже. Поясняющие фразы (Reason-Phrase),
<br>&nbsp; &nbsp; &nbsp; перечисленные здесь являются рекомендуемыми, но могут быть
<br>&nbsp; &nbsp; &nbsp; заменены на эквивалентные без воздействия на протокол.
<br>
<br>&nbsp; &nbsp; &nbsp; Status-Code    = "100"   ; Продолжать, Continue
<br>&nbsp; &nbsp; &nbsp; | "101"   ; Переключение протоколов,
<br>&nbsp; &nbsp; &nbsp; ; Switching Protocols
<br>&nbsp; &nbsp; &nbsp; | "200"   ; OK
<br>&nbsp; &nbsp; &nbsp; | "201"   ; Создан, Created
<br>&nbsp; &nbsp; &nbsp; | "202"   ; Принято, Accepted
<br>&nbsp; &nbsp; &nbsp; | "203"   ; Не авторская информация,
<br>&nbsp; &nbsp; &nbsp; ; Non-Authoritative Information
<br>&nbsp; &nbsp; &nbsp; | "204"   ; Нет содержимого, No Content
<br>&nbsp; &nbsp; &nbsp; | "205"   ; Сбросить содержимое, Reset
<br>&nbsp; &nbsp; &nbsp; ; Content
<br>&nbsp; &nbsp; &nbsp; | "206"   ; Частичное содержимое, Partial
<br>&nbsp; &nbsp; &nbsp; ; Content
<br>&nbsp; &nbsp; &nbsp; | "300"   ; Множественный выбор, Multiple
<br>&nbsp; &nbsp; &nbsp; ; Choices
<br>&nbsp; &nbsp; &nbsp; | "301"   ; Постоянно перенесен, Moved
<br>&nbsp; &nbsp; &nbsp; ; Permanently
<br>&nbsp; &nbsp; &nbsp; | "302"   ; Временно перемещен, Moved
<br>&nbsp; &nbsp; &nbsp; ; Temporarily
<br>&nbsp; &nbsp; &nbsp; | "303"   ; Смотреть другой, See Other
<br>&nbsp; &nbsp; &nbsp; | "304"   ; Не модифицирован, Not Modified
<br>&nbsp; &nbsp; &nbsp; | "305"   ; Используйте прокси-сервер, Use
<br>&nbsp; &nbsp; &nbsp; ; Proxy
<br>&nbsp; &nbsp; &nbsp; | "400"   ; Испорченный Запрос, Bad Request
<br>&nbsp; &nbsp; &nbsp; | "401"   ; Несанкционированно, Unauthorized
<br>&nbsp; &nbsp; &nbsp; | "402"   ; Требуется оплата, Payment
<br>&nbsp; &nbsp; &nbsp; ; Required
<br>&nbsp; &nbsp; &nbsp; | "403"   ; Запрещено, Forbidden
<br>&nbsp; &nbsp; &nbsp; | "404"   ; Не найден, Not Found
<br>&nbsp; &nbsp; &nbsp; | "405"   ; Метод не дозволен, Method Not
<br>&nbsp; &nbsp; &nbsp; ; Allowed
<br>&nbsp; &nbsp; &nbsp; | "406"   ; Не приемлем, Not Acceptable
<br>&nbsp; &nbsp; &nbsp; | "407"   ; Требуется установление
<br>&nbsp; &nbsp; &nbsp; ; подлинности через прокси-сервер,
<br>&nbsp; &nbsp; &nbsp; ; Proxy Authentication Required
<br>&nbsp; &nbsp; &nbsp; | "408"   ; Истекло время ожидания запроса,
<br>&nbsp; &nbsp; &nbsp; ; Request Timeout
<br>&nbsp; &nbsp; &nbsp; | "409"   ; Конфликт, Conflict
<br>&nbsp; &nbsp; &nbsp; | "410"   ; Удален, Gone
<br>&nbsp; &nbsp; &nbsp; | "411"   ; Требуется длина, Length Required
<br>&nbsp; &nbsp; &nbsp; | "412"   ; Предусловие неверно,
<br>&nbsp; &nbsp; &nbsp; ; Precondition Failed
<br>&nbsp; &nbsp; &nbsp; | "413"   ; Объект запроса слишком большой,
<br>&nbsp; &nbsp; &nbsp; ; Request Entity Too Large
<br>&nbsp; &nbsp; &nbsp; | "414"   ; URI запроса слишком длинный,
<br>&nbsp; &nbsp; &nbsp; ; Request-URI Too Long
<br>&nbsp; &nbsp; &nbsp; | "415"   ; Неподдерживаемый медиа тип,
<br>&nbsp; &nbsp; &nbsp; ; Unsupported Media Type
<br>&nbsp; &nbsp; &nbsp; | "500"   ; Внутренняя ошибка сервера,
<br>&nbsp; &nbsp; &nbsp; ; Internal Server Error
<br>&nbsp; &nbsp; &nbsp; | "501"   ; Не реализовано, Not Implemented
<br>&nbsp; &nbsp; &nbsp; | "502"   ; Ошибка шлюза, Bad Gateway
<br>&nbsp; &nbsp; &nbsp; | "503"   ; Сервис недоступен, Service
<br>&nbsp; &nbsp; &nbsp; ; Unavailable
<br>&nbsp; &nbsp; &nbsp; | "504"   ; Истекло время ожидания от шлюза,
<br>&nbsp; &nbsp; &nbsp; ; Gateway Timeout
<br>&nbsp; &nbsp; &nbsp; | "505"   ; Не поддерживаемая версия HTTP,
<br>&nbsp; &nbsp; &nbsp; ; HTTP Version Not Supported
<br>&nbsp; &nbsp; &nbsp; | extension-code
<br>
<br>&nbsp; &nbsp; &nbsp; extension-code = 3DIGIT
<br>
<br>&nbsp; &nbsp; &nbsp; Reason-Phrase  = *&lt;TEXT не включающий CR, LF&gt;
<br>
<br>&nbsp; &nbsp; &nbsp; Коды состояния HTTP расширяемы. HTTP приложениям не требуется
<br>&nbsp; &nbsp; &nbsp; понимать значение всех зарегистрированных кодов состояния, хотя
<br>&nbsp; &nbsp; &nbsp; такое понимание очень желательно. Однако, приложения ДОЛЖНЫ
<br>&nbsp; &nbsp; &nbsp; понимать класс любого кода состояния, который обозначается первой
<br>&nbsp; &nbsp; &nbsp; цифрой, и обрабатывать любой нераспознанный ответ как
<br>&nbsp; &nbsp; &nbsp; эквивалентный коду состояния x00 этого класса, за исключением тех
<br>&nbsp; &nbsp; &nbsp; случаев, когда нераспознанный ответ НЕ ДОЛЖЕН кэшироваться.
<br>&nbsp; &nbsp; &nbsp; Например, если клиентом получен и не был распознан код
<br>&nbsp; &nbsp; &nbsp; состояния 431, то он может безопасно считать, что в запросе что-то
<br>&nbsp; &nbsp; &nbsp; было неправильно и обрабатывать ответ, как если бы был получен код
<br>&nbsp; &nbsp; &nbsp; состояния 400. В таких случаях агентам пользователя СЛЕДУЕТ
<br>&nbsp; &nbsp; &nbsp; представить пользователю объект, возвращенный в ответе, так как
<br>&nbsp; &nbsp; &nbsp; этот объект, вероятно, включает читабельную для человека
<br>&nbsp; &nbsp; &nbsp; информацию, которая поясняет необычное состояние.
<br>
<br>
<a name="44"></a><center><h2>6.2 Поля заголовка ответа.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Поля заголовка ответа (response-header fields) позволяют серверу
<br>&nbsp; &nbsp; &nbsp; передавать дополнительную информацию, касающуюся ответа, которая
<br>&nbsp; &nbsp; &nbsp; не может быть помещена в строку состояния Status-Line. Эти поля
<br>&nbsp; &nbsp; &nbsp; заголовка дают информацию о сервере и о дальнейшем доступе к
<br>&nbsp; &nbsp; &nbsp; ресурсу, указанному этим Request-URI.
<br>
<br>&nbsp; &nbsp; &nbsp; response-header = Age                     ; Раздел 14.6
<br>&nbsp; &nbsp; &nbsp; | Location                ; Раздел 14.30
<br>&nbsp; &nbsp; &nbsp; | Proxy-Authenticate      ; Раздел 14.33
<br>&nbsp; &nbsp; &nbsp; | Public                  ; Раздел 14.35
<br>&nbsp; &nbsp; &nbsp; | Retry-After             ; Раздел 14.38
<br>&nbsp; &nbsp; &nbsp; | Server                  ; Раздел 14.39
<br>&nbsp; &nbsp; &nbsp; | Vary                    ; Раздел 14.43
<br>&nbsp; &nbsp; &nbsp; | Warning                 ; Раздел 14.45
<br>&nbsp; &nbsp; &nbsp; | WWW-Authenticate        ; Раздел 14.46
<br>
<br>&nbsp; &nbsp; &nbsp; Имена полей заголовка ответа (Response-header) могут быть надежно
<br>&nbsp; &nbsp; &nbsp; расширены только в сочетании с изменением версии протокола.
<br>&nbsp; &nbsp; &nbsp; Однако, новые или экспериментальные поля заголовка могут получить
<br>&nbsp; &nbsp; &nbsp; семантику полей заголовка ответа (Response-header), если все
<br>&nbsp; &nbsp; &nbsp; стороны соединения распознают их как поля заголовка ответа
<br>&nbsp; &nbsp; &nbsp; (Response-header). Нераспознанные поля заголовка обрабатываются
<br>&nbsp; &nbsp; &nbsp; как поля заголовка объекта (entity-header).
<br>
<br>&nbsp; &nbsp; &nbsp; Множество имен полей заголовка ответа (Response-header) может быть
<br>&nbsp; &nbsp; &nbsp; надежно расширено только в комбинации с изменением версии протокола.
<br>&nbsp; &nbsp; &nbsp; Однако, новые или экспериментальные поля заголовка с семантикой
<br>&nbsp; &nbsp; &nbsp; полей заголовка ответа МОГУТ быть добавлены если все участники
<br>&nbsp; &nbsp; &nbsp; соединения распознают их как поля заголовка ответа. Нераспознанные
<br>&nbsp; &nbsp; &nbsp; поля заголовка обрабатываются как поля заголовка объекта.
<br>
<br>
<a name="45"></a><center><h2>7 Объект (Entity).</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Сообщения запросов и ответов МОГУТ передать объект, если иное не
<br>&nbsp; &nbsp; &nbsp; установлено методом запроса или кодом состояния ответа. Объект
<br>&nbsp; &nbsp; &nbsp; состоит из полей заголовка объекта (entity-header) и тела объекта
<br>&nbsp; &nbsp; &nbsp; (entity-body), хотя некоторые ответы могут включать только
<br>&nbsp; &nbsp; &nbsp; заголовки объекта (entity-headers).
<br>
<br>&nbsp; &nbsp; &nbsp; Этот раздел относится как к отправителю, так и к получателю, то
<br>&nbsp; &nbsp; &nbsp; есть к клиенту или серверу, в зависимости от того, кто посылает,
<br>&nbsp; &nbsp; &nbsp; а кто получает объект.
<br>
<br>
<a name="46"></a><center><h2>7.1 Поля заголовка объекта.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Поля заголовка объекта (Entity-header fields) определяют
<br>&nbsp; &nbsp; &nbsp; опциональную метаинформацию о теле объекта или, если тело не
<br>&nbsp; &nbsp; &nbsp; присутствует, относительно ресурса, идентифицированного запросом.
<br>
<br>&nbsp; &nbsp; &nbsp; entity-header  = Allow                    ; Раздел 14.7
<br>&nbsp; &nbsp; &nbsp; | Content-Base             ; Раздел 14.11
<br>&nbsp; &nbsp; &nbsp; | Content-Encoding         ; Раздел 14.12
<br>&nbsp; &nbsp; &nbsp; | Content-Language         ; Раздел 14.13
<br>&nbsp; &nbsp; &nbsp; | Content-Length           ; Раздел 14.14
<br>&nbsp; &nbsp; &nbsp; | Content-Location         ; Раздел 14.15
<br>&nbsp; &nbsp; &nbsp; | Content-MD5              ; Раздел 14.16
<br>&nbsp; &nbsp; &nbsp; | Content-Range            ; Раздел 14.17
<br>&nbsp; &nbsp; &nbsp; | Content-Type             ; Раздел 14.18
<br>&nbsp; &nbsp; &nbsp; | ETag                     ; Раздел 14.20
<br>&nbsp; &nbsp; &nbsp; | Expires                  ; Раздел 14.21
<br>&nbsp; &nbsp; &nbsp; | Last-Modified            ; Раздел 14.29
<br>&nbsp; &nbsp; &nbsp; | extension-header
<br>
<br>&nbsp; &nbsp; &nbsp; extension-header = message-header
<br>
<br>&nbsp; &nbsp; &nbsp; Механизм расширения полей заголовка позволяет вводить
<br>&nbsp; &nbsp; &nbsp; дополнительные поля заголовка объекта (entity-header fields) не
<br>&nbsp; &nbsp; &nbsp; изменяя протокол, но эти поля не могут считаться распознаваемыми
<br>&nbsp; &nbsp; &nbsp; получателем. Нераспознанные поля заголовка получателю СЛЕДУЕТ
<br>&nbsp; &nbsp; &nbsp; игнорировать, а прокси-серверу пересылать без изменений.
<br>
<br>
<a name="47"></a><center><h2>7.2 Тело объекта.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Тело объекта (если оно присутствует) посылается с HTTP запросом
<br>&nbsp; &nbsp; &nbsp; или ответом и имеет формат и кодирование, определяемое полями
<br>&nbsp; &nbsp; &nbsp; заголовка объекта (entity-header fields).
<br>
<br>&nbsp; &nbsp; &nbsp; entity-body    = *OCTET
<br>
<br>&nbsp; &nbsp; &nbsp; Тело объекта (entity-body) представлено в сообщении только тогда,
<br>&nbsp; &nbsp; &nbsp; когда присутствует тело сообщения (message-body), как описано в
<br>&nbsp; &nbsp; &nbsp; разделе 4.3. Тело объекта (entity-body) получается из тела
<br>&nbsp; &nbsp; &nbsp; сообщения (message-body), декодированием кодирования передачи,
<br>&nbsp; &nbsp; &nbsp; указанного в поле Transfer-Encoding, и которое может быть
<br>&nbsp; &nbsp; &nbsp; применено для гарантирования безопасной и правильной передачи
<br>&nbsp; &nbsp; &nbsp; сообщения.
<br>
<br>
<a name="48"></a><center><h2>7.2.1 Тип (Type).</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Когда тело объекта (entity-body) включено в сообщение, тип данных
<br>&nbsp; &nbsp; &nbsp; этого тела определяется полями заголовка Content-Type и
<br>&nbsp; &nbsp; &nbsp; Content-Encoding. Они определяют двухуровневую упорядоченную
<br>&nbsp; &nbsp; &nbsp; модель кодирования:
<br>
<br>&nbsp; &nbsp; &nbsp; entity-body := Content-Encoding( Content-Type( data ) )
<br>
<br>&nbsp; &nbsp; &nbsp; Тип содержимого (Content-Type) определяет медиа тип основных
<br>&nbsp; &nbsp; &nbsp; данных. Кодирование содержимого (Content-Encoding) может
<br>&nbsp; &nbsp; &nbsp; использоваться для указания любого дополнительного кодирования
<br>&nbsp; &nbsp; &nbsp; содержимого, примененного к данным (обычно с целью сжатия данных).
<br>&nbsp; &nbsp; &nbsp; Кодирование содержимого (Content-Encoding) является свойством
<br>&nbsp; &nbsp; &nbsp; запрошенного ресурса. По умолчанию никакого кодирования не задано.
<br>
<br>&nbsp; &nbsp; &nbsp; В любое HTTP/1.1 сообщение, содержащее тело объекта (entity-body)
<br>&nbsp; &nbsp; &nbsp; СЛЕДУЕТ включать поле заголовка Content-Type, определяющее медиа
<br>&nbsp; &nbsp; &nbsp; тип этого тела. В том и только в том случае, когда медиа тип не
<br>&nbsp; &nbsp; &nbsp; представлен полем Content-Type, получатель МОЖЕТ попытаться
<br>&nbsp; &nbsp; &nbsp; предположить медиа тип, проверяя содержимое и/или расширение
<br>&nbsp; &nbsp; &nbsp; (расширения) в имени URL, используемого для идентификации ресурса.
<br>&nbsp; &nbsp; &nbsp; Если медиа тип остался нераспознан, получателю СЛЕДУЕТ
<br>&nbsp; &nbsp; &nbsp; обрабатывать его как тип "application/octet-stream".
<br>
<br>
<a name="49"></a><center><h2>7.2.2 Длина (Length).</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Длина тела объекта (entity-body) - это длина тела сообщения
<br>&nbsp; &nbsp; &nbsp; (message-body), полученного после декодирования всех кодирований
<br>&nbsp; &nbsp; &nbsp; передачи. Раздел 4.4 определяет как вычисляется длина тела
<br>&nbsp; &nbsp; &nbsp; сообщения (message-body).
<br>
<br>
<a name="50"></a><center><h2>8 Соединения (Connections).</h2></center>
<br>
<a name="51"></a><center><h2>8.1 Постоянные соединения (Persistent Connections).</h2></center>
<br>
<a name="52"></a><center><h2>8.1.1 Цель.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; До постоянных соединений для запроса каждого URL устанавливалось
<br>&nbsp; &nbsp; &nbsp; отдельное TCP соединение, что увеличивало нагрузку на HTTP сервера
<br>&nbsp; &nbsp; &nbsp; и вызывало загрузку Интернета. Использование встроенных
<br>&nbsp; &nbsp; &nbsp; изображений и других связанных данных часто требует от клиента
<br>&nbsp; &nbsp; &nbsp; делать несколько запросов к одному серверу за короткий промежуток
<br>&nbsp; &nbsp; &nbsp; времени. Исследования проблем эффективности такого решения
<br>&nbsp; &nbsp; &nbsp; доступны в [30][27]; анализ и результаты реализации прототипа
<br>&nbsp; &nbsp; &nbsp; находятся в [26].
<br>
<br>&nbsp; &nbsp; &nbsp; Постоянные HTTP соединения имеют ряд преимуществ:
<br>
<br>&nbsp; &nbsp; &nbsp; o  Открытие и закрытие меньшего количества TCP соединений
<br>&nbsp; &nbsp; &nbsp; экономит время центрального процессора и память, используемую
<br>&nbsp; &nbsp; &nbsp; для управляющих блоков протокола TCP.
<br>
<br>&nbsp; &nbsp; &nbsp; o  HTTP запросы и ответы может быть конвейеризованы в
<br>&nbsp; &nbsp; &nbsp; соединении. Конвейерная обработка позволяет клиенту делать
<br>&nbsp; &nbsp; &nbsp; множество запросов не ожидая ответа на каждый, следовательно,
<br>&nbsp; &nbsp; &nbsp; одиночное TCP соединение, использование которого намного
<br>&nbsp; &nbsp; &nbsp; более эффективно, теряет меньше времени.
<br>
<br>&nbsp; &nbsp; &nbsp; o  Загрузка сети уменьшается с уменьшением числа пакетов,
<br>&nbsp; &nbsp; &nbsp; вызванных открытием TCP соединений, и, следовательно, дает
<br>&nbsp; &nbsp; &nbsp; протоколу TCP достаточное время для определения состояния
<br>&nbsp; &nbsp; &nbsp; загрузки сети.
<br>
<br>&nbsp; &nbsp; &nbsp; o  HTTP может развиваться более элегантно; так как ошибки могут
<br>&nbsp; &nbsp; &nbsp; сообщаться без закрытия TCP соединения в качестве штрафа.
<br>&nbsp; &nbsp; &nbsp; Клиенты, использующие будущие версии HTTP могли бы
<br>&nbsp; &nbsp; &nbsp; оптимистично пробовать новые возможности, но при связи со
<br>&nbsp; &nbsp; &nbsp; старым сервером, повторять запрос, используя старую
<br>&nbsp; &nbsp; &nbsp; семантику после сообщения об ошибке.
<br>
<br>&nbsp; &nbsp; &nbsp; HTTP реализациям СЛЕДУЕТ реализовывать постоянные соединения.
<br>
<br>
<a name="53"></a><center><h2>8.1.2 Общее описание.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Значительное отличие HTTP/1.1 от более ранних версий HTTP состоит
<br>&nbsp; &nbsp; &nbsp; в том, что постоянные соединения являются заданным по умолчанию
<br>&nbsp; &nbsp; &nbsp; поведением любого HTTP соединения. То есть если не обозначено
<br>&nbsp; &nbsp; &nbsp; иного, клиент может считать, что сервер поддержит постоянное
<br>&nbsp; &nbsp; &nbsp; соединение.
<br>
<br>&nbsp; &nbsp; &nbsp; Постоянные соединения обеспечивают механизм, согласно которому
<br>&nbsp; &nbsp; &nbsp; клиент и сервер могут сообщить о разрыве TCP соединения. Это
<br>&nbsp; &nbsp; &nbsp; сигнализируется при помощи использования поля заголовка
<br>&nbsp; &nbsp; &nbsp; Connection. При получении сообщения о разрыве соединения клиент
<br>&nbsp; &nbsp; &nbsp; НЕ ДОЛЖЕН посылать больше запросов по этому соединению.
<br>
<br>
<a name="54"></a><center><h2>8.1.2.1 Обсуждение (Negotiation).</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; HTTP/1.1 сервер МОЖЕТ считать, что HTTP/1.1 клиент не предполагает
<br>&nbsp; &nbsp; &nbsp; поддерживать постоянное соединение, если посланный в запросе
<br>&nbsp; &nbsp; &nbsp; заголовок Connection содержит лексему соединения
<br>&nbsp; &nbsp; &nbsp; (connection-token) "close". Если сервер решает закрыть соединение
<br>&nbsp; &nbsp; &nbsp; немедленно после посылки ответа, то ему СЛЕДУЕТ послать заголовок
<br>&nbsp; &nbsp; &nbsp; Connection, который содержит лексему соединения (connection-token)
<br>&nbsp; &nbsp; &nbsp; "close".
<br>
<br>&nbsp; &nbsp; &nbsp; HTTP/1.1 клиент МОЖЕТ ожидать, что соединение останется открытым,
<br>&nbsp; &nbsp; &nbsp; но должен решить оставлять ли его открытым на основании того,
<br>&nbsp; &nbsp; &nbsp; содержит ли ответ сервера заголовок Connection с лексемой
<br>&nbsp; &nbsp; &nbsp; соединения "close". В случае, если клиент не хочет поддерживать
<br>&nbsp; &nbsp; &nbsp; соединение для последующих запросов, ему СЛЕДУЕТ послать заголовок
<br>&nbsp; &nbsp; &nbsp; Connection, содержащий лексему соединения "close".
<br>
<br>&nbsp; &nbsp; &nbsp; Если клиент или сервер посылает лексему закрытия соединения
<br>&nbsp; &nbsp; &nbsp; "close" в заголовке Connection, то запрос становится последним
<br>&nbsp; &nbsp; &nbsp; в соединении.
<br>
<br>&nbsp; &nbsp; &nbsp; Клиентам и серверам НЕ СЛЕДУЕТ считать, что постоянное соединение
<br>&nbsp; &nbsp; &nbsp; поддерживается HTTP версиями, меньшими чем 1.1, если это не
<br>&nbsp; &nbsp; &nbsp; указано явно. Смотрите раздел 19.7.1 с более подробной информацией
<br>&nbsp; &nbsp; &nbsp; о обратной совместимости с HTTP/1.0 клиентами.
<br>
<br>&nbsp; &nbsp; &nbsp; Чтобы соединение оставалось постоянным, все сообщения,
<br>&nbsp; &nbsp; &nbsp; передаваемые по нему должны иметь самоопределенную (self-defined)
<br>&nbsp; &nbsp; &nbsp; длину сообщения (то есть, не определяемую закрытием соединения),
<br>&nbsp; &nbsp; &nbsp; как описано в разделе 4.4.
<br>
<br>
<a name="55"></a><center><h2>8.1.2.2 Конвейерная обработка (Pipelining).</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Клиент, который поддерживает постоянные соединения МОЖЕТ
<br>&nbsp; &nbsp; &nbsp; "произвести конвейерную обработку" запросов (то есть, посылать
<br>&nbsp; &nbsp; &nbsp; несколько запросов не ожидая ответа на каждый). Сервер ДОЛЖЕН
<br>&nbsp; &nbsp; &nbsp; послать ответы на эти запросы в том же самом порядке, в каком
<br>&nbsp; &nbsp; &nbsp; были получены запросы.
<br>
<br>&nbsp; &nbsp; &nbsp; Клиенты, которые поддерживают постоянные соединения и производят
<br>&nbsp; &nbsp; &nbsp; конвейерную обработку немедленно после установления соединения,
<br>&nbsp; &nbsp; &nbsp; ДОЛЖНЫ быть готовы повторить соединение, если первая попытка
<br>&nbsp; &nbsp; &nbsp; конвейерной обработки дала сбой. Если клиент делает такой повтор,
<br>&nbsp; &nbsp; &nbsp; он НЕ ДОЛЖЕН производить конвейерную обработку прежде, чем узнает,
<br>&nbsp; &nbsp; &nbsp; что соединение постоянное. Клиенты ДОЛЖНЫ также быть готовы снова
<br>&nbsp; &nbsp; &nbsp; послать запросы, если сервер закрывает соединение перед посылкой
<br>&nbsp; &nbsp; &nbsp; всех соответствующих ответов.
<br>
<br>
<a name="56"></a><center><h2>8.1.3 Прокси-сервера (Proxy Servers).</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Очень важно, чтобы прокси-сервера правильно выполняли свойства
<br>&nbsp; &nbsp; &nbsp; полей заголовка Connection, как определено в 14.2.1.
<br>
<br>&nbsp; &nbsp; &nbsp; Прокси-сервер ДОЛЖЕН сообщать о постоянных соединениях отдельно
<br>&nbsp; &nbsp; &nbsp; своим клиентам и отдельно первоначальным серверам (или другим
<br>&nbsp; &nbsp; &nbsp; прокси-серверам), которые с ним соединены. Каждое постоянное
<br>&nbsp; &nbsp; &nbsp; соединение применяется только к одной транспортной связи.
<br>
<br>&nbsp; &nbsp; &nbsp; Прокси-сервер НЕ ДОЛЖЕН устанавливать постоянное соединение с
<br>&nbsp; &nbsp; &nbsp; HTTP/1.0 клиентом.
<br>
<br>
<a name="57"></a><center><h2>8.1.4 Практические cоглашения (Practical Considerations).</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Сервера обычно имеют некоторое значение времени ожидания, после
<br>&nbsp; &nbsp; &nbsp; которого они не поддерживают неактивное соединение. Прокси-сервера
<br>&nbsp; &nbsp; &nbsp; могут делать это значение более высоким, так как, вероятно, клиент
<br>&nbsp; &nbsp; &nbsp; сделает большее количество соединений через этот же сервер.
<br>&nbsp; &nbsp; &nbsp; Использование постоянных соединений не вводит никаких ограничений
<br>&nbsp; &nbsp; &nbsp; на продолжительность этого времени ожидания как для клиента, так
<br>&nbsp; &nbsp; &nbsp; и для сервера.
<br>
<br>&nbsp; &nbsp; &nbsp; Когда у клиента или сервера истекло время ожидания, ему СЛЕДУЕТ
<br>&nbsp; &nbsp; &nbsp; произвести изящное закрытие транспортного соединения. Как
<br>&nbsp; &nbsp; &nbsp; клиентам, так и серверам СЛЕДУЕТ постоянно наблюдать за другой
<br>&nbsp; &nbsp; &nbsp; стороной на предмет закрытия соединения, и соответственно
<br>&nbsp; &nbsp; &nbsp; отвечать. Если клиент или сервер не обнаруживает закрытия
<br>&nbsp; &nbsp; &nbsp; соединения другой стороной сразу, то это вызывает не оправданную
<br>&nbsp; &nbsp; &nbsp; трату ресурсов сети.
<br>
<br>&nbsp; &nbsp; &nbsp; Клиент, сервер, или прокси-сервер МОГУТ закрыть транспортное
<br>&nbsp; &nbsp; &nbsp; соединение в любое время. Например, клиент МОЖЕТ начать посылать
<br>&nbsp; &nbsp; &nbsp; новый запрос в то время, когда сервер решает закрыть
<br>&nbsp; &nbsp; &nbsp; "бездействующее" соединение. С точки зрения сервера, соединение
<br>&nbsp; &nbsp; &nbsp; закрывается, в то время как оно было неактивно, но с точки зрения
<br>&nbsp; &nbsp; &nbsp; клиента, запрос произошел.
<br>
<br>&nbsp; &nbsp; &nbsp; Это означает, что клиенты, серверы, и прокси-серверы ДОЛЖНЫ быть
<br>&nbsp; &nbsp; &nbsp; в состоянии обрабатывать асинхронные события закрытия.
<br>&nbsp; &nbsp; &nbsp; Программному обеспечению клиента СЛЕДУЕТ вновь открыть
<br>&nbsp; &nbsp; &nbsp; транспортное соединение и повторно передать прерванный запрос без
?   взаимодействия с пользователем, поскольку метод запроса
<br>&nbsp; &nbsp; &nbsp; idempotent (смотрите раздел 9.1.2); другие методы НЕ ДОЛЖНЫ быть
<br>&nbsp; &nbsp; &nbsp; повторены автоматически, хотя агенты пользователя МОГУТ предложить
<br>&nbsp; &nbsp; &nbsp; оператору выбор повторять запрос, или нет.
<br>
<br>&nbsp; &nbsp; &nbsp; Однако это автоматическое повторение НЕ СЛЕДУЕТ производить, если
<br>&nbsp; &nbsp; &nbsp; сбой происходит уже во втором запросе.
<br>
<br>&nbsp; &nbsp; &nbsp; Серверам всегда СЛЕДУЕТ отвечать на по крайней мере на один запрос
<br>&nbsp; &nbsp; &nbsp; в соединении, если это возможно. Серверам НЕ СЛЕДУЕТ разрывать
<br>&nbsp; &nbsp; &nbsp; соединение в середине передачи ответа, если не предполагается
<br>&nbsp; &nbsp; &nbsp; сетевой или клиентский отказ.
<br>
<br>&nbsp; &nbsp; &nbsp; Клиентам, использующим постоянные соединения, СЛЕДУЕТ ограничить
<br>&nbsp; &nbsp; &nbsp; число одновременных соединений, которые они устанавливают с данным
<br>&nbsp; &nbsp; &nbsp; сервером. Однопользовательскому клиенту СЛЕДУЕТ устанавливать
<br>&nbsp; &nbsp; &nbsp; максимум 2 соединения с любым сервером или прокси-сервером.
<br>&nbsp; &nbsp; &nbsp; Прокси-серверу СЛЕДУЕТ ограничиться 2*N соединеними с другими
<br>&nbsp; &nbsp; &nbsp; серверами или прокси-серверами, где N - число одновременно
<br>&nbsp; &nbsp; &nbsp; активных пользователей. Эти руководящие принципы предназначены
<br>&nbsp; &nbsp; &nbsp; для уменьшения времени HTTP ответа и избежания чрезмерной загрузки
<br>&nbsp; &nbsp; &nbsp; Интернета или других сетей.
<br>
<br>
<a name="58"></a><center><h2>8.2 Требования к передаче сообщений.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Общие требования:
<br>
<br>&nbsp; &nbsp; &nbsp; o  HTTP/1.1 серверам СЛЕДУЕТ поддерживать постоянные соединения и
<br>&nbsp; &nbsp; &nbsp; использовать механизмы управления потоком данных TCP в целях
<br>&nbsp; &nbsp; &nbsp; уменьшения временных перегрузок, вместо закрытия соединений,
<br>&nbsp; &nbsp; &nbsp; которые, как ожидается, могут быть повторно использованы
<br>&nbsp; &nbsp; &nbsp; клиентами. Последняя методика может усиливать сетевую загрузку.
<br>
<br>&nbsp; &nbsp; &nbsp; o  HTTP/1.1 (или более поздним) клиентам, посылающим тело
<br>&nbsp; &nbsp; &nbsp; сообщения (message-body) СЛЕДУЕТ контролировать сетевое
<br>&nbsp; &nbsp; &nbsp; соединение на предмет ошибок во время передачи запроса. Если
<br>&nbsp; &nbsp; &nbsp; клиент обнаруживает ошибку, ему СЛЕДУЕТ немедленно прекратить
<br>&nbsp; &nbsp; &nbsp; передачу тела сообщения. Если тело посылается с использованием
<br>&nbsp; &nbsp; &nbsp; кодирования "по кускам" ("chunked", раздел 3.6), то кусок
<br>&nbsp; &nbsp; &nbsp; нулевой длины, и пустой завершитель МОГУТ использоваться для
<br>&nbsp; &nbsp; &nbsp; индикации преждевременного конца сообщения. Если телу
<br>&nbsp; &nbsp; &nbsp; предшествовал заголовок Content-Length, клиент ДОЛЖЕН закрыть
<br>&nbsp; &nbsp; &nbsp; соединение.
<br>
<br>&nbsp; &nbsp; &nbsp; o  HTTP/1.1 (или более поздний) клиент ДОЛЖЕН быть готов принять
<br>&nbsp; &nbsp; &nbsp; ответ с кодом состояния 100 (Продолжать, Continue),
<br>&nbsp; &nbsp; &nbsp; предшествующий основному ответу.
<br>
<br>&nbsp; &nbsp; &nbsp; o  HTTP/1.1 (или более поздний) сервер, который получает запрос от
<br>&nbsp; &nbsp; &nbsp; HTTP/1.0 (или более раннего) клиента НЕ ДОЛЖЕН передать ответ
<br>&nbsp; &nbsp; &nbsp; с кодом состояния 100 (Продолжать, Continue); ему СЛЕДУЕТ либо
<br>&nbsp; &nbsp; &nbsp; ожидать пока запрос будет выполнен обычным образом (то есть без
<br>&nbsp; &nbsp; &nbsp; использования прерванного запроса), либо преждевременно закрыть
<br>&nbsp; &nbsp; &nbsp; соединение.
<br>
<br>&nbsp; &nbsp; &nbsp; После получения метода, подчиненного этим требованиям, от HTTP/1.1
<br>&nbsp; &nbsp; &nbsp; (или более позднего) клиента, HTTP/1.1 (или более поздний) сервер
<br>&nbsp; &nbsp; &nbsp; ДОЛЖЕН либо ответить кодом состояния 100 (Продолжать, Continue) и
<br>&nbsp; &nbsp; &nbsp; продолжать чтение входного потока, либо ответить ошибочным кодом
<br>&nbsp; &nbsp; &nbsp; состояния. Если сервер ответил ошибочным кодом состояния, то он
<br>&nbsp; &nbsp; &nbsp; МОЖЕТ либо закрыть транспортное соединение (TCP), либо продолжать
<br>&nbsp; &nbsp; &nbsp; читать и отбрасывать оставшуюся часть запроса. Он НЕ ДОЛЖЕН
<br>&nbsp; &nbsp; &nbsp; выполнять запрошенный метод, если возвратил код состояния ошибки.
<br>
<br>&nbsp; &nbsp; &nbsp; Клиентам СЛЕДУЕТ помнить номер версии HTTP, используемой сервером
<br>&nbsp; &nbsp; &nbsp; по крайней мере в последний раз; если HTTP/1.1 клиент встречал
<br>&nbsp; &nbsp; &nbsp; HTTP/1.1 или более поздний ответ от сервера, и видит закрытие
<br>&nbsp; &nbsp; &nbsp; соединения перед получением какого-либо кода состояния от сервера,
<br>&nbsp; &nbsp; &nbsp; клиенту СЛЕДУЕТ повторить запрос без взаимодействия с
?   пользователем, поскольку метод запроса idempotent (смотрите
<br>&nbsp; &nbsp; &nbsp; раздел 9.1.2); другие методы НЕ ДОЛЖНЫ быть повторены
<br>&nbsp; &nbsp; &nbsp; автоматически, хотя агенты пользователя МОГУТ предложить оператору
<br>&nbsp; &nbsp; &nbsp; выбор повторять запрос, или нет. Если клиент повторяет запрос,
<br>&nbsp; &nbsp; &nbsp; то он
<br>
<br>&nbsp; &nbsp; &nbsp; o  ДОЛЖЕН сначала послать поля заголовка запроса, а затем
<br>
<br>&nbsp; &nbsp; &nbsp; o  ДОЛЖЕН ожидать ответа сервера с кодом 100 (Продолжать,
<br>&nbsp; &nbsp; &nbsp; Continue), а затем продолжать, или с кодом состояния ошибки.
<br>
<br>&nbsp; &nbsp; &nbsp; Если HTTP/1.1 клиент не встречал ответа сервера версии HTTP/1.1
<br>&nbsp; &nbsp; &nbsp; или более поздней, то ему следует считать, что сервер реализует
<br>&nbsp; &nbsp; &nbsp; HTTP/1.0 или более старый протокол и не использовать ответы с
<br>&nbsp; &nbsp; &nbsp; кодом состояния 100 (Продолжать, Continue). Если в такой ситуации
<br>&nbsp; &nbsp; &nbsp; клиент видит закрытие соединения перед получением какого-либо
<br>&nbsp; &nbsp; &nbsp; ответа с кодом состояния от сервера, то ему СЛЕДУЕТ повторить
<br>&nbsp; &nbsp; &nbsp; запрос. Если клиент повторяет запрос к этому HTTP/1.0 серверу, то
?   он должен использовать следующий "binary exponential backoff"
<br>&nbsp; &nbsp; &nbsp; алгоритм, чтобы быть уверенным в получении надежного ответа:
<br>
<br>&nbsp; &nbsp; &nbsp; 1. Инициализировать новое соединение с сервером.
<br>
<br>&nbsp; &nbsp; &nbsp; 2. Передать заголовки запроса (request-headers).
<br>
<br>&nbsp; &nbsp; &nbsp; 3. Инициализировать переменную R примерным временем передачи
<br>&nbsp; &nbsp; &nbsp; информации на сервер и обратно (например на основании времени
<br>&nbsp; &nbsp; &nbsp; установления соединения), или постоянным значение в 5 секунд,
<br>&nbsp; &nbsp; &nbsp; если время передачи не доступно.
<br>
<br>&nbsp; &nbsp; &nbsp; 4. Вычислить T = R * (2**N), где N - число предыдущих повторов
<br>&nbsp; &nbsp; &nbsp; этого запроса.
<br>
<br>&nbsp; &nbsp; &nbsp; 5. Либо дождаться от сервера ответа с кодом ошибки, либо просто
<br>&nbsp; &nbsp; &nbsp; выждать T секунд (смотря что произойдет раньше).
<br>
<br>&nbsp; &nbsp; &nbsp; 6. Если ответа с кодом ошибки не получено, после T секунд передать
<br>&nbsp; &nbsp; &nbsp; тело запроса.
<br>
<br>&nbsp; &nbsp; &nbsp; 7. Если клиент обнаруживает, что соединение было закрыто
<br>&nbsp; &nbsp; &nbsp; преждевременно, то ему нужно повторять начиная с шага 1, пока
<br>&nbsp; &nbsp; &nbsp; запрос не будет принят, либо пока не будет получен ошибочный
<br>&nbsp; &nbsp; &nbsp; ответ, либо пока у пользователя не кончится терпение и он не
<br>&nbsp; &nbsp; &nbsp; завершит процесс повторения.
<br>
<br>&nbsp; &nbsp; &nbsp; Независимо от того, какая версия HTTP реализована сервером, если
<br>&nbsp; &nbsp; &nbsp; клиент получает ошибочный код состояния, то он
<br>
<br>&nbsp; &nbsp; &nbsp; o  НЕ ДОЛЖЕН продолжать и
<br>
<br>&nbsp; &nbsp; &nbsp; o  ДОЛЖЕН закрыть соединение, если он не завершил посылку
<br>&nbsp; &nbsp; &nbsp; сообщения.
<br>
<br>&nbsp; &nbsp; &nbsp; HTTP/1.1 (или более позднему) клиенту, который обнаруживает
<br>&nbsp; &nbsp; &nbsp; закрытие соединения после получения ответа с кодом состояния 100
<br>&nbsp; &nbsp; &nbsp; (Продолжать, Continue), но до получения ответа с другим кодом
<br>&nbsp; &nbsp; &nbsp; состояния, СЛЕДУЕТ повторить запрос, но уже не ожидать ответа с
<br>&nbsp; &nbsp; &nbsp; кодом состояния 100 (Продолжать, Continue) (но он МОЖЕТ сделать
<br>&nbsp; &nbsp; &nbsp; так, если это упрощает реализацию).
<br>
<br>
<a name="59"></a><center><h2>9 Определения методов (Method Definitions).</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Набор общих методов для HTTP/1.1 приводится ниже. Хотя этот набор
<br>&nbsp; &nbsp; &nbsp; может быть расширен, нельзя считать, что дополнительные методы
<br>&nbsp; &nbsp; &nbsp; имеют одиннаковую семантику, если они являются расширениями
<br>&nbsp; &nbsp; &nbsp; разных клиентов и серверов.
<br>
<br>&nbsp; &nbsp; &nbsp; Поле заголовка запроса Host (раздел 14.23) ДОЛЖНО сопровождать
<br>&nbsp; &nbsp; &nbsp; все HTTP/1.1 запросы.
<br>
<br>
?9.1 Безопасные и Idempotent методы.
<br>
<br>
<a name="60"></a><center><h2>9.1.1 Безопасные методы.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Программистам следует понимать, что программное обеспечение при
<br>&nbsp; &nbsp; &nbsp; взаимодействии с Интернетом представляет пользователя, и программе
<br>&nbsp; &nbsp; &nbsp; следует информировать пользователя о любых действиях, которые он
<br>&nbsp; &nbsp; &nbsp; может произвести, но которые могут иметь непредсказуемое значение
<br>&nbsp; &nbsp; &nbsp; для него или других лиц.
<br>
<br>&nbsp; &nbsp; &nbsp; В частности было принято соглашение, что методы GET и HEAD никогда
<br>&nbsp; &nbsp; &nbsp; не должны иметь иного значения, кроме загрузки. Эти методы следует
<br>&nbsp; &nbsp; &nbsp; рассматривать как "безопасные". Это позволяет агентам пользователя
<br>&nbsp; &nbsp; &nbsp; представлять другие методы, такие как POST, PUT и DELETE, таким
<br>&nbsp; &nbsp; &nbsp; образом, чтобы пользователь был проинформирован о том, что он
<br>&nbsp; &nbsp; &nbsp; запрашивает выполнение потенциально опасного действия.
<br>
<br>&nbsp; &nbsp; &nbsp; Естественно, не возможно гарантировать, что сервер не генерирует
<br>&nbsp; &nbsp; &nbsp; побочные эффекты в результате выполнения запроса GET; фактически,
<br>&nbsp; &nbsp; &nbsp; некоторые динамические ресурсы содержат такую возможность. Важное
<br>&nbsp; &nbsp; &nbsp; различие здесь в том, что не пользователь запрашивает побочные
<br>&nbsp; &nbsp; &nbsp; эффекты, и, следовательно, пользователь не может нести
<br>&nbsp; &nbsp; &nbsp; ответственность за них.
<br>
<br>
?9.1.2 Idempotent методы.
<br>
<br>&nbsp; &nbsp; &nbsp; Методы могут также обладать свойством "idempotence" в том смысле,
<br>&nbsp; &nbsp; &nbsp; что побочные эффекты от N &gt; 0 идентичных запросов такие же, как
<br>&nbsp; &nbsp; &nbsp; от одиночного запроса (за исключение ошибок и проблем
<br>&nbsp; &nbsp; &nbsp; устаревания). Методы GET, HEAD, PUT и DELETE обладают данным
<br>&nbsp; &nbsp; &nbsp; свойством.
<br>
<br>
<a name="61"></a><center><h2>9.2 OPTIONS.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Метод OPTIONS представляет запрос информации об опциях соединения,
<br>&nbsp; &nbsp; &nbsp; доступных в цепочке запросов/ответов, идентифицируемой
<br>&nbsp; &nbsp; &nbsp; запрашиваемым URI (Request-URI). Этот метод позволяет клиенту
<br>&nbsp; &nbsp; &nbsp; определять опции и/или требования, связанные с ресурсом, или
<br>&nbsp; &nbsp; &nbsp; возможностями сервера, но не производя никаких действий над
<br>&nbsp; &nbsp; &nbsp; ресурсом и не инициируя его загрузку.
<br>
<br>&nbsp; &nbsp; &nbsp; Если ответ сервера - это не сообщение об ошибке, то ответ НЕ
<br>&nbsp; &nbsp; &nbsp; ДОЛЖЕН содержать иной информации объекта, кроме той, которую можно
<br>&nbsp; &nbsp; &nbsp; рассматривать как опции соединения (например Allow - можно
<br>&nbsp; &nbsp; &nbsp; рассматривать как опцию соединения, а Content-Type - нет). Ответы
<br>&nbsp; &nbsp; &nbsp; на этот метод не кэшируются.
<br>
<br>&nbsp; &nbsp; &nbsp; Если запрашиваемый URI (Request-URI) - звездочка ("*"), то запрос
<br>&nbsp; &nbsp; &nbsp; OPTIONS предназначен для обращения к серверу в целом. Если код
<br>&nbsp; &nbsp; &nbsp; состояния в ответе - 200, то ответу СЛЕДУЕТ содержать любые поля
<br>&nbsp; &nbsp; &nbsp; заголовка, которые указывают опциональные возможности, реализуемые
<br>&nbsp; &nbsp; &nbsp; сервером (например, Public), включая любые расширения, не
<br>&nbsp; &nbsp; &nbsp; определенные данной спецификацией, в дополнение к соответствующим
<br>&nbsp; &nbsp; &nbsp; общим полям или полям заголовка ответа (response-header). Как
<br>&nbsp; &nbsp; &nbsp; описано в разделе 5.1.2, запрос "OPTIONS *" может быть применен
<br>&nbsp; &nbsp; &nbsp; через прокси-сервер с определением адресуемого сервера в
<br>&nbsp; &nbsp; &nbsp; запрашиваемом URI (Request-URI) с пустым путем.
<br>
<br>&nbsp; &nbsp; &nbsp; Если запрашиваемый URI (Request-URI) не звездочка ("*"), то запрос
<br>&nbsp; &nbsp; &nbsp; OPTIONS применяется к опциям, которые доступны при соединении с
<br>&nbsp; &nbsp; &nbsp; указанным ресурсом. Если код состояния ответа - 200, то ответу
<br>&nbsp; &nbsp; &nbsp; СЛЕДУЕТ содержать любые поля заголовка, которые указывают
<br>&nbsp; &nbsp; &nbsp; опциональные возможности, реализуемые сервером и применимые к
<br>&nbsp; &nbsp; &nbsp; указанному ресурсу (например, Allow), включая любые расширения, не
<br>&nbsp; &nbsp; &nbsp; определенные данной спецификацией, в дополнение к соответствующим
<br>&nbsp; &nbsp; &nbsp; общим полям или полям заголовка ответа (response-header). Если
<br>&nbsp; &nbsp; &nbsp; запрос OPTIONS передается через прокси-сервер, то последний
<br>&nbsp; &nbsp; &nbsp; редактирует ответ, исключая те опции, которые не предусмотрены
<br>&nbsp; &nbsp; &nbsp; возможности этого прокси-сервера.
<br>
<br>
<a name="62"></a><center><h2>9.3 GET.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Метод GET позволяет получать любую информацию (в форме объекта),
<br>&nbsp; &nbsp; &nbsp; идентифицированную запрашиваемым URI (Request-URI). Если
<br>&nbsp; &nbsp; &nbsp; запрашиваемый URI (Request-URI) обращается к процессу,
<br>&nbsp; &nbsp; &nbsp; производящему данные, то в качестве объекта ответа должны быть
<br>&nbsp; &nbsp; &nbsp; возвращены произведенные данные, а не исходный текст процесса,
<br>&nbsp; &nbsp; &nbsp; если сам процесс не выводит исходный текст.
<br>
<br>&nbsp; &nbsp; &nbsp; Различается "условный GET" ("conditional GET"), при котором
<br>&nbsp; &nbsp; &nbsp; сообщение запроса включает поля заголовка If-Modified-Since,
<br>&nbsp; &nbsp; &nbsp; If-Unmodified-Since, If-Match, If-None-Match, или If-Range.
<br>&nbsp; &nbsp; &nbsp; Условный метод GET запрашивает передачу объекта, только если он
<br>&nbsp; &nbsp; &nbsp; удовлетворяет условиям, описанным в условных полях заголовка.
<br>&nbsp; &nbsp; &nbsp; Условный метод GET предназначен для уменьшения ненужной загрузки
<br>&nbsp; &nbsp; &nbsp; сети, и позволяет обновлять кэшированные объекты без использования
<br>&nbsp; &nbsp; &nbsp; нескольких запросов или пересылки данных, уже сохраненных
<br>&nbsp; &nbsp; &nbsp; клиентом.
<br>
<br>&nbsp; &nbsp; &nbsp; Различается также "частичный GET" ("partial GET"), при котором
<br>&nbsp; &nbsp; &nbsp; сообщение запроса включает поле заголовка Range. Частичный GET
<br>&nbsp; &nbsp; &nbsp; запрашивает передачу только части объекта, как описано в разделе
<br>&nbsp; &nbsp; &nbsp; 14.36. Частичный метод GET предназначен для уменьшения ненужной
<br>&nbsp; &nbsp; &nbsp; загрузки сети, и позволяет собирать объекты из частей, без
<br>&nbsp; &nbsp; &nbsp; передачи частей данных, уже сохраненных клиентом.
<br>
<br>&nbsp; &nbsp; &nbsp; Ответ на запрос GET кэшируем тогда и только тогда, когда он
<br>&nbsp; &nbsp; &nbsp; отвечает требованиям HTTP кэширования, описанным в разделе 13.
<br>
<br>
<a name="63"></a><center><h2>9.4 HEAD.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Метод HEAD идентичен GET, за исключением того, что сервер НЕ
<br>&nbsp; &nbsp; &nbsp; ДОЛЖЕН возвращать в ответе тело сообщения (message-body).
<br>&nbsp; &nbsp; &nbsp; Метаинформации, содержащейся в HTTP заголовках ответа на запрос
<br>&nbsp; &nbsp; &nbsp; HEAD СЛЕДУЕТ быть идентичной информации, представляемой в ответ
<br>&nbsp; &nbsp; &nbsp; на запрос GET. Этот метод может использоваться для получения
<br>&nbsp; &nbsp; &nbsp; метаинформации об объекте запроса без непосредственной пересылки
<br>&nbsp; &nbsp; &nbsp; тела объекта (entity-body). Этот метод часто используется для
<br>&nbsp; &nbsp; &nbsp; тестирования гипертекстовых связей в целях проверки правильности,
<br>&nbsp; &nbsp; &nbsp; достижимости, и времени модификации.
<br>
<br>&nbsp; &nbsp; &nbsp; Ответ на запрос HEAD может быть кэшируемым в том смысле, что
<br>&nbsp; &nbsp; &nbsp; информация, содержащаяся в ответе может использоваться для
<br>&nbsp; &nbsp; &nbsp; модифицикации предварительно кэшированного объекта из этого
<br>&nbsp; &nbsp; &nbsp; ресурса. Если новые значения поля указывают, что кэшируемый
<br>&nbsp; &nbsp; &nbsp; объект отличается от текущего объекта (по таким параметрам, как
<br>&nbsp; &nbsp; &nbsp; Content-Length, Content-MD5, ETag или Last-Modified), то кэш
<br>&nbsp; &nbsp; &nbsp; ДОЛЖЕН обрабатывать содержимое как просроченное.
<br>
<br>
<a name="64"></a><center><h2>9.5 POST.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Метод POST используется для запроса, при котором адресуемый сервер
<br>&nbsp; &nbsp; &nbsp; принимает объект, включенный в запрос, как новое подчинение
<br>&nbsp; &nbsp; &nbsp; ресурса, идентифицированного запрашиваемым URI (Request-URI) в
<br>&nbsp; &nbsp; &nbsp; строке запроса (Request-Line). POST разработан для того, чтобы
<br>&nbsp; &nbsp; &nbsp; общим методом реализовать следующие функции:
<br>
<br>&nbsp; &nbsp; &nbsp; o  Аннотация существующих ресурсов;
<br>
<br>&nbsp; &nbsp; &nbsp; o  Регистрация сообщения на электронной доске объявлений
<br>&nbsp; &nbsp; &nbsp; (bulletin board), в конференции новостей (newsgroup), списке
<br>&nbsp; &nbsp; &nbsp; рассылки (mailing list), или подобной группе статей;
<br>
<br>&nbsp; &nbsp; &nbsp; o  Передача блока данных, например результат ввода в форме,
<br>&nbsp; &nbsp; &nbsp; процессу обработки;
<br>
<br>&nbsp; &nbsp; &nbsp; o  Расширение базы данных посредством конкатенирующей операции
<br>&nbsp; &nbsp; &nbsp; (append operation).
<br>
<br>&nbsp; &nbsp; &nbsp; Фактически функция, выполняемая методом POST, определяется
<br>&nbsp; &nbsp; &nbsp; сервером и обычно зависит от запрашиваемого URI (Request-URI).
<br>&nbsp; &nbsp; &nbsp; Объект, передаваемый методом POST, относится к этому URI таким же
<br>&nbsp; &nbsp; &nbsp; образом, как файл относится к каталогу, в котором он находится,
<br>&nbsp; &nbsp; &nbsp; статья относится к конференции новостей (newsgroup), в которой она
<br>&nbsp; &nbsp; &nbsp; зарегистрирована, а запись относится к базе данных.
<br>
<br>&nbsp; &nbsp; &nbsp; Действие, выполняемое методом POST может не давать в качестве
<br>&nbsp; &nbsp; &nbsp; результата ресурс, который можно было бы идентифицировать URI. В
<br>&nbsp; &nbsp; &nbsp; этом случае, в зависимости от того, включает ли ответ объект,
<br>&nbsp; &nbsp; &nbsp; описывающий результат, или нет, код состояния в ответе может быть
<br>&nbsp; &nbsp; &nbsp; как 200 (OK), так и 204 (Нет содержимого, No Content).
<br>
<br>&nbsp; &nbsp; &nbsp; Если ресурс был создан на первоначальном сервере, ответу СЛЕДУЕТ
<br>&nbsp; &nbsp; &nbsp; содержать код состояния 201 (Создан, Created) и включать объект,
<br>&nbsp; &nbsp; &nbsp; который описывает состояние запроса и ссылается на новый ресурс,
<br>&nbsp; &nbsp; &nbsp; а также заголовок Location (смотрите раздел 14.30).
<br>
<br>&nbsp; &nbsp; &nbsp; Ответы на этот метод не кэшируемы, если ответ не включает
<br>&nbsp; &nbsp; &nbsp; соответствующие поля заголовка Cache-Control или Expires. Однако,
<br>&nbsp; &nbsp; &nbsp; ответ с кодом состояния 303 (Смотреть другой, See Other) может
<br>&nbsp; &nbsp; &nbsp; использоваться для перенаправления агента пользователя для
<br>&nbsp; &nbsp; &nbsp; загрузки кэшируемого ресурса.
<br>
<br>&nbsp; &nbsp; &nbsp; Запросы POST должны отвечать требованиям передачи сообщения,
<br>&nbsp; &nbsp; &nbsp; изложенным в разделе 8.2.
<br>
<br>
<a name="65"></a><center><h2>9.6 PUT.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Запросы с методом PUT, которые содержат объект, сохраняются под
<br>&nbsp; &nbsp; &nbsp; запрашиваемым URI (Request-URI). Если Request-URI обращается к уже
<br>&nbsp; &nbsp; &nbsp; существующему ресурсу, включенный объект СЛЕДУЕТ рассматривать как
<br>&nbsp; &nbsp; &nbsp; модифицированную версию объекта, находящегося на первоначальном
<br>&nbsp; &nbsp; &nbsp; сервере. Если Request-URI не указывает на существующий ресурс, и
<br>&nbsp; &nbsp; &nbsp; может интерпретироваться агентом пользователя как новый ресурс для
<br>&nbsp; &nbsp; &nbsp; запросов, первоначальный сервер может создать ресурс с данным URI.
<br>&nbsp; &nbsp; &nbsp; Если новый ресурс создан, то первоначальный сервер ДОЛЖЕН сообщить
<br>&nbsp; &nbsp; &nbsp; агенту пользователя об этом посредством ответа с кодом состояния
<br>&nbsp; &nbsp; &nbsp; 201 (Создан, Created). Если существующий ресурс модифицирован, то
<br>&nbsp; &nbsp; &nbsp; для указания успешного завершения запроса СЛЕДУЕТ послать ответ с
<br>&nbsp; &nbsp; &nbsp; кодом состояния либо 200 (OK), либо 204 (Нет содержимого, No
<br>&nbsp; &nbsp; &nbsp; Content). Если ресурс не может быть создан или изменен для
<br>&nbsp; &nbsp; &nbsp; запрашиваемого URI (Request-URI), то СЛЕДУЕТ послать ответ,
<br>&nbsp; &nbsp; &nbsp; отражающий характер проблемы. Получатель объекта НЕ ДОЛЖЕН
<br>&nbsp; &nbsp; &nbsp; игнорировать заголовков Content-* (например Content-Range),
<br>&nbsp; &nbsp; &nbsp; которых не понимает или не реализует, а ДОЛЖЕН в данном случае
<br>&nbsp; &nbsp; &nbsp; возвратить ответ с кодом состояния 501 (Не реализовано, Not
<br>&nbsp; &nbsp; &nbsp; Implemented).
<br>
<br>&nbsp; &nbsp; &nbsp; Если запрос передается через кэш и запрашиваемый URI (Request-URI)
<br>&nbsp; &nbsp; &nbsp; идентифицирует один или несколько кэшированных в настоящее время
<br>&nbsp; &nbsp; &nbsp; объектов, то вхождения в кэш этих объектов должны обрабатываться
<br>&nbsp; &nbsp; &nbsp; как просроченные. Ответы на этот метод не кэшируемы.
<br>
<br>&nbsp; &nbsp; &nbsp; Фундаментальное различие между POST и PUT запросами, отражено в
<br>&nbsp; &nbsp; &nbsp; различном значении запрашиваемого URI (Request-URI). URI в запросе
<br>&nbsp; &nbsp; &nbsp; POST идентифицирует ресурс, который обрабатывает включенный
<br>&nbsp; &nbsp; &nbsp; объект. Этим ресурсом может быть процесс, принимающий данные, шлюз
<br>&nbsp; &nbsp; &nbsp; к некоторому другому протоколу, или отдельный объект, который
<br>&nbsp; &nbsp; &nbsp; принимает аннотации (accepts annotations). Напротив, URI в запросе
<br>&nbsp; &nbsp; &nbsp; PUT идентифицирует объект, включенный в запрос - агент
<br>&nbsp; &nbsp; &nbsp; пользователя назначает данный URI включенному ресурсу, а сервер НЕ
<br>&nbsp; &nbsp; &nbsp; ДОЛЖЕН пытаться применить запрос к некоторому другому ресурсу.
<br>&nbsp; &nbsp; &nbsp; Если сервер желает применить запрос к другому URI, он ДОЛЖЕН
<br>&nbsp; &nbsp; &nbsp; послать ответ с кодом 301 (Перемещен постоянно, Moved
<br>&nbsp; &nbsp; &nbsp; Permanently); агент пользователя МОЖЕТ затем принять собственное
<br>&nbsp; &nbsp; &nbsp; решение относительно переназначения запроса.
<br>
<br>&nbsp; &nbsp; &nbsp; Одиночный ресурс МОЖЕТ быть идентифицирован несколькими различными
<br>&nbsp; &nbsp; &nbsp; URI. Например, статья может иметь URI идентифицирующий "текущую
<br>&nbsp; &nbsp; &nbsp; версию", который отличен от URI, идентифицирующего каждую
<br>&nbsp; &nbsp; &nbsp; специфическую версию. В этом случае, запрос PUT на общий URI может
<br>&nbsp; &nbsp; &nbsp; отразиться (may result) на нескольких других URI, определенных
<br>&nbsp; &nbsp; &nbsp; сервером происхождения.
<br>
<br>&nbsp; &nbsp; &nbsp; HTTP/1.1 не определяет каким образом метод PUT воздействует на
<br>&nbsp; &nbsp; &nbsp; состояние первоначального сервера.
<br>
<br>&nbsp; &nbsp; &nbsp; Запросы PUT должны подчиняться требованиям передачи сообщений,
<br>&nbsp; &nbsp; &nbsp; изложенным в разделе 8.2.
<br>
<br>
<a name="66"></a><center><h2>9.7 DELETE.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Метод DELETE запрашивает первоначальный сервер об удалении
<br>&nbsp; &nbsp; &nbsp; ресурса, идентифицируемого запрашиваемым URI (Request-URI). Этот
<br>&nbsp; &nbsp; &nbsp; метод МОЖЕТ быть отменен человеческим вмешательством (или другими
<br>&nbsp; &nbsp; &nbsp; средствами) на первоначальном сервере. Клиенту нельзя
<br>&nbsp; &nbsp; &nbsp; гарантировать, что операция была выполнена, даже если код
<br>&nbsp; &nbsp; &nbsp; состояния, возвращенный первоначальным сервером указывает на то,
<br>&nbsp; &nbsp; &nbsp; что действие было завершено успешно. Однако, серверу НЕ СЛЕДУЕТ
<br>&nbsp; &nbsp; &nbsp; отвечать об успешном выполнении, если во время ответа он
<br>&nbsp; &nbsp; &nbsp; предполагает удалить ресурс или переместить его в недоступное
<br>&nbsp; &nbsp; &nbsp; положение.
<br>
<br>&nbsp; &nbsp; &nbsp; Успешному ответу СЛЕДУЕТ иметь код состояния 200 (OK), если ответ
<br>&nbsp; &nbsp; &nbsp; включает объект, описывающий состояние, либо иметь код состояния
<br>&nbsp; &nbsp; &nbsp; 202 (Принято, Accepted), если действие еще не было произведено,
<br>&nbsp; &nbsp; &nbsp; либо иметь код состояния 204 (Нет содержимого, No Content), если
<br>&nbsp; &nbsp; &nbsp; ответ сообщает об успехе (OK), но не содержит объекта.
<br>
<br>&nbsp; &nbsp; &nbsp; Если запрос передается через кэш и запрашиваемый URI (Request-URI)
<br>&nbsp; &nbsp; &nbsp; идентифицирует один или несколько кэшированных в настоящее время
<br>&nbsp; &nbsp; &nbsp; объектов, то вхождения их должны обрабатываться как просроченные.
<br>&nbsp; &nbsp; &nbsp; Ответы на этот метод не кэшируемы.
<br>
<br>
<a name="67"></a><center><h2>9.8 TRACE.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Метод TRACE используется для вызова удаленного возврата сообщения
<br>&nbsp; &nbsp; &nbsp; запроса на уровне приложения. Конечному получателю запроса СЛЕДУЕТ
<br>&nbsp; &nbsp; &nbsp; отразить полученное сообщение обратно клиенту как тело объекта
<br>&nbsp; &nbsp; &nbsp; ответа с кодом состояния 200 (OK). Конечным получателем является
<br>&nbsp; &nbsp; &nbsp; либо сервер происхождения, либо первый прокси-сервер, либо первый
<br>&nbsp; &nbsp; &nbsp; шлюз, получивший нулевое значение (0) в поле Max-Forwards в
<br>&nbsp; &nbsp; &nbsp; запросе (см. раздел 14.31). Запрос TRACE НЕ ДОЛЖЕН содержать
<br>&nbsp; &nbsp; &nbsp; объекта.
<br>
<br>&nbsp; &nbsp; &nbsp; TRACE позволяет клиенту видеть, что получается на другом конце
<br>&nbsp; &nbsp; &nbsp; цепочки запросов и использовать эти данные для тестирования или
<br>&nbsp; &nbsp; &nbsp; диагностической информации. Значение поля заголовка Via (раздел
<br>&nbsp; &nbsp; &nbsp; 14.44) представляет особый интерес, так как оно действует как
<br>&nbsp; &nbsp; &nbsp; след цепочки запросов. Использование поля заголовка Max-Forwards
<br>&nbsp; &nbsp; &nbsp; позволяет клиенту ограничивать длину цепочки запросов, что
<br>&nbsp; &nbsp; &nbsp; является полезным при тестировании бесконечных циклов в цепочке
<br>&nbsp; &nbsp; &nbsp; прокси-серверов, пересылающих сообщения.
<br>
<br>&nbsp; &nbsp; &nbsp; Если запрос успешно выполнен, то ответу СЛЕДУЕТ содержать все
<br>&nbsp; &nbsp; &nbsp; сообщение запроса в теле объекта (entity-body), а Content-Type
<br>&nbsp; &nbsp; &nbsp; следует быть равным "message/http". Ответы на этот метод НЕ
<br>&nbsp; &nbsp; &nbsp; ДОЛЖНЫ кэшироваться.
<br>
<br>
<a name="68"></a><center><h2>10 Описания кодов состояния (Status Code Definitions).</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Каждый код состояния, описанный ниже, включает описание метода
<br>&nbsp; &nbsp; &nbsp; (или методов), за которым он может следовать и метаинформации,
<br>&nbsp; &nbsp; &nbsp; требуемой в ответе.
<br>
<br>
<a name="69"></a><center><h2>10.1 1xx - Информационные коды.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Этот класс кодов состояния указывает предварительный (временный)
<br>&nbsp; &nbsp; &nbsp; ответ, состоящий только из строки состояния (Status-Line) и
<br>&nbsp; &nbsp; &nbsp; опциональных заголовков, и завершающийся пустой строкой. Так как
<br>&nbsp; &nbsp; &nbsp; HTTP/1.0 не определял никаких 1xx кодов состояния, серверы НЕ
<br>&nbsp; &nbsp; &nbsp; ДОЛЖНЫ посылать 1xx ответы HTTP/1.0 клиентам, за исключением
<br>&nbsp; &nbsp; &nbsp; экспериментальных условий.
<br>
<br>
<a name="70"></a><center><h2>10.1.1 100 Продолжать, Continue.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Клиент может продолжать запрос. Этот промежуточный ответ
<br>&nbsp; &nbsp; &nbsp; используется, для того, чтобы сообщить клиенту, что начальная
<br>&nbsp; &nbsp; &nbsp; часть запроса была получена и еще не отвергнута сервером. Клиенту
<br>&nbsp; &nbsp; &nbsp; СЛЕДУЕТ продолжить посылку оставшихся данных запроса или, если
<br>&nbsp; &nbsp; &nbsp; запрос уже был выполнен, игнорировать этот ответ. Сервер ДОЛЖЕН
<br>&nbsp; &nbsp; &nbsp; послать заключительный ответ после того, как запрос будет
<br>&nbsp; &nbsp; &nbsp; выполнен.
<br>
<br>
<a name="71"></a><center><h2>10.1.2 101 Переключение протоколов, Switching Protocols</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Сервер понимает и желает выполнить запрос клиента, если протокол
<br>&nbsp; &nbsp; &nbsp; прикладной программы в этом соединении будет изменен на тот,
<br>&nbsp; &nbsp; &nbsp; который указан в поле заголовка сообщения Upgrade (раздел 14.41).
<br>&nbsp; &nbsp; &nbsp; Сервер переключит протокол на тот, который определен в поле
<br>&nbsp; &nbsp; &nbsp; заголовка ответа Upgrade непосредственно после пустой строки,
<br>&nbsp; &nbsp; &nbsp; которая завершает ответ с кодом состояния 101.
<br>
<br>&nbsp; &nbsp; &nbsp; Протокол должен быть переключен только тогда, когда это принесет
<br>&nbsp; &nbsp; &nbsp; выгоду. Например, переключение на более новую версию HTTP выгодно
<br>&nbsp; &nbsp; &nbsp; по сравнения с использованием более старых версий, а переключение
<br>&nbsp; &nbsp; &nbsp; на синхронный протокол реального времени может быть выгодно при
<br>&nbsp; &nbsp; &nbsp; предоставлении ресурсов, которые используют такие возможности.
<br>
<br>
<a name="72"></a><center><h2>10.2 2xx - Успешные коды.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Этот класс кодов состояния указывает, что запрос клиента был
<br>&nbsp; &nbsp; &nbsp; успешно получен, понят, и принят.
<br>
<br>
<a name="73"></a><center><h2>10.2.1 200 OK.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Запрос был удачно выполнен. Информация, возвращаемая с ответом
<br>&nbsp; &nbsp; &nbsp; зависит от метода, используемого в запросе. Например:
<br>
<br>&nbsp; &nbsp; &nbsp; GET   в ответе представлен объект, соответствующий запрошенному
<br>&nbsp; &nbsp; &nbsp; ресурсу;
<br>
<br>&nbsp; &nbsp; &nbsp; HEAD  в ответе представлены поля заголовка объекта
<br>&nbsp; &nbsp; &nbsp; (entity-header), соответствующие запрошенному ресурсу. Тело
<br>&nbsp; &nbsp; &nbsp; сообщения (message-body) отсутствует;
<br>
<br>&nbsp; &nbsp; &nbsp; POST  в ответе представлено описание объекта или содержится
<br>&nbsp; &nbsp; &nbsp; результат действия;
<br>
<br>&nbsp; &nbsp; &nbsp; TRACE в ответе представлен объект, содержащий сообщение запроса,
<br>&nbsp; &nbsp; &nbsp; полученого конечным сервером.
<br>
<br>
<a name="74"></a><center><h2>10.2.2 201 Создан, Created.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Запрос был выполнен и в результате был создан новый ресурс. Новый
<br>&nbsp; &nbsp; &nbsp; созданный ресурс может быть вызван по URI (одному или нескольким),
<br>&nbsp; &nbsp; &nbsp; возвращенным в объекте ответа; наиболее специфический URL для
<br>&nbsp; &nbsp; &nbsp; ресурса отдается в поле заголовка Location. Первоначальный сервер
<br>&nbsp; &nbsp; &nbsp; ДОЛЖЕН создать ресурс перед возвратом кода состояния 201. Если
<br>&nbsp; &nbsp; &nbsp; действие не может быть выполнено немедленно, сервер должен
<br>&nbsp; &nbsp; &nbsp; возвратить ответ с кодом состояния 202 (Принято, Accepted) вместо
<br>&nbsp; &nbsp; &nbsp; 201.
<br>
<br>
<a name="75"></a><center><h2>10.2.3 202 Принято, Accepted.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Запрос был принят для обработки, но обработка не была завершена.
<br>&nbsp; &nbsp; &nbsp; В конечном счете запрос МОЖЕТ быть, а МОЖЕТ и не быть выполнен,
<br>&nbsp; &nbsp; &nbsp; поскольку он МОЖЕТ быть отвергнут при фактической обработке.
<br>&nbsp; &nbsp; &nbsp; Не имеется никакой возможности вторичной посылки кода состояния от
<br>&nbsp; &nbsp; &nbsp; асинхронной операции типа этой.
<br>
<br>&nbsp; &nbsp; &nbsp; Ответ с кодом состояния 202 преднамеренно уклончив. Цель его
<br>&nbsp; &nbsp; &nbsp; состоит в том, чтобы позволить серверу принять запрос для
<br>&nbsp; &nbsp; &nbsp; некоторого другого процесса (возможно пакетно-ориентированного
<br>&nbsp; &nbsp; &nbsp; процесса, который выполняется только один раз в день) и не
<br>&nbsp; &nbsp; &nbsp; требовать при этом, чтобы соединение агента пользователя с
<br>&nbsp; &nbsp; &nbsp; сервером сохранялось до завершения процесса. Объекту,
<br>&nbsp; &nbsp; &nbsp; возвращенному с этим ответом СЛЕДУЕТ содержать индикатор текущего
<br>&nbsp; &nbsp; &nbsp; состояния запроса и либо ссылку на монитор состояния, либо
<br>&nbsp; &nbsp; &nbsp; некоторую оценку времени, когда пользователь может ожидать
<br>&nbsp; &nbsp; &nbsp; завершения выполнения запроса.
<br>
<br>
<a name="76"></a><center><h2>10.2.4 203 Не авторская информация, Non-Authoritative Information.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Возвращенная в заголовке объекта (entity-header) метаинформация -
<br>&nbsp; &nbsp; &nbsp; это не оригинал, доступный на первоначальном сервере, а документ,
<br>&nbsp; &nbsp; &nbsp; собранный из локальных копий или копий третьей стороны.
<br>&nbsp; &nbsp; &nbsp; Представленный документ МОЖЕТ быть как подмножеством оригинальной
<br>&nbsp; &nbsp; &nbsp; версии, так и содержать сведения, которые в ней не были
<br>&nbsp; &nbsp; &nbsp; представлены. Например, включение локальной аннотирующей
<br>&nbsp; &nbsp; &nbsp; информацию о ресурсе МОЖЕТ расширить метаинформацию, известную
<br>&nbsp; &nbsp; &nbsp; первоначальному серверу. Использование этого кода состояния в
<br>&nbsp; &nbsp; &nbsp; ответе не является необходимым, но может применяться тогда, когда
<br>&nbsp; &nbsp; &nbsp; код состояния ответа отличен от 200 (OK).
<br>
<br>
<a name="77"></a><center><h2>10.2.5 204 Нет содержимого, No Content.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Сервер выполнил запрос, но нет никакой новой информации, которую
<br>&nbsp; &nbsp; &nbsp; можно послать обратно. Если клиент - агент пользователя, ему НЕ
<br>&nbsp; &nbsp; &nbsp; СЛЕДУЕТ изменять вид документа, который послужил причиной запроса.
<br>&nbsp; &nbsp; &nbsp; Этот ответ предназначен прежде всего для того, чтобы позволить
<br>&nbsp; &nbsp; &nbsp; вводить данные для действий, не изменяя вид активного документа
<br>&nbsp; &nbsp; &nbsp; агента пользователя. Ответ МОЖЕТ включать новую метаинформацию в
<br>&nbsp; &nbsp; &nbsp; форме заголовков объекта (entity-headers), которые СЛЕДУЕТ
<br>&nbsp; &nbsp; &nbsp; добавить к документу, показываемому в настоящее время агентом
<br>&nbsp; &nbsp; &nbsp; пользователя.
<br>
<br>&nbsp; &nbsp; &nbsp; Ответ с кодом состояния 204 НЕ ДОЛЖЕН содержать тела сообщения, и,
<br>&nbsp; &nbsp; &nbsp; таким образом, всегда завершается первой пустой строкой после
<br>&nbsp; &nbsp; &nbsp; полей заголовка.
<br>
<br>
<a name="78"></a><center><h2>10.2.6 205 Сбросить содержимое, Reset Content.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Сервер выполнил запрос, и агенту пользователя СЛЕДУЕТ отменить
<br>&nbsp; &nbsp; &nbsp; просмотр документа, который инициировал запрос. Этот ответ
<br>&nbsp; &nbsp; &nbsp; предназначен прежде всего для того, чтобы позволить ввод данных,
<br>&nbsp; &nbsp; &nbsp; осуществляемый пользователем, с последующей очисткой формы, в
<br>&nbsp; &nbsp; &nbsp; которой сделан ввод, так, чтобы пользователь мог легко
<br>&nbsp; &nbsp; &nbsp; инициировать следующее действие ввода. Ответ НЕ ДОЛЖЕН содержать
<br>&nbsp; &nbsp; &nbsp; объект.
<br>
<br>
<a name="79"></a><center><h2>10.2.7 206 Частичное содержимое, Partial Content.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Сервер выполнил частичный GET запрос ресурса. Запрос должен
<br>&nbsp; &nbsp; &nbsp; содержать поле заголовка Range (раздел 14.36), указывающее
<br>&nbsp; &nbsp; &nbsp; желаемый диапазон. Ответ ДОЛЖЕН содержать либо поле заголовка
<br>&nbsp; &nbsp; &nbsp; Content-Range (раздел 14.17), указывающее диапазон, включенный в
<br>&nbsp; &nbsp; &nbsp; ответ, либо тип содержимого (Content-Type) должен быть равным
<br>&nbsp; &nbsp; &nbsp; "multipart/byteranges", а поля Content-Range должны содержаться в
<br>&nbsp; &nbsp; &nbsp; каждой части. Если "multipart/byteranges" не используется, поле
<br>&nbsp; &nbsp; &nbsp; заголовка Content-Length в ответе ДОЛЖНО соответствовать
<br>&nbsp; &nbsp; &nbsp; фактическому числу октетов (OCTETs), переданных в теле сообщения
<br>&nbsp; &nbsp; &nbsp; (message-body).
<br>
<br>&nbsp; &nbsp; &nbsp; Кэш, который не поддерживает заголовки Range и Content-Range НЕ
<br>&nbsp; &nbsp; &nbsp; ДОЛЖЕН кэшировать ответы с кодом состояния 206.
<br>
<br>
<a name="80"></a><center><h2>10.3 3xx - Перенаправление.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Этот класс кодов состояния указывает, что для выполнения запроса
<br>&nbsp; &nbsp; &nbsp; агенту пользователя необходимо придпринять дополнительное
<br>&nbsp; &nbsp; &nbsp; действие. Требуемое действие МОЖЕТ быть выполнено агентом
<br>&nbsp; &nbsp; &nbsp; пользователя без взаимодействия с пользователем, тогда и только
<br>&nbsp; &nbsp; &nbsp; тогда, когда во втором запросе используется метод GET или HEAD.
<br>&nbsp; &nbsp; &nbsp; Агенту пользователя НЕ СЛЕДУЕТ автоматически перенаправлять
<br>&nbsp; &nbsp; &nbsp; запрос более 5 раз, так как такие переадресации обычно указывают
<br>&nbsp; &nbsp; &nbsp; бесконечный цикл.
<br>
<br>
<a name="81"></a><center><h2>10.3.1 300 Множественный выбор, Multiple Choices.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Запрошенный ресурс имеет несколько представлений, и можно
<br>&nbsp; &nbsp; &nbsp; использовать любое из перечисленных. Каждое представление имеет
<br>&nbsp; &nbsp; &nbsp; свое расположение и информацию для агента по управлению диалогом
<br>&nbsp; &nbsp; &nbsp; (раздел 12), представленную таким образом, что пользователь (или
<br>&nbsp; &nbsp; &nbsp; агент пользователя) может выбрать наиболее подходящее
<br>&nbsp; &nbsp; &nbsp; представление и перенаправить запрос к нему.
<br>
<br>&nbsp; &nbsp; &nbsp; Если запрос был отличен от HEAD, то ответу СЛЕДУЕТ содержать
<br>&nbsp; &nbsp; &nbsp; объект, включающий список характеристик и адресов, из которого
<br>&nbsp; &nbsp; &nbsp; пользователь или агент пользователя может выбрать один наиболее
<br>&nbsp; &nbsp; &nbsp; подходящий. Формат объекта определяется медиа типом, указанным в
<br>&nbsp; &nbsp; &nbsp; поле заголовка Content-Type. В зависимости от формата и
<br>&nbsp; &nbsp; &nbsp; возможностей агента пользователя, выбор наиболее подходящего
<br>&nbsp; &nbsp; &nbsp; представления может выполняться автоматически. Однако, эта
<br>&nbsp; &nbsp; &nbsp; спецификация не определяет какого-либо стандарта для
<br>&nbsp; &nbsp; &nbsp; автоматического выбора.
<br>
<br>&nbsp; &nbsp; &nbsp; Если сервер имеет представление по умолчанию (наиболее
<br>&nbsp; &nbsp; &nbsp; предпочтительное), то ему СЛЕДУЕТ включить URL этого представления
<br>&nbsp; &nbsp; &nbsp; в поле Location; агенты пользователя МОГУТ использовать значение
<br>&nbsp; &nbsp; &nbsp; поля Location для автоматической переадресации. Этот ответ
<br>&nbsp; &nbsp; &nbsp; является кэшируемым, если не обозначено иного.
<br>
<br>
<a name="82"></a><center><h2>10.3.2 301 Постоянно перенесен, Moved Permanently.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Запрошенному ресурсу был назначен новый постоянный URI, и любые
<br>&nbsp; &nbsp; &nbsp; будущие ссылки на этот ресурс СЛЕДУЕТ выполнять, используя один из
<br>&nbsp; &nbsp; &nbsp; возвращенных URI. Клиентам с возможностями редактирования связей
<br>&nbsp; &nbsp; &nbsp; СЛЕДУЕТ автоматически переопределить ссылки на запрашиваемый URI
<br>&nbsp; &nbsp; &nbsp; (Request-URI), используя одну или несколько новых ссылок,
<br>&nbsp; &nbsp; &nbsp; возвращенных сервером в тех местах, где это возможно. Этот ответ
<br>&nbsp; &nbsp; &nbsp; является кэшируемым, если не обозначено иного.
<br>
<br>&nbsp; &nbsp; &nbsp; Если новый URI - это расположение, то ответу СЛЕДУЕТ содержать URL
<br>&nbsp; &nbsp; &nbsp; в поле Location. Если метод запроса был не HEAD, то объекту ответа
<br>&nbsp; &nbsp; &nbsp; СЛЕДУЕТ содержать короткое гипертекстовое примечание с
<br>&nbsp; &nbsp; &nbsp; гиперссылкой на новый (или новые) URI.
<br>
<br>&nbsp; &nbsp; &nbsp; Если код состояния 301 был получен в ответ на запрос, отличный от
<br>&nbsp; &nbsp; &nbsp; GET или HEAD, агент пользователя НЕ ДОЛЖЕН автоматически
<br>&nbsp; &nbsp; &nbsp; переназначать запрос, пока нет подтверждения пользователя, так как
<br>&nbsp; &nbsp; &nbsp; иначе условия запроса изменятся.
<br>
<br>&nbsp; &nbsp; &nbsp; Обратите внимание: При автоматическом переназначении запроса
<br>&nbsp; &nbsp; &nbsp; POST после получения кода состояния 301, некоторые существующие
<br>&nbsp; &nbsp; &nbsp; HTTP/1.0 агенты пользователя ошибочно изменят метод запроса на
<br>&nbsp; &nbsp; &nbsp; GET.
<br>
<br>
<a name="83"></a><center><h2>10.3.3 302 Временно перемещен, Moved Temporarily.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Запрошенный ресурс временно находится под другим URI. Так как
<br>&nbsp; &nbsp; &nbsp; переадресация может быть изменена в любой момент, клиенту СЛЕДУЕТ
<br>&nbsp; &nbsp; &nbsp; продолжать использовать запрашиваемый URI (Request-URI) в будущих
<br>&nbsp; &nbsp; &nbsp; запросах. Кэшируемость этого ответа зависит только от содержимого
<br>&nbsp; &nbsp; &nbsp; полей заголовка Cache-Control или Expires (если этих полей нет, то
<br>&nbsp; &nbsp; &nbsp; ответ не кэшируется).
<br>
<br>&nbsp; &nbsp; &nbsp; Если новый URI - это расположение, то ответу СЛЕДУЕТ содержать URL
<br>&nbsp; &nbsp; &nbsp; в поле Location. Если метод запроса был не HEAD, то объекту ответа
<br>&nbsp; &nbsp; &nbsp; СЛЕДУЕТ содержать короткое гипертекстовое примечание с
<br>&nbsp; &nbsp; &nbsp; гиперссылкой на новый (или новые) URI.
<br>
<br>&nbsp; &nbsp; &nbsp; Если код состояния 302 был получен в ответ на запрос, отличный от
<br>&nbsp; &nbsp; &nbsp; GET или HEAD, агент пользователя НЕ ДОЛЖЕН автоматически
<br>&nbsp; &nbsp; &nbsp; переназначать запрос, пока нет подтверждения пользователя, так как
<br>&nbsp; &nbsp; &nbsp; иначе условия запроса изменятся.
<br>
<br>&nbsp; &nbsp; &nbsp; Обратите внимание: При автоматическом переназначении запроса
<br>&nbsp; &nbsp; &nbsp; POST после получения кода состояния 302, некоторые существующие
<br>&nbsp; &nbsp; &nbsp; HTTP/1.0 агенты пользователя ошибочно изменят метод запроса на
<br>&nbsp; &nbsp; &nbsp; GET.
<br>
<br>
<a name="84"></a><center><h2>10.3.4 303 Смотреть другой, See Other.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Ответ на запрос может быть найден под другим URI и его СЛЕДУЕТ
<br>&nbsp; &nbsp; &nbsp; запрашивать, используя метод GET для этого ресурса. Этот метод
<br>&nbsp; &nbsp; &nbsp; существует прежде всего для того, чтобы производить вывод данных
<br>&nbsp; &nbsp; &nbsp; активизированного методом POST сценария, используя перенаправление
<br>&nbsp; &nbsp; &nbsp; агента пользователя на указанный ресурс. Новый URI - это не
<br>&nbsp; &nbsp; &nbsp; ссылка, заменяющая первоначально запрошенный ресурс. Ответ с кодом
<br>&nbsp; &nbsp; &nbsp; состояния 303 не кэшируем, но ответ на второй (переназначенный)
<br>&nbsp; &nbsp; &nbsp; запрос МОЖЕТ быть кэширован.
<br>
<br>&nbsp; &nbsp; &nbsp; Если новый URI - это расположение, то ответу СЛЕДУЕТ содержать URL
<br>&nbsp; &nbsp; &nbsp; в поле Location. Если метод запроса был не HEAD, то объекту ответа
<br>&nbsp; &nbsp; &nbsp; СЛЕДУЕТ содержать короткое гипертекстовое примечание с
<br>&nbsp; &nbsp; &nbsp; гиперссылкой на новый (или новые) URI.
<br>
<br>
<a name="85"></a><center><h2>10.3.5 304 Не модифицирован, Not Modified.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Если клиент выполнил условный GET запрос, и доступ разрешен, но
<br>&nbsp; &nbsp; &nbsp; документ не изменился, то серверу СЛЕДУЕТ ответить, используя этот
<br>&nbsp; &nbsp; &nbsp; код состояния. Ответ НЕ ДОЛЖЕН содержать тела сообщения.
<br>
<br>&nbsp; &nbsp; &nbsp; Ответ ДОЛЖЕН содержать следующие поля заголовка:
<br>
<br>&nbsp; &nbsp; &nbsp; o  Date
<br>
<br>&nbsp; &nbsp; &nbsp; o  ETag и/или Content-Location, если заголовок был бы послан в
<br>&nbsp; &nbsp; &nbsp; ответе с кодом состояния 200 на этот же запрос
<br>
<br>&nbsp; &nbsp; &nbsp; o  Expires, Cache-Control, и/или Vary, если значение поля
<br>&nbsp; &nbsp; &nbsp; (field-value) может отличаться от посланного в любом
<br>&nbsp; &nbsp; &nbsp; предыдущем ответе для такого же варианта
<br>
<br>&nbsp; &nbsp; &nbsp; Если условный GET использует строгое сравнение кэша (strong cache
<br>&nbsp; &nbsp; &nbsp; validator) (смотреть раздел 13.3.3), ответу НЕ СЛЕДУЕТ содержать
<br>&nbsp; &nbsp; &nbsp; других заголовков объекта (entity-headers). Иначе (то есть, если
<br>&nbsp; &nbsp; &nbsp; условный GET использует слабое сравнение (weak validator)), ответ
<br>&nbsp; &nbsp; &nbsp; НЕ ДОЛЖЕН содержать других заголовков объекта; это предотвращает
<br>&nbsp; &nbsp; &nbsp; несогласованности между кэшированными телами объектов
<br>&nbsp; &nbsp; &nbsp; (entity-bodies) и модифицированными заголовками.
<br>
<br>&nbsp; &nbsp; &nbsp; Если ответ с кодом состояния 304 указывает объект, в настоящее
<br>&nbsp; &nbsp; &nbsp; время не кэшированный, то кэш ДОЛЖЕН игнорировать ответ и
<br>&nbsp; &nbsp; &nbsp; повторить запрос без условного выражения.
<br>
<br>&nbsp; &nbsp; &nbsp; Если кэш использует полученный ответ с кодом состояния 304 для
<br>&nbsp; &nbsp; &nbsp; модифицикации вхождения кэша, кэш ДОЛЖЕН модифицировать вхождение
<br>&nbsp; &nbsp; &nbsp; так, чтобы отразить любые новые значения полей, данные в ответе.
<br>
<br>&nbsp; &nbsp; &nbsp; Ответ с кодом состояния 304 НЕ ДОЛЖЕН включать тела сообщения
<br>&nbsp; &nbsp; &nbsp; (message-body), и, таким образом, всегда завершается первой пустой
<br>&nbsp; &nbsp; &nbsp; строкой после полей заголовка.
<br>
<br>
<a name="86"></a><center><h2>10.3.6 305 Используйте прокси-сервер, Use Proxy.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Обращение к запрошенному ресурсу ДОЛЖНО производиться через
<br>&nbsp; &nbsp; &nbsp; прокси-сервер, указанный в поле Location. В поле Location указан
<br>&nbsp; &nbsp; &nbsp; URL прокси-сервера. Ожидается, что получатель повторит запрос
<br>&nbsp; &nbsp; &nbsp; через прокси-сервер.
<br>
<br>
<a name="87"></a><center><h2>10.4 4xx - Коды ошибок клиента.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Класс кодов состояния 4xx предназначен для случаев, когда клиент,
<br>&nbsp; &nbsp; &nbsp; возможно, допустил ошибку. За исключением ответа на запрос
<br>&nbsp; &nbsp; &nbsp; HEAD, серверу СЛЕДУЕТ включить объект, содержащий объяснение
<br>&nbsp; &nbsp; &nbsp; ошибочной ситуации, и объяснение, является ли она временной или
<br>&nbsp; &nbsp; &nbsp; постоянной. Эти коды состояния применимы к любому методу запроса.
<br>&nbsp; &nbsp; &nbsp; Агентам пользователя СЛЕДУЕТ показывать пользователю любой
<br>&nbsp; &nbsp; &nbsp; включенный объект.
<br>
<br>&nbsp; &nbsp; &nbsp; Обратите внимание: Если клиент посылает данные, то реализации
<br>&nbsp; &nbsp; &nbsp; сервера, использующей TCP, следует гарантировать, что клиент
<br>&nbsp; &nbsp; &nbsp; подтвердил получение пакета(ов), содержащего ответ, прежде чем
<br>&nbsp; &nbsp; &nbsp; сервер закроет соединение. Если клиент продолжает посылать
<br>&nbsp; &nbsp; &nbsp; данные серверу после закрытия соединения, TCP стек сервера
<br>&nbsp; &nbsp; &nbsp; пошлет пакет сброса (RST) клиенту, а TCP стек клиента, в свою
<br>&nbsp; &nbsp; &nbsp; очередь, может стереть клиентские неподтвержденные входные
<br>&nbsp; &nbsp; &nbsp; буфера прежде, чем они будут прочитаны и интерпретированы
<br>&nbsp; &nbsp; &nbsp; приложением HTTP.
<br>
<br>
<a name="88"></a><center><h2>10.4.1 400 Испорченный Запрос, Bad Request.</h2></center>
<br>
?   Запрос не может быть понят сервером из-за malformed синтаксиса.
<br>&nbsp; &nbsp; &nbsp; Клиенту НЕ СЛЕДУЕТ повторять запрос без модификаций.
<br>
<br>
<a name="89"></a><center><h2>10.4.2 401 Несанкционированно, Unauthorized.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Запрос требует установления подлинности пользователя. Ответ ДОЛЖЕН
<br>&nbsp; &nbsp; &nbsp; включать поле заголовка WWW-Authenticate (раздел 14.46),
<br>&nbsp; &nbsp; &nbsp; содержащее вызов (challenge), применимый к запрошенному ресурсу.
<br>&nbsp; &nbsp; &nbsp; Клиент МОЖЕТ повторить запрос с подходящим полем заголовка
<br>&nbsp; &nbsp; &nbsp; Authorization (раздел 14.8). Если запрос уже включает рекомендации
<br>&nbsp; &nbsp; &nbsp; установления подлинности (Authorization credentials) в поле
<br>&nbsp; &nbsp; &nbsp; Authorization, то ответ с кодом состояния 401 указывает, что в
<br>&nbsp; &nbsp; &nbsp; установлении подлинности этим рекомендациям отказано. Если ответ
<br>&nbsp; &nbsp; &nbsp; с кодом состояния 401 содержит тот же самый вызов, что и
<br>&nbsp; &nbsp; &nbsp; предшествующий ответ, а агент пользователя уже делал попытку
<br>&nbsp; &nbsp; &nbsp; установления подлинности по крайней мере один раз, то СЛЕДУЕТ
<br>&nbsp; &nbsp; &nbsp; показать пользователю объект, который был дан в ответе, так как
?   этот объект МОЖЕТ включать relevant диагностическую информацию.
<br>&nbsp; &nbsp; &nbsp; Установление подлинности доступа в протоколе HTTP описывается в
<br>&nbsp; &nbsp; &nbsp; разделе 11.
<br>
<br>
<a name="90"></a><center><h2>10.4.3 402 Требуется оплата, Payment Required.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Этот код зарезервирован для будущего использования.
<br>
<br>
<a name="91"></a><center><h2>10.4.4 403 Запрещено, Forbidden.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Сервер понял запрос, но отказывается выполнять его. Установление
<br>&nbsp; &nbsp; &nbsp; подлинности (Authorization) не поможет, и запрос НЕ ДОЛЖЕН быть
<br>&nbsp; &nbsp; &nbsp; повторен. Если метод запроса не HEAD и сервер желает указать,
<br>&nbsp; &nbsp; &nbsp; почему запрос не был выполнен, ему СЛЕДУЕТ описать причину отказа
<br>&nbsp; &nbsp; &nbsp; в объекте. Этот код состояния обычно используется, когда сервер
<br>&nbsp; &nbsp; &nbsp; не желает указывать точную причину отказа, или когда никакой
<br>&nbsp; &nbsp; &nbsp; другой ответ не подходит.
<br>
<br>
<a name="92"></a><center><h2>10.4.5 404 Не найден, Not Found.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Сервер не нашел ничего, соответствующего данному запрашиваемому
<br>&nbsp; &nbsp; &nbsp; URI (Request-URI). Никак не сообщается является ли такое положение
<br>&nbsp; &nbsp; &nbsp; временным или постоянным.
<br>
<br>&nbsp; &nbsp; &nbsp; Если сервер не желает делать данную информацию доступной клиенту,
<br>&nbsp; &nbsp; &nbsp; то вместо этого кода состояния может использоваться код состояния
<br>&nbsp; &nbsp; &nbsp; 403 (Запрещено, Forbidden). Код состояния 410 (Удален, Gone)
<br>&nbsp; &nbsp; &nbsp; СЛЕДУЕТ использовать, если сервер знает через некоторый внутренне
<br>&nbsp; &nbsp; &nbsp; конфигурируемый механизм, что старый ресурс более недоступен, но
<br>&nbsp; &nbsp; &nbsp; не знает нового адреса для пересылки.
<br>
<br>
<a name="93"></a><center><h2>10.4.6 405 Метод не дозволен, Method Not Allowed.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Метод, определенный в строке запроса (Request-Line) не дозволено
<br>&nbsp; &nbsp; &nbsp; применять для ресурса, идентифицированного запрашиваемым URI
<br>&nbsp; &nbsp; &nbsp; (Request-URI). Ответ ДОЛЖЕН включать заголовок Allow, содержащий
<br>&nbsp; &nbsp; &nbsp; список допустимых методов для запрошенного ресурса.
<br>
<br>
<a name="94"></a><center><h2>10.4.7 406 Не приемлем, Not Acceptable.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Ресурс, идентифицируемый запросом, имеет возможности генерации
<br>&nbsp; &nbsp; &nbsp; только таких объектов ответа, которые имеют характеристики
<br>&nbsp; &nbsp; &nbsp; содержимого (content characteristics), не согласующиеся с
<br>&nbsp; &nbsp; &nbsp; заголовками приема (accept headers), представленными в запросе.
<br>
<br>&nbsp; &nbsp; &nbsp; Если это был не запрос HEAD, то в ответ СЛЕДУЕТ включить объект,
<br>&nbsp; &nbsp; &nbsp; содержащий список доступных характеристик объекта и адреса
<br>&nbsp; &nbsp; &nbsp; (locations), из которых пользователь или агент пользователя может
<br>&nbsp; &nbsp; &nbsp; выбрать наиболее подходящий. Формат объекта определеятся медиа
<br>&nbsp; &nbsp; &nbsp; типом, представленным в поле заголовка Content-Type. В зависимости
<br>&nbsp; &nbsp; &nbsp; от формата и возможностей агента пользователя, выбор наиболее
<br>&nbsp; &nbsp; &nbsp; подходящего варианта может выполняться автоматически. Однако, эта
<br>&nbsp; &nbsp; &nbsp; спецификация не определяет никакого стандарта для автоматического
<br>&nbsp; &nbsp; &nbsp; выбора.
<br>
<br>&nbsp; &nbsp; &nbsp; Обратите внимание: HTTP/1.1 серверы позволяют возвращать ответы,
<br>&nbsp; &nbsp; &nbsp; которые не приемлемы согласно заголовкам приема (accept
<br>&nbsp; &nbsp; &nbsp; headers), представленным в запросе. В некоторых случаях, это
<br>&nbsp; &nbsp; &nbsp; может быть даже предпочтительно по сравнению с посылкой ответа
<br>&nbsp; &nbsp; &nbsp; с кодом состояния 406. Агентам пользователя неплохо бы
<br>&nbsp; &nbsp; &nbsp; рассматривать заголовки поступившего ответа, чтобы определить,
<br>&nbsp; &nbsp; &nbsp; является ли он приемлемым. Если ответ недопустим, агенту
<br>&nbsp; &nbsp; &nbsp; пользователя СЛЕДУЕТ временно остановиться, чтобы получить
<br>&nbsp; &nbsp; &nbsp; больше данных и спросить пользователя о дальнейших действиях.
<br>
<br>
<a name="95"></a><center><h2>10.4.8 407 Требуется установление подлинности через прокси-сервер,</h2></center>
<br>&nbsp; &nbsp; &nbsp; Proxy Authentication Required.
<br>
<br>&nbsp; &nbsp; &nbsp; Этот код подобен коду 401 (Несанкционированно, Unauthorized), но
<br>&nbsp; &nbsp; &nbsp; указывает, что клиент ДОЛЖЕН сначала установить свою подлинность
<br>&nbsp; &nbsp; &nbsp; (authenticate) прокси-серверу. Прокси-сервер ДОЛЖЕН возвратить
<br>&nbsp; &nbsp; &nbsp; поле заголовка Proxy-Authenticate (раздел 14.33), содержащее
<br>&nbsp; &nbsp; &nbsp; вызов (challenge), применяемый прокси-сервером для запрошенного
<br>&nbsp; &nbsp; &nbsp; ресурса. Клиент МОЖЕТ повторить запрос с подходящим полем
<br>&nbsp; &nbsp; &nbsp; заголовка Proxy-Authorization (раздел 14.34). Установление
<br>&nbsp; &nbsp; &nbsp; подлинности доступа в протоколе HTTP описывается в разделе 11.
<br>
<br>
<a name="96"></a><center><h2>10.4.9 408 Истекло время ожидания запроса, Request Timeout.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Клиент не произвел запрос в течение времени, которое сервер готов
<br>&nbsp; &nbsp; &nbsp; ждать. Клиент МОЖЕТ повторить запрос без модификаций позже.
<br>
<br>
<a name="97"></a><center><h2>10.4.10 409 Конфликт, Conflict.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Запрос не был выполнен из-за конфликта с текущим состоянием
<br>&nbsp; &nbsp; &nbsp; ресурса. Этот код позволяется только в ситуациях, когда ожидается,
<br>&nbsp; &nbsp; &nbsp; что пользователь может решить конфликт и повторно передать запрос.
<br>&nbsp; &nbsp; &nbsp; Телу ответа СЛЕДУЕТ содержать достаточное количество информации
<br>&nbsp; &nbsp; &nbsp; для пользователя, чтобы он мог распознать источник конфликта. В
<br>&nbsp; &nbsp; &nbsp; идеале, объект ответа должен включать достаточно информации для
<br>&nbsp; &nbsp; &nbsp; пользователя или агента пользователя для решения проблемы; однако
<br>&nbsp; &nbsp; &nbsp; это может не быть возможно, да и не требуется.
<br>
<br>&nbsp; &nbsp; &nbsp; Конфликты, наиболее вероятно, будут возникать в ответ на запрос
<br>&nbsp; &nbsp; &nbsp; PUT. Если используется версификация, и объект, который должен быть
<br>&nbsp; &nbsp; &nbsp; помещен, включает изменения ресурса, которые находятся в
<br>&nbsp; &nbsp; &nbsp; противоречии со сделанными раньше каким-либо запросом (третьей
<br>&nbsp; &nbsp; &nbsp; стороны), сервер МОЖЕТ использовать ответ с кодом состояния 409,
<br>&nbsp; &nbsp; &nbsp; чтобы показать, что он не может выполнить запрос. В этом случае,
<br>&nbsp; &nbsp; &nbsp; объекту ответа СЛЕДУЕТ содержать список отличий двух версий в
<br>&nbsp; &nbsp; &nbsp; формате, определенном полем заголовка ответа Content-Type.
<br>
<br>
<a name="98"></a><center><h2>10.4.11 410 Удален, Gone.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Запрошенный ресурс больше не доступен на сервере, и нет никакого
<br>&nbsp; &nbsp; &nbsp; адреса для перенаправления запроса. Такое состояние СЛЕДУЕТ
<br>&nbsp; &nbsp; &nbsp; рассматривать как постоянное. Клиентам с возможностями
<br>&nbsp; &nbsp; &nbsp; редактирования гиперсвязей СЛЕДУЕТ удалить ссылки на запрашиваемый
<br>&nbsp; &nbsp; &nbsp; URI (Request-URI) после одобрения пользователем. Если сервер не
<br>&nbsp; &nbsp; &nbsp; знает, или не может определить, является ли такое положение
<br>&nbsp; &nbsp; &nbsp; постоянным или нет, то ему СЛЕДУЕТ вместо этого кода использовать
<br>&nbsp; &nbsp; &nbsp; код состояния 404 (Не найден, Not Found). Этот ответ является
<br>&nbsp; &nbsp; &nbsp; кэшируемым, если не обозначено иного.
<br>
<br>&nbsp; &nbsp; &nbsp; Ответ с кодом состояния 410 предназначен прежде всего для того,
<br>&nbsp; &nbsp; &nbsp; чтобы помочь в сопровождении WWW, уведомляя получателя, что ресурс
<br>&nbsp; &nbsp; &nbsp; преднамеренно недоступен и что владельцы сервера желают, чтобы
<br>&nbsp; &nbsp; &nbsp; удаленные связи, указывающие на этот ресурс были удалены. Такое
<br>&nbsp; &nbsp; &nbsp; случается в основном для ограниченных по времени, рекламных
<br>&nbsp; &nbsp; &nbsp; сервисов и для ресурсов, принадлежащих личностям, больше не
<br>&nbsp; &nbsp; &nbsp; занимающимся сайтом. Не обязательно отмечать все постоянно
<br>&nbsp; &nbsp; &nbsp; недоступные ресурсы как "удаленные" ("gone") или хранить запись в
<br>&nbsp; &nbsp; &nbsp; течение любого отрезка времени - это предоставляется на усмотрение
<br>&nbsp; &nbsp; &nbsp; владельца сервера.
<br>
<br>
<a name="99"></a><center><h2>10.4.12 411 Требуется длина, Length Required.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Сервер отказывается принимать запрос с неопределенным
<br>&nbsp; &nbsp; &nbsp; Content-Length. Клиент МОЖЕТ повторить запрос, если добавит
<br>&nbsp; &nbsp; &nbsp; допустимое поле заголовка Content-Length, содержащее длину тела
<br>&nbsp; &nbsp; &nbsp; сообщения (message-body) в сообщении запроса.
<br>
<br>
<a name="100"></a><center><h2>10.4.13 412 Предусловие неверно, Precondition Failed.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Предусловие, представленное одним или несколькими полями заголовка
<br>&nbsp; &nbsp; &nbsp; запроса (request-header), оказалось ложным при проверке сервером.
<br>&nbsp; &nbsp; &nbsp; Этот код ответа позволяет клиенту поместить предусловия на текущую
<br>&nbsp; &nbsp; &nbsp; метаинформацию ресурса (данные полей заголовка) и, таким образом,
<br>&nbsp; &nbsp; &nbsp; предотвратить применение запрошенного метода к ресурсу, отличному
<br>&nbsp; &nbsp; &nbsp; от того, для которого предназначен метод.
<br>
<br>
<a name="101"></a><center><h2>10.4.14 413 Объект запроса слишком большой, Request Entity Too Large.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Сервер отказывается обрабатывать запрос, потому что объект запроса
<br>&nbsp; &nbsp; &nbsp; больше, чем сервер желает или способен обработать. Сервер может
<br>&nbsp; &nbsp; &nbsp; закрыть соединение, чтобы не дать клиенту возможность продолжить
<br>&nbsp; &nbsp; &nbsp; запрос.
<br>
<br>&nbsp; &nbsp; &nbsp; Если это временное состояние, то серверу СЛЕДУЕТ включить поле
<br>&nbsp; &nbsp; &nbsp; заголовка Retry-After для указания времени, через которое клиент
<br>&nbsp; &nbsp; &nbsp; может снова повторить запрос.
<br>
<br>
<a name="102"></a><center><h2>10.4.15 414 URI запроса слишком длинный, Request-URI Too Long.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Сервер отказывается обслуживать запрос, потому что запрашиваемый
<br>&nbsp; &nbsp; &nbsp; URI (Request-URI) длиннее, чем сервер желает интерпретировать. Это
<br>&nbsp; &nbsp; &nbsp; редкое состояние, которое, по всей вероятности, происходит только
<br>&nbsp; &nbsp; &nbsp; тогда, когда клиент неправильно преобразовал запрос POST к запросу
<br>&nbsp; &nbsp; &nbsp; GET с длинной информацией запроса, либо когда клиент попал в
<br>&nbsp; &nbsp; &nbsp; "черную дыру" URL перенаправления (например, перенаправленный URL
<br>&nbsp; &nbsp; &nbsp; префикс указывает на свой суффикс), или когда на сервер
<br>&nbsp; &nbsp; &nbsp; производится нападение клиентом, пытающимся эксплуатировать
<br>&nbsp; &nbsp; &nbsp; лазейки в секретности, имеющиеся в некоторых серверах,
<br>&nbsp; &nbsp; &nbsp; использующих буфера фиксированной длины для чтения или
<br>&nbsp; &nbsp; &nbsp; манипулирования с запрашиваемым URI (Request-URI).
<br>
<br>
<a name="103"></a><center><h2>10.4.16 415 Неподдерживаемый медиа тип, Unsupported Media Type.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Сервер отказывается обслуживать запрос, потому что объект запроса
<br>&nbsp; &nbsp; &nbsp; находится в формате, не поддерживаемом запрошенным ресурсом для
<br>&nbsp; &nbsp; &nbsp; запрошенного метода.
<br>
<br>
<a name="104"></a><center><h2>10.5 5xx - Коды ошибок сервера.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Коды состояния, начинающиеся с цифры "5" указывают случаи, в
<br>&nbsp; &nbsp; &nbsp; которых сервер знает, что допустил ошибку или неспособен выполнить
<br>&nbsp; &nbsp; &nbsp; запрос. Отвечая на запрос, за исключением запроса HEAD, серверу
<br>&nbsp; &nbsp; &nbsp; СЛЕДУЕТ включить объект, содержащий объяснение ошибочной ситуации
<br>&nbsp; &nbsp; &nbsp; и информацию, является ли это положение временным или постоянным.
<br>&nbsp; &nbsp; &nbsp; Агентам пользователя СЛЕДУЕТ показывать пользователю любой
<br>&nbsp; &nbsp; &nbsp; включенный объект. Эти коды состояния применимы к любому методу
<br>&nbsp; &nbsp; &nbsp; запроса.
<br>
<br>
<a name="105"></a><center><h2>10.5.1 500 Внутренняя ошибка сервера, Internal Server Error.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Сервер столкнулся с непредвиденным условием, которое не позволяет
<br>&nbsp; &nbsp; &nbsp; ему выполнить запрос.
<br>
<br>
<a name="106"></a><center><h2>10.5.2 501 Не реализовано, Not Implemented.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Сервер не поддерживает функциональные возможности, требуемые для
<br>&nbsp; &nbsp; &nbsp; выполнения запроса. Этот ответ соответствует состоянию, когда
<br>&nbsp; &nbsp; &nbsp; сервер не распознает метод запроса и не способен обеспечитиь его
<br>&nbsp; &nbsp; &nbsp; для любого ресурса.
<br>
<br>
<a name="107"></a><center><h2>10.5.3 502 Ошибка шлюза, Bad Gateway.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Сервер, действуя в качестве шлюза или прокси-сервера, получил
<br>&nbsp; &nbsp; &nbsp; недопустимый ответ от следующего сервера в цепочке запросов, к
<br>&nbsp; &nbsp; &nbsp; которому обратился при попытке выполнить запрос.
<br>
<br>
<a name="108"></a><center><h2>10.5.4 503 Сервис недоступен, Service Unavailable.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Сервер в настоящее время не способен обработать запрос из-за
<br>&nbsp; &nbsp; &nbsp; временной перегрузки или обслуживания сервера. Это временное
<br>&nbsp; &nbsp; &nbsp; условие, которое будет облегчено после некоторой задержки.
<br>&nbsp; &nbsp; &nbsp; Если известна продолжительность задержки, она может быть указана
<br>&nbsp; &nbsp; &nbsp; в заголовке Retry-After. Если Retry-After не присутствует в
<br>&nbsp; &nbsp; &nbsp; ответе, клиенту СЛЕДУЕТ обрабатывать этот ответ как ответ с кодом
<br>&nbsp; &nbsp; &nbsp; 500.
<br>
<br>&nbsp; &nbsp; &nbsp; Обратите внимание: существование кода состояния 503 не
<br>&nbsp; &nbsp; &nbsp; подразумевает, что сервер должен использовать его, когда
<br>&nbsp; &nbsp; &nbsp; перегружен. Некоторые сервера могут просто закрывать соединение.
<br>
<br>
<a name="109"></a><center><h2>10.5.5 504 Истекло время ожидания от шлюза, Gateway Timeout.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Сервер, действуя в качестве шлюза или прокси-сервера, не получил
<br>&nbsp; &nbsp; &nbsp; своевременного ответа от следующего сервера в цепочке запросов, к
<br>&nbsp; &nbsp; &nbsp; которому обратился при попытке выполнить запрос.
<br>
<br>
<a name="110"></a><center><h2>10.5.6 505 Не поддерживаемая версия HTTP, HTTP Version Not Supported.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Сервер не поддерживает, или отказывается поддерживать, версию HTTP
<br>&nbsp; &nbsp; &nbsp; протокола, которая используется в сообщении запроса. Сервер
<br>&nbsp; &nbsp; &nbsp; указывает, что не способен или не желает выполнять запрос,
<br>&nbsp; &nbsp; &nbsp; используя ту же самую major версию, что и клиент, как описано в
<br>&nbsp; &nbsp; &nbsp; разделе 3.1, в других сообщениях. Ответу СЛЕДУЕТ содержать объект,
<br>&nbsp; &nbsp; &nbsp; описывающий, почему эта версия не поддерживается, и какие другие
<br>&nbsp; &nbsp; &nbsp; протоколы поддерживаются этим сервером.
<br>
<br>
<a name="111"></a><center><h2>11 Установление подлинности доступа (Access Authentication).</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; HTTP обеспечивает для установления подлинности простой механизм
<br>&nbsp; &nbsp; &nbsp; вызов-ответ (challenge-response), который МОЖЕТ использоваться
<br>&nbsp; &nbsp; &nbsp; сервером для вызова (challenge) клиентского запроса, а клиентом
<br>&nbsp; &nbsp; &nbsp; для предоставления опознавательной информации (authentication
<br>&nbsp; &nbsp; &nbsp; information). Он использует расширяемую, не чувствительную к
<br>&nbsp; &nbsp; &nbsp; регистру лексему идентификации схемы установления подлинности
<br>&nbsp; &nbsp; &nbsp; (authentication scheme) и отделенный запятой список пар
<br>&nbsp; &nbsp; &nbsp; атрибут-значение (attribute-value), которые представляют
<br>&nbsp; &nbsp; &nbsp; параметры, необходимые для установления подлинности с
<br>&nbsp; &nbsp; &nbsp; использованием этой схемы.
<br>
<br>&nbsp; &nbsp; &nbsp; auth-scheme    = token
<br>
<br>&nbsp; &nbsp; &nbsp; auth-param     = token "=" quoted-string
<br>
<br>&nbsp; &nbsp; &nbsp; Сообщение ответа с кодом 401 (Несанкционирован, Unauthorized)
<br>&nbsp; &nbsp; &nbsp; используется первоначальным сервером для вызова (challenge)
<br>&nbsp; &nbsp; &nbsp; установления подлинности (authorization) агентом пользователя.
<br>&nbsp; &nbsp; &nbsp; Этот ответ ДОЛЖЕН содержать поле заголовка WWW-Authenticate,
<br>&nbsp; &nbsp; &nbsp; включающее по крайней мере один вызов (challenge), применимый к
<br>&nbsp; &nbsp; &nbsp; запрошенному ресурсу.
<br>
<br>&nbsp; &nbsp; &nbsp; challenge      = auth-scheme 1*SP realm *( "," auth-param )
<br>
<br>&nbsp; &nbsp; &nbsp; realm          = "realm" "=" realm-value
<br>&nbsp; &nbsp; &nbsp; realm-value    = quoted-string
<br>
<br>&nbsp; &nbsp; &nbsp; Атрибут области (realm) (не чувствительный к регистру) требуется
<br>&nbsp; &nbsp; &nbsp; для всех схем установления подлинности, которые выдают вызов
<br>&nbsp; &nbsp; &nbsp; (challenge). Значение аттрибута realm (чувствительное к регистру),
<br>&nbsp; &nbsp; &nbsp; в комбинации с каноническим корневым URL (смотреть раздел 5.1.2)
<br>&nbsp; &nbsp; &nbsp; сервера, к которому обращен запрос, определяет область защиты
<br>&nbsp; &nbsp; &nbsp; (protection space). Эти области позволяют разбивать защищенные
<br>&nbsp; &nbsp; &nbsp; ресурсы сервера на множество областей, каждая из которых имеет
<br>&nbsp; &nbsp; &nbsp; собственную опознавательную схему и/или базу данных установления
<br>&nbsp; &nbsp; &nbsp; подлинности (authorization database). Значение realm - строка,
<br>&nbsp; &nbsp; &nbsp; вообще говоря назначенная первоначальным сервером, которая может
<br>&nbsp; &nbsp; &nbsp; иметь дополнительную семантику, специфическую для схемы
<br>&nbsp; &nbsp; &nbsp; установления подлинности (authentication scheme).
<br>
<br>&nbsp; &nbsp; &nbsp; Агент пользователя, который хочет доказать свою подлинность
<br>&nbsp; &nbsp; &nbsp; серверу, обычно, но не обязательно, МОЖЕТ это сделать после
<br>&nbsp; &nbsp; &nbsp; получения ответа с кодом состояния 401 или 411, включив поле
<br>&nbsp; &nbsp; &nbsp; заголовка Authorization в запрос. Значение поля Authorization
<br>&nbsp; &nbsp; &nbsp; состоит из рекомендаций (credentials), содержащих информацию
<br>&nbsp; &nbsp; &nbsp; установления подлинности (authentication information) агента
<br>&nbsp; &nbsp; &nbsp; пользователя для области (realm) запрошенного ресурса.
<br>
<br>&nbsp; &nbsp; &nbsp; credentials    = basic-credentials
<br>&nbsp; &nbsp; &nbsp; | auth-scheme #auth-param
<br>
<br>&nbsp; &nbsp; &nbsp; Область (domain), над которой рекомендации (credentials) могут
<br>&nbsp; &nbsp; &nbsp; автоматически применяться агентом пользователя, определена
<br>&nbsp; &nbsp; &nbsp; областью защиты (protection space). Если подлинность была
<br>&nbsp; &nbsp; &nbsp; установлена предшествующим запросом, то эти же рекомендации
<br>&nbsp; &nbsp; &nbsp; (credentials) МОГУТ использоваться многократно во всех других
<br>&nbsp; &nbsp; &nbsp; запросах внутри этой области защиты (protection space) в течении
<br>&nbsp; &nbsp; &nbsp; времени, определенного схемой установления подлинности,
<br>&nbsp; &nbsp; &nbsp; параметрами, и/или установками пользователя. Если схемой
<br>&nbsp; &nbsp; &nbsp; установления подлинности не определено иного, то одиночная область
<br>&nbsp; &nbsp; &nbsp; защиты (protection space) не может простираться шире области
<br>&nbsp; &nbsp; &nbsp; сервера (the scope of its server).
<br>
<br>&nbsp; &nbsp; &nbsp; Если сервер не желает принимать рекомендации (credentials),
<br>&nbsp; &nbsp; &nbsp; посланные в запросе, то ему СЛЕДУЕТ возвратить ответ с кодом 401
<br>&nbsp; &nbsp; &nbsp; (Несанкционирован, Unauthorized). Ответ ДОЛЖЕН включать поле
<br>&nbsp; &nbsp; &nbsp; заголовка WWW-Authenticate, содержащее (возможно новый) вызов
<br>&nbsp; &nbsp; &nbsp; (challenge), применимый к запрошенному ресурсу, и объект,
<br>&nbsp; &nbsp; &nbsp; объясняющий отказ.
<br>
<br>&nbsp; &nbsp; &nbsp; Протокол HTTP не ограничивает приложения использованием этого
<br>&nbsp; &nbsp; &nbsp; простого механизма вызов-ответ (challenge-response) для
<br>&nbsp; &nbsp; &nbsp; установления подлинности доступа. МОЖНО использовать
<br>&nbsp; &nbsp; &nbsp; дополнительные механизмы, такие как шифрование на транспортном
<br>&nbsp; &nbsp; &nbsp; уровне или формирование пакета сообщения (message encapsulation)
<br>&nbsp; &nbsp; &nbsp; с дополнительными полями заголовка, определяющими информацию
<br>&nbsp; &nbsp; &nbsp; установления подлинности. Однако эти дополнительные механизмы не
<br>&nbsp; &nbsp; &nbsp; определены в этой спецификации.
<br>
<br>&nbsp; &nbsp; &nbsp; Прокси-сервера ДОЛЖНЫ быть полностью прозрачны для установления
<br>&nbsp; &nbsp; &nbsp; подлинности агента пользователя. То есть они ДОЛЖНЫ пересылать
<br>&nbsp; &nbsp; &nbsp; заголовки WWW-Authenticate и Authorization нетронутыми и
<br>&nbsp; &nbsp; &nbsp; следовать правилам раздела 14.8.
<br>
<br>&nbsp; &nbsp; &nbsp; HTTP/1.1 позволяет клиенту передавать информацию установления
<br>&nbsp; &nbsp; &nbsp; подлинности для и от прокси-сервера посредством заголовков
<br>&nbsp; &nbsp; &nbsp; Proxy-Authenticate и Proxy-Authorization.
<br>
<br>
<a name="112"></a><center><h2>11.1 Базовая схема установления подлинности (Basic Authentication</h2></center>
<br>&nbsp; &nbsp; &nbsp; Scheme).
<br>
<br>&nbsp; &nbsp; &nbsp; "Базовая" схема установления подлинности основана на том, что
<br>&nbsp; &nbsp; &nbsp; агент пользователя должен доказывать свою подлинность при помощи
<br>&nbsp; &nbsp; &nbsp; идентификатора пользователя (user-ID) и пароля (password) для
<br>&nbsp; &nbsp; &nbsp; каждой области (realm). Значению области (realm) следует быть
<br>&nbsp; &nbsp; &nbsp; непрозрачной (opaque) строкой, которую можно проверять только на
<br>&nbsp; &nbsp; &nbsp; равенство с другими областями на этом сервере. Сервер обслужит
<br>&nbsp; &nbsp; &nbsp; запрос, только если он может проверить правильность идентификатора
<br>&nbsp; &nbsp; &nbsp; пользователя (user-ID) и пароля (password) для защищенной области
<br>&nbsp; &nbsp; &nbsp; (protection space) запрошенного URI (Request-URI). Никаких
<br>&nbsp; &nbsp; &nbsp; опциональных опознавательных параметров нет.
<br>
<br>&nbsp; &nbsp; &nbsp; После получения запроса на URI, находящийся в защищаемой области
<br>&nbsp; &nbsp; &nbsp; (protection space), сервер МОЖЕТ ответить вызовом (challenge),
<br>&nbsp; &nbsp; &nbsp; подобным следующему:
<br>
<br>&nbsp; &nbsp; &nbsp; WWW-Authenticate: Basic realm="WallyWorld"
<br>
<br>&nbsp; &nbsp; &nbsp; где "WallyWorld" - строка, назначенная сервером, которая
<br>&nbsp; &nbsp; &nbsp; идентифицирует область защиты запрашиваемого URI (Request-URI).
<br>
<br>&nbsp; &nbsp; &nbsp; Чтобы получить права доступа, клиент посылает идентификатор
<br>&nbsp; &nbsp; &nbsp; пользователя (userid) и пароль (password), разделенные одним
<br>&nbsp; &nbsp; &nbsp; символом двоеточия (":"), внутри base64-кодированной строки
<br>&nbsp; &nbsp; &nbsp; рекомендаций (credentials).
<br>
<br>&nbsp; &nbsp; &nbsp; basic-credentials = "Basic" SP basic-cookie
<br>
<br>&nbsp; &nbsp; &nbsp; basic-cookie   = &lt;base64-кодированный [7] user-pass,
<br>&nbsp; &nbsp; &nbsp; за исключением не ограниченных 76
<br>&nbsp; &nbsp; &nbsp; символами в строке&gt;
<br>
<br>&nbsp; &nbsp; &nbsp; user-pass   = userid ":" password
<br>
<br>&nbsp; &nbsp; &nbsp; userid      = *&lt;TEXT не содержащий ":"&gt;
<br>
<br>&nbsp; &nbsp; &nbsp; password    = *TEXT
<br>
<br>&nbsp; &nbsp; &nbsp; Userid может быть чувствителен к регистру.
<br>
<br>&nbsp; &nbsp; &nbsp; Если агент пользователя хочет послать идентификатор пользователя
<br>&nbsp; &nbsp; &nbsp; (userid) "Aladdin", и пароль (password) "open sesame", он будет
<br>&nbsp; &nbsp; &nbsp; использовать следующее поле заголовка:
<br>
<br>&nbsp; &nbsp; &nbsp; Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
<br>
<br>&nbsp; &nbsp; &nbsp; Соглашения о защите, связанные с базовой схемой установления
<br>&nbsp; &nbsp; &nbsp; подлинности, смотрите в разделе 15.
<br>
<br>
<a name="113"></a><center><h2>11.2 Обзорная схема установления подлинности (Digest Authentication</h2></center>
<br>&nbsp; &nbsp; &nbsp; Scheme).
<br>
<br>&nbsp; &nbsp; &nbsp; Обзорное установление подлинности для HTTP определяется в
<br>&nbsp; &nbsp; &nbsp; RFC 2069 [32].
<br>
<br>
<a name="114"></a><center><h2>12 Обсуждение содержимого (Content Negotiation).</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Большинство HTTP ответов включают объект, который содержит
<br>&nbsp; &nbsp; &nbsp; информацию, предназначенную для интерпретации пользователем.
<br>&nbsp; &nbsp; &nbsp; Естественно желание обеспечить пользователя "лучшим доступным"
<br>&nbsp; &nbsp; &nbsp; объектом, соответствующим запросу. К сожалению для серверов и
<br>&nbsp; &nbsp; &nbsp; кэшей, не все пользователи имеют одиннаковые предпочтения, и не
<br>&nbsp; &nbsp; &nbsp; все агенты пользователя одинаково способны к визуализации всех
<br>&nbsp; &nbsp; &nbsp; типов объектов. По этой причине, HTTP имеет средства для
<br>&nbsp; &nbsp; &nbsp; нескольких механизмов "обсуждения содержимого" - процесса выбора
<br>&nbsp; &nbsp; &nbsp; самого лучшего представления для данного ответа, когда доступно
<br>&nbsp; &nbsp; &nbsp; несколько представлений.
<br>
<br>&nbsp; &nbsp; &nbsp; Обратите внимание: Это не вызывается "обсуждение формата"
<br>&nbsp; &nbsp; &nbsp; ("format negotiation"), потому что альтернативные представления
<br>&nbsp; &nbsp; &nbsp; могут иметь одиннаковый медиа тип, но использовать различные
<br>&nbsp; &nbsp; &nbsp; возможности этого типа, иметь разные языки и т.д.
<br>
<br>&nbsp; &nbsp; &nbsp; Любой ответ, содержащий тело объекта (entity-body) МОЖЕТ быть
<br>&nbsp; &nbsp; &nbsp; темой обсуждения, включая ошибочные ответы.
<br>
<br>&nbsp; &nbsp; &nbsp; Имеются два вида обсуждения содержимого, которые возможны в HTTP:
<br>&nbsp; &nbsp; &nbsp; управляемое сервером и управляемое агентом обсуждение. Эти два
<br>&nbsp; &nbsp; &nbsp; вида обсуждения независимы, и, таким образом, могут использоваться
<br>&nbsp; &nbsp; &nbsp; отдельно или вместе. Один метод использования их вместе,
<br>&nbsp; &nbsp; &nbsp; упоминаемый как прозрачное обсуждение, происходит, когда кэш
<br>&nbsp; &nbsp; &nbsp; использует информацию обсуждения, управляемого агентом,
<br>&nbsp; &nbsp; &nbsp; предоставляя ее первоначальному серверу, для обеспечения
<br>&nbsp; &nbsp; &nbsp; управляемого сервером обсуждения при последующих запросах.
<br>
<br>
<a name="115"></a><center><h2>12.1 Управляемое сервером обсуждение.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Обсуждение называется управляемым сервером, если выбор самого
<br>&nbsp; &nbsp; &nbsp; лучшего представления для ответа произведен алгоритмом,
<br>&nbsp; &nbsp; &nbsp; размещенным на сервере. Выбор основан на доступных представлениях
<br>&nbsp; &nbsp; &nbsp; ответа (они могут различаться по нескольким характеристикам;
<br>&nbsp; &nbsp; &nbsp; например языку, кодированию содержимого (content-coding), и т.д.)
<br>&nbsp; &nbsp; &nbsp; и содержании специфических полей заголовка в сообщении запроса,
<br>&nbsp; &nbsp; &nbsp; или на другой информации, имеющей отношение к запросу (такой как
<br>&nbsp; &nbsp; &nbsp; сетевой адрес клиента).
<br>
<br>&nbsp; &nbsp; &nbsp; Управляемое сервером обсуждение выгодно, когда алгоритм выбора из
<br>&nbsp; &nbsp; &nbsp; числа доступных представлений трудно описать агенту пользователя,
<br>&nbsp; &nbsp; &nbsp; или когда сервер желает послать "лучшее предположение" клиенту
<br>&nbsp; &nbsp; &nbsp; одновременно с первым ответом (надеясь избежать задержки пересылки
<br>&nbsp; &nbsp; &nbsp; туда и обратно последующего запроса, если "лучшее предположение"
<br>&nbsp; &nbsp; &nbsp; устроит пользователя). Чтобы улучшить предположение сервера,
<br>&nbsp; &nbsp; &nbsp; агент пользователя МОЖЕТ включать поля заголовка запроса (Accept,
<br>&nbsp; &nbsp; &nbsp; Accept-Language, Accept-Encoding, и т.д.), которые описывают
<br>&nbsp; &nbsp; &nbsp; предпочтительный ответ.
<br>
<br>&nbsp; &nbsp; &nbsp; Управляемое сервером обсуждение имеет недостатки:
<br>
<br>&nbsp; &nbsp; &nbsp; 1. Сервер не может точно определить, что могло бы быть "самым
<br>&nbsp; &nbsp; &nbsp; лучшим" для данного пользователя, так как это требует полного
<br>&nbsp; &nbsp; &nbsp; знания, как возможностей агента пользователя, так и целей
<br>&nbsp; &nbsp; &nbsp; использования ответа (например, пользователь хочет
<br>&nbsp; &nbsp; &nbsp; просматривать его на экране или печатать на бумаге?).
<br>
<br>&nbsp; &nbsp; &nbsp; 2. Наличие описания возможностей агента пользователя в каждом
<br>&nbsp; &nbsp; &nbsp; запросе может быть очень неэффективным (при условии, что
<br>&nbsp; &nbsp; &nbsp; только небольшой процент ответов имеет несколько
<br>&nbsp; &nbsp; &nbsp; представлений) и потенциально нарушает секретность
<br>&nbsp; &nbsp; &nbsp; пользователя.
<br>
<br>&nbsp; &nbsp; &nbsp; 3. Оно усложняет реализацию первоначального сервера и алгоритмов
<br>&nbsp; &nbsp; &nbsp; генерации ответов на запрос.
<br>
<br>&nbsp; &nbsp; &nbsp; 4. Оно может ограничивать способность общего кэша использовать
<br>&nbsp; &nbsp; &nbsp; один и тот же ответ для запросов нескольких пользователей.
<br>
<br>&nbsp; &nbsp; &nbsp; HTTP/1.1 включает следующие поля заголовка запроса
<br>&nbsp; &nbsp; &nbsp; (request-header), которые обеспечивают управляемое сервером
<br>&nbsp; &nbsp; &nbsp; обсуждение посредством описания возможностей агента пользователя
<br>&nbsp; &nbsp; &nbsp; и предпочтений самого пользователя: Accept (раздел 14.1),
<br>&nbsp; &nbsp; &nbsp; Accept-Charset (раздел 14.2), Accept-Encoding (раздел 14.3),
<br>&nbsp; &nbsp; &nbsp; Accept-Language (раздел 14.4), and User-Agent (раздел 14.42).
<br>&nbsp; &nbsp; &nbsp; Однако первоначальный сервер не ограничен этим и МОЖЕТ изменить
<br>&nbsp; &nbsp; &nbsp; ответ, основываясь на любом аспекте запроса, включая информацию,
<br>&nbsp; &nbsp; &nbsp; которая не содержится в полях заголовка запроса или информацию из
<br>&nbsp; &nbsp; &nbsp; расширенных полей заголовка, не определенных в этой спецификации.
<br>
<br>&nbsp; &nbsp; &nbsp; Первоначальный сервер HTTP/1.1 ДОЛЖЕН включать соответствующее
<br>&nbsp; &nbsp; &nbsp; поле заголовка Vary (раздел 14.43) в любой кэшируемый ответ,
<br>&nbsp; &nbsp; &nbsp; основанный на управлямом сервером обсуждении. Поле заголовка Vary
<br>&nbsp; &nbsp; &nbsp; описывает характеристики, которые могут меняться в ответе (то есть
<br>&nbsp; &nbsp; &nbsp; характеристики, согласно которым первоначальный сервер выбирает
<br>&nbsp; &nbsp; &nbsp; "наилучший" ответ из нескольких представлений).
<br>
<br>&nbsp; &nbsp; &nbsp; Общие HTTP/1.1 кэши ДОЛЖНЫ распознать поле заголовка Vary, если
<br>&nbsp; &nbsp; &nbsp; он присутствует в ответе, и отвечать требованиям, описанным в
<br>&nbsp; &nbsp; &nbsp; разделе 13.6, который описывает взаимодействия между кэшированием
<br>&nbsp; &nbsp; &nbsp; и обсуждением содержимого.
<br>
<br>
<a name="116"></a><center><h2>12.2 Управляемое агентом обсуждение.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; При управляемом агентом обсуждении, выбор лучшего представления
<br>&nbsp; &nbsp; &nbsp; ответа выполняется агентом пользователя после получения начального
<br>&nbsp; &nbsp; &nbsp; ответа первоначального сервера. Выбор основан на списке доступных
<br>&nbsp; &nbsp; &nbsp; представлений ответа, включенном в поля заголовка (эта
<br>&nbsp; &nbsp; &nbsp; спецификация резервирует имя поля Alternates, как описано в
<br>&nbsp; &nbsp; &nbsp; приложении 19.6.2.1) или тело объекта начального ответа. Каждое
<br>&nbsp; &nbsp; &nbsp; представление идентифицируется собственным URI. Выбор
<br>&nbsp; &nbsp; &nbsp; представления может выполняться автоматически (если агент
<br>&nbsp; &nbsp; &nbsp; пользователя способен это сделать) или вручную пользователем из
<br>&nbsp; &nbsp; &nbsp; сгенерированного (возможно гипертекстового) меню.
<br>
<br>&nbsp; &nbsp; &nbsp; Управляемое агентом обсуждение выгодно, когда ответ варьируется по
<br>&nbsp; &nbsp; &nbsp; общеиспользуемым характеристикам (таким как тип, язык, или
<br>&nbsp; &nbsp; &nbsp; кодирование), когда первоначальный сервер не способен определить
<br>&nbsp; &nbsp; &nbsp; возможности агента пользователя путем исследования запроса, и
<br>&nbsp; &nbsp; &nbsp; обычно при использовании общих кэшей для распределения нагрузки
<br>&nbsp; &nbsp; &nbsp; на сервер и уменьшения использования сети.
<br>
<br>&nbsp; &nbsp; &nbsp; Управляемое агентом обсуждение страдает тем, что для получения
<br>&nbsp; &nbsp; &nbsp; самого лучшего альтернативного представления требуется второй
<br>&nbsp; &nbsp; &nbsp; запрос. Этот второй запрос эффективен только тогда, когда
<br>&nbsp; &nbsp; &nbsp; используется кэширование. Кроме того, эта спецификация не
<br>&nbsp; &nbsp; &nbsp; определяет никакого механизма для обеспечения автоматического
<br>&nbsp; &nbsp; &nbsp; выбора, хотя также и не предотвращает разработку такого механизма
<br>&nbsp; &nbsp; &nbsp; в качестве расширения и использования в HTTP/1.1.
<br>
<br>&nbsp; &nbsp; &nbsp; HTTP/1.1 определяет коды состояния 300 (Множественный выбор,
<br>&nbsp; &nbsp; &nbsp; Multiple Choices) и 406 (Не приемлем, Not Acceptable) для
<br>&nbsp; &nbsp; &nbsp; обеспечения управляемого агентом обсуждения, когда сервер не
<br>&nbsp; &nbsp; &nbsp; желает или не способен обеспечить изменение ответа, используя
<br>&nbsp; &nbsp; &nbsp; управляемое сервером обсуждение.
<br>
<br>
<a name="117"></a><center><h2>12.3 Прозрачное обсуждение.</h2></center>
<br>
<br>&nbsp; &nbsp; &nbsp; Прозрачное обсуждение - это комбинация управляемого сервером и
<br>&nbsp; &nbsp; &nbsp; управляемого агентом обсуждения. Когда кэш обеспечен списком
<br>&nbsp; &nbsp; &nbsp; доступных представлений ответа (как при управляемом агентом
<br>&nbsp; &nbsp; &nbsp; обсуждении) и изменяющиеся характеристики полностью поняты кэшем,
<br>&nbsp; &nbsp; &nbsp; тогда он способен выполнять управляемое сервером обсуждение
<br>&nbsp; &nbsp; &nbsp; последующих запросов этого же ресурса от имени первоначального
<br>&nbsp; &nbsp; &nbsp; сервера.
<br>
<br>&nbsp; &nbsp; &nbsp; Прозрачное обсуждение имеет то преимущество, что работа по
<br>&nbsp; &nbsp; &nbsp; обсуждению распределяется. Когда кэш способен правильно
<br>&nbsp; &nbsp; &nbsp; предположить нужный ответ сокращается работа, которая раньше
<br>&nbsp; &nbsp; &nbsp; требовалась от первоначального сервера и не происходит задержки
<br>&nbsp; &nbsp; &nbsp; второго запроса, как при управляемом агентом обсуждении.
<br>
<br>&nbsp; &nbsp; &nbsp; Эта спецификация не определяет никакого механизма прозрачного
<br>&nbsp; &nbsp; &nbsp; обсуждения, хотя также и не предотвращает разработку такого
<br>&nbsp; &nbsp; &nbsp; механизма в качестве расширения и использования в HTTP/1.1.
<br>&nbsp; &nbsp; &nbsp; HTTP/1.1 кэш, выполняющий прозрачное обсуждение ДОЛЖЕН включать
<br>&nbsp; &nbsp; &nbsp; поле заголовка Vary (определяющее параметры, которые могут
<br>&nbsp; &nbsp; &nbsp; варьироваться) в ответ, если он кэшируем, чтобы гарантировать
<br>&nbsp; &nbsp; &nbsp; правильную интерпретацию всеми HTTP/1.1 клиентами. Информацию
<br>&nbsp; &nbsp; &nbsp; управляемого агентом обсуждения, представленную первоначальным
<br>&nbsp; &nbsp; &nbsp; сервером, СЛЕДУЕТ включать в ответ при прозрачном обсуждении.
<br>

</body></html>